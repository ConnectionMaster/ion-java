<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnifiedSavePointManagerX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">UnifiedSavePointManagerX.java</span></div><h1>UnifiedSavePointManagerX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2009-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;


/**
 *   These classes (UnifiedSavePointManager and the contained
 *   SavePoint) isolate the save point handing. Its effect spans
 *   both the input stream and the underlying buffer - so the manager
 *   keeps it's own reference to these.  By doing so this should
 *   make save points easier to use.  It grabs the buffer from
 *   the stream since it need a reference to the UnifiedInputBuffer
 *   on most calls and doesn't need an extra de-ref (mostly for
 *   code clarity)
 *
 *   The general life time of a save point is:
 *   . allocate a save point
 *   . . start the save point, which sets the start idx and pos - and
 *       pins the buffer pages with a use count
 *   . . mark_end the save point, which sets the end idx and pos
 *   . . . activate the save point, which sets the input streams pos
 *         to the start
 *   . . . deactivate the save point, which pops the save point stack
 *         and restores the stream to its previous position
 *   . . clear the save point. this clears its internal values and
 *       releases its use counter on the buffer. As the buffers in use
 *       count goes to zero it may release any unnecessary pages.
 *   . free the save point
 *
 *   this order of operation, as nested above, is enforced by checking
 *   the state of the save points and member values like the end position.
 *
 *   if the end position is not set it is treated as &quot;to end of file&quot;
 *
 */
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">final class UnifiedSavePointManagerX</span>
{
    private static final int FREE_LIST_LIMIT = 20;

    UnifiedInputStreamX  _stream;
    UnifiedInputBufferX  _buffer;
    SavePoint           _inuse;
    SavePoint           _free;
    int                 _free_count;
    SavePoint           _active_stack;
    int                 _open_save_points;

<span class="fc" id="L60">    public UnifiedSavePointManagerX(UnifiedInputStreamX  stream) {</span>
<span class="fc" id="L61">        _stream = stream;</span>
<span class="fc" id="L62">        _buffer = stream._buffer;</span>
<span class="fc" id="L63">        _inuse = null;</span>
<span class="fc" id="L64">        _free = null;</span>
<span class="fc" id="L65">        _active_stack = null;</span>
<span class="fc" id="L66">    }</span>

    public final boolean isSavePointOpen() {
<span class="fc bfc" id="L69" title="All 2 branches covered.">        return (_open_save_points &gt; 0);</span>
    }

    public final long lengthOf(SavePoint sp)
    {
<span class="fc" id="L74">        int start_idx = sp.getStartIdx();</span>
<span class="fc" id="L75">        int end_idx   = sp.getEndIdx();</span>

<span class="pc bpc" id="L77" title="2 of 4 branches missed.">        if (start_idx == -1 || end_idx == -1) {</span>
<span class="nc" id="L78">            return 0;</span>
        }

        long len;
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (start_idx == end_idx) {  // a very common case</span>
<span class="fc" id="L83">            int start_pos = sp.getStartPos();</span>
<span class="fc" id="L84">            int end_pos   = sp.getEndPos();</span>
<span class="fc" id="L85">            len = end_pos - start_pos;</span>
<span class="fc" id="L86">        }</span>
        else {
<span class="nc" id="L88">            UnifiedDataPageX start = _buffer.getPage(start_idx);</span>
<span class="nc" id="L89">            UnifiedDataPageX end   = _buffer.getPage(end_idx);</span>
<span class="nc" id="L90">            long start_pos = start.getFilePosition(sp.getStartPos());</span>
<span class="nc" id="L91">            long end_pos   = end.getFilePosition(sp.getEndPos());</span>
<span class="nc" id="L92">            len = end_pos - start_pos;</span>
        }
<span class="fc" id="L94">        return len;</span>
    }

    public final SavePoint savePointAllocate() {
        SavePoint sp;
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (_free != null) {</span>
<span class="nc" id="L100">            sp = _free;</span>
<span class="nc" id="L101">            _free = sp._next;</span>
<span class="nc" id="L102">            _free_count--;</span>
<span class="nc" id="L103">            sp.clear();</span>
        }
        else {
<span class="fc" id="L106">            sp = new SavePoint(this);</span>
        }
<span class="fc" id="L108">        sp._next = _inuse;</span>
<span class="fc" id="L109">        sp._prev = null;</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (_inuse != null) {</span>
<span class="nc" id="L111">            _inuse._prev = sp;</span>
        }
        else {
<span class="fc" id="L114">            _inuse = sp;</span>
        }
<span class="fc" id="L116">        return sp;</span>
    }
    public final void savePointFree(SavePoint sp)
    {
<span class="nc bnc" id="L120" title="All 4 branches missed.">        assert(sp.isClear());</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (_free_count &gt;= FREE_LIST_LIMIT) {</span>
            // by not putting this on the free list
            // the GC is free to clean it up.
<span class="nc" id="L125">            return;</span>
        }

<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (sp._prev == null) {</span>
<span class="nc" id="L129">            sp._prev = sp._next;</span>
        }
        else {
<span class="nc" id="L132">            _inuse = sp._next;</span>
        }
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (sp._next  != null) {</span>
<span class="nc" id="L135">            sp._next._prev = sp._prev;</span>
        }
<span class="nc" id="L137">        sp._next = _free;</span>
<span class="nc" id="L138">        _free = sp;</span>
<span class="nc" id="L139">        _free_count++;</span>
<span class="nc" id="L140">    }</span>
    public final SavePoint savePointActiveTop() {
<span class="fc" id="L142">        return _active_stack;</span>
    }

    public final void savePointPushActive(SavePoint sp, long line_number, long line_start) {
<span class="pc bpc" id="L146" title="2 of 4 branches missed.">        assert(!sp.isActive());</span>

<span class="fc" id="L148">        int      idx = _buffer.getCurrentPageIdx();</span>
<span class="fc" id="L149">        int      pos = _stream._pos;</span>
<span class="fc" id="L150">        int      limit = _stream._limit;</span>
<span class="fc" id="L151">        UnifiedDataPageX curr = _buffer.getPage(idx);</span>

        // save our current state in the Save Point so when
        // we pop it off we can restore our current state
<span class="fc" id="L155">        sp.set_prev_pos(idx, pos, limit, line_number, line_start);</span>

        // actually push this save point on the stack
<span class="fc" id="L158">        sp._next_active = _active_stack;</span>
<span class="fc" id="L159">        _active_stack = sp;</span>
<span class="fc" id="L160">        sp.set_active();</span>

        // if the start page is also the last page we
        // need set the limit to the sp end, otherwise
        // we use the limit from the page and we'll
        // deal with the last page when we get to it
<span class="fc" id="L166">        idx = sp.getStartIdx();</span>
<span class="fc" id="L167">        pos = sp.getStartPos();</span>
<span class="fc" id="L168">        curr = _buffer.getPage(idx);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (sp.getEndIdx() != sp.getStartIdx()) {</span>
<span class="fc" id="L170">            limit = curr.getBufferLimit();</span>
        }
        else {
<span class="fc" id="L173">            limit = sp.getEndPos();</span>
        }
<span class="fc" id="L175">        _stream.make_page_current(curr, idx, pos, limit);</span>
<span class="fc" id="L176">    }</span>

    public final void savePointPopActive(SavePoint sp)
    {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (sp != _active_stack) {</span>
<span class="nc" id="L181">            throw new IllegalArgumentException(&quot;save point being released isn't currently active&quot;);</span>
        }

<span class="fc" id="L184">        _active_stack = sp._next_active;</span>
<span class="fc" id="L185">        sp._next_active = null;</span>
<span class="fc" id="L186">        sp.set_inactive();</span>

<span class="fc" id="L188">        _stream.save_point_reset_to_prev(sp);</span>

<span class="fc" id="L190">        return;</span>
    }

    private void save_point_clear(SavePoint sp)
    {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (sp.isClear()) {</span>
<span class="nc" id="L196">            return;</span>
        }
<span class="fc" id="L198">        int start_idx = sp.getStartIdx();</span>
<span class="fc" id="L199">        int end_idx = sp.getEndIdx();</span>
<span class="pc bpc" id="L200" title="1 of 4 branches missed.">        if (end_idx != -1 || start_idx != -1) {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            if (start_idx != -1) {</span>
<span class="fc" id="L202">                _open_save_points--;</span>
<span class="fc" id="L203">                save_point_unpin(sp);</span>
            }
        }
<span class="fc" id="L206">    }</span>
    private final void save_point_unpin(SavePoint sp) {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (sp.isActive()) {</span>
<span class="nc" id="L209">            throw new IllegalArgumentException(&quot;you can't release an active save point&quot;);</span>
        }
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">        assert(sp.isDefined());</span>

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (_buffer.decLock()) {</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">            if (_open_save_points == 0) {</span>
<span class="fc" id="L215">                _buffer.resetToCurrentPage();</span>
            }
        }
<span class="fc" id="L218">        return;</span>
    }
    private final SavePoint save_point_start(SavePoint sp, long line_number, long line_start) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (sp.isDefined()) {</span>
<span class="nc" id="L222">            throw new IllegalArgumentException(&quot;you can't start an active save point&quot;);</span>
        }

<span class="fc" id="L225">        int new_pinned_idx = _buffer.getCurrentPageIdx();</span>
<span class="fc" id="L226">        _buffer.incLock();</span>
<span class="fc" id="L227">        sp.set_start_pos(new_pinned_idx,_stream._pos, line_number, line_start);</span>
<span class="fc" id="L228">        _open_save_points++;</span>

<span class="fc" id="L230">        return sp;</span>
    }
    private final void save_point_mark_end(SavePoint sp, int offset) {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (sp.isActive()) {</span>
<span class="nc" id="L234">            throw new IllegalArgumentException(&quot;you can't start an active save point&quot;);</span>
        }

<span class="fc" id="L237">        UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L238">        int curr_idx = _buffer.getCurrentPageIdx();</span>
<span class="fc" id="L239">        int curr_pos = _stream._pos + offset;</span>

        // this adjusts the current page idx and pos (in the page buffer)
        // to handle the end point being offset from the current pos
        // since that may result in the end mark referencing a different page
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (offset != 0) {</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">            if (curr_pos &gt;= curr.getBufferLimit()) {</span>
<span class="nc" id="L246">                curr_pos -= curr.getOriginalStartingOffset();</span>
<span class="nc" id="L247">                curr_idx++;</span>
<span class="nc" id="L248">                curr = _buffer.getPage(curr_idx);</span>
            }
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">            else if (curr_pos &lt; curr.getStartingOffset()) {</span>
<span class="nc" id="L251">                int pos_offset = curr_pos - curr.getOriginalStartingOffset();</span>
<span class="nc" id="L252">                curr_idx--;</span>
<span class="nc" id="L253">                curr = _buffer.getPage(curr_idx);</span>
<span class="nc" id="L254">                curr_pos = curr.getBufferLimit() - pos_offset;</span>
            }
<span class="pc bpc" id="L256" title="3 of 6 branches missed.">            if (curr == null || curr_pos &gt;= curr.getBufferLimit() || curr_pos &lt; curr.getStartingOffset()) {</span>
<span class="nc" id="L257">                end_point_too_far(curr_idx);</span>
            }
        }

<span class="fc" id="L261">        sp.set_end_pos(curr_idx, curr_pos); // we may be &quot;re-setting&quot; the idx (that's ok)</span>

<span class="fc" id="L263">        return;</span>
    }
    private final void end_point_too_far(int curr_idx) {
<span class="nc" id="L266">        String message = &quot;end point [&quot;</span>
                       + curr_idx
                       + &quot;] must be within 1 page of current [&quot;
<span class="nc" id="L269">                       + _buffer.getCurrentPageIdx()</span>
                       + &quot;]&quot;;
<span class="nc" id="L271">        throw new IllegalArgumentException(message);</span>
    }

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">    public static class SavePoint</span>
    {
<span class="fc" id="L276">        public enum SavePointState { CLEAR, DEFINED, ACTIVE }</span>

        private UnifiedSavePointManagerX _owner;
        private SavePointState   _state;
        private int              _start_idx, _start_pos;
        private long             _start_line_count;
        private long             _start_line_start;
        private int              _end_idx, _end_pos;
        private int              _prev_idx, _prev_pos, _prev_limit;
        private long             _prev_line_count;
        private long             _prev_line_start;
        private SavePoint        _next, _prev;
        private SavePoint        _next_active;

<span class="fc" id="L290">        SavePoint(UnifiedSavePointManagerX owner) {</span>
<span class="fc" id="L291">            clear();</span>
<span class="fc" id="L292">            _owner = owner;</span>
<span class="fc" id="L293">        }</span>
        private final void set_start_pos(int idx, int pos, long line_count, long line_start) {
<span class="pc bpc" id="L295" title="2 of 4 branches missed.">            assert(_state == SavePointState.CLEAR);</span>
<span class="fc" id="L296">            _state = SavePointState.DEFINED;</span>
<span class="fc" id="L297">            _start_idx = idx;</span>
<span class="fc" id="L298">            _start_pos = pos;</span>
<span class="fc" id="L299">            _start_line_count = line_count;</span>
<span class="fc" id="L300">            _start_line_start = line_start;</span>
<span class="fc" id="L301">        }</span>
        private final void set_end_pos(int idx, int pos) {
<span class="pc bpc" id="L303" title="2 of 4 branches missed.">            assert(_state == SavePointState.DEFINED);</span>
<span class="fc" id="L304">            _end_idx = idx;</span>
<span class="fc" id="L305">            _end_pos = pos;</span>
<span class="fc" id="L306">        }</span>
        private final void set_prev_pos(int idx, int pos, int limit, long line_count, long line_start) {
<span class="pc bpc" id="L308" title="2 of 4 branches missed.">            assert(_state == SavePointState.DEFINED);</span>
<span class="fc" id="L309">            _prev_idx = idx;</span>
<span class="fc" id="L310">            _prev_pos = pos;</span>
<span class="fc" id="L311">            _prev_limit = limit;</span>
<span class="fc" id="L312">            _prev_line_count = line_count;</span>
<span class="fc" id="L313">            _prev_line_start = line_start;</span>
<span class="fc" id="L314">        }</span>

        public final void clear() {
<span class="pc bpc" id="L317" title="2 of 4 branches missed.">            assert(_state != SavePointState.ACTIVE);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (isDefined()) {</span>
<span class="fc" id="L319">                _owner.save_point_clear(this);</span>
            }
<span class="fc" id="L321">            _state = SavePointState.CLEAR;</span>
<span class="fc" id="L322">            _start_idx = -1;</span>
<span class="fc" id="L323">            _end_idx = -1;</span>
<span class="fc" id="L324">            _prev_idx = -1;</span>
<span class="fc" id="L325">        }</span>
        public final void start(long line_number, long line_start) {
<span class="fc" id="L327">            _owner.save_point_start(this, line_number, line_start);</span>
<span class="fc" id="L328">        }</span>
        public final void markEnd() {
<span class="fc" id="L330">            _owner.save_point_mark_end(this, 0);</span>
<span class="fc" id="L331">        }</span>
        public final void markEnd(int offset) {
<span class="fc" id="L333">            _owner.save_point_mark_end(this, offset);</span>
<span class="fc" id="L334">        }</span>
        public final void free() {
<span class="nc" id="L336">            _owner.savePointFree(this);</span>
<span class="nc" id="L337">        }</span>
        public final boolean isClear() {
<span class="fc bfc" id="L339" title="All 2 branches covered.">            return (_state == SavePointState.CLEAR);</span>
        }
        public final boolean isDefined() {
<span class="pc bpc" id="L342" title="1 of 4 branches missed.">            return (_state == SavePointState.DEFINED || _state == SavePointState.ACTIVE);</span>
        }
        public final boolean isActive() {
<span class="fc bfc" id="L345" title="All 2 branches covered.">            return (_state == SavePointState.ACTIVE);</span>
        }
        public final void set_active() {
<span class="pc bpc" id="L348" title="2 of 4 branches missed.">            assert(_state == SavePointState.DEFINED);</span>
<span class="fc" id="L349">            _state = SavePointState.ACTIVE;</span>
<span class="fc" id="L350">        }</span>
        public final void set_inactive() {
<span class="pc bpc" id="L352" title="2 of 4 branches missed.">            assert(_state == SavePointState.ACTIVE);</span>
<span class="fc" id="L353">            _state = SavePointState.DEFINED;</span>
<span class="fc" id="L354">        }</span>
        public final long length() {
<span class="pc bpc" id="L356" title="2 of 4 branches missed.">            if (_start_idx == -1 || _end_idx == -1) {</span>
<span class="nc" id="L357">                return 0;</span>
            }
<span class="fc" id="L359">            return _owner.lengthOf(this);</span>
        }

        public final int getStartIdx() {
<span class="fc" id="L363">            return _start_idx;</span>
        }
        public final int getStartPos() {
<span class="pc bpc" id="L366" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L367">            return _start_pos;</span>
        }
        public final long getStartLineNumber() {
<span class="fc" id="L370">            return _start_line_count;</span>
        }
        public final long getStartLineStart() {
<span class="fc" id="L373">            return _start_line_start;</span>
        }
        public final long getStartFilePosition() {
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (_start_idx == -1) return -1;</span>
<span class="nc" id="L377">            UnifiedDataPageX p = _owner._buffer.getPage(_start_idx);</span>
<span class="nc" id="L378">            return p.getFilePosition(_start_pos);</span>
        }
        public final int getEndIdx() {
<span class="fc" id="L381">            return _end_idx;</span>
        }
        public final int getEndPos() {
<span class="pc bpc" id="L384" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L385">            return _end_pos;</span>
        }
        public final long getEndFilePosition() {
<span class="nc bnc" id="L388" title="All 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (_end_idx == -1) return -1;</span>
<span class="nc" id="L390">            UnifiedDataPageX p = _owner._buffer.getPage(_end_idx);</span>
<span class="nc" id="L391">            return p.getFilePosition(_end_pos);</span>
        }
        public final int getPrevIdx() {
<span class="fc" id="L394">            return _prev_idx;</span>
        }
        public final int getPrevPos() {
<span class="pc bpc" id="L397" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L398">            return _prev_pos;</span>
        }
        public final int getPrevLimit() {
<span class="pc bpc" id="L401" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L402">            return _prev_limit;</span>
        }
        public final long getPrevLineNumber() {
<span class="fc" id="L405">            return _prev_line_count;</span>
        }
        public final long getPrevLineStart() {
<span class="fc" id="L408">            return _prev_line_start;</span>
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>