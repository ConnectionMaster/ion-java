<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OutputStreamFastAppendable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">OutputStreamFastAppendable.java</span></div><h1>OutputStreamFastAppendable.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.impl.PrivateIonConstants.makeUnicodeScalar;

import java.io.Closeable;
import java.io.Flushable;
import java.io.IOException;
import java.io.OutputStream;
import software.amazon.ion.util.PrivateFastAppendable;

/**
 * Adapts an {@link OutputStream} to implement {@link PrivateFastAppendable}.
 * &lt;b&gt;This always outputs UTF-8!&lt;/b&gt;
 */
<span class="pc bpc" id="L29" title="1 of 2 branches missed.">final class OutputStreamFastAppendable</span>
    implements PrivateFastAppendable, Closeable, Flushable
{
    private static final int MAX_BYTES_LEN = 4096;

    private final OutputStream _out;

    /** Aggregates bytes so we can write to {@link #_out} in large batches. */
    private final byte[] _byteBuffer;

    /** Position in {@link #_byteBuffer} where we'll write the next byte. */
    private int _pos;

    OutputStreamFastAppendable(OutputStream out)
<span class="fc" id="L43">    {</span>
<span class="fc" id="L44">        out.getClass(); // Efficient null check</span>

<span class="fc" id="L46">        _out = out;</span>
<span class="fc" id="L47">        _pos = 0;</span>
<span class="fc" id="L48">        _byteBuffer = new byte[MAX_BYTES_LEN];</span>
<span class="fc" id="L49">    }</span>

    // ------------------- FastAppendable Appendable Methods -------------------
    public Appendable append(char c)
        throws IOException
    {
        // Choose what method to use depending on type of character.
<span class="nc bnc" id="L56" title="All 2 branches missed.">        if (c &lt; 0x80) {</span>
<span class="nc" id="L57">            appendAscii(c);</span>
        } else {
<span class="nc" id="L59">            appendUtf16(c);</span>
        }
<span class="nc" id="L61">        return this;</span>
    }

    public Appendable append(CharSequence csq)
        throws IOException
    {
<span class="nc" id="L67">        append(csq, 0, csq.length());</span>
<span class="nc" id="L68">        return this;</span>
    }

    public Appendable append(CharSequence csq, int start, int end)
        throws IOException
    {
<span class="nc bnc" id="L74" title="All 2 branches missed.">        for (int ii = start; ii &lt; end; ++ii) {</span>
<span class="nc" id="L75">            append(csq.charAt(ii));</span>
        }
<span class="nc" id="L77">        return this;</span>
    }

    public final void appendAscii(char c)
        throws IOException
    {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (_pos == _byteBuffer.length) {</span>
<span class="nc" id="L84">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="nc" id="L85">            _pos = 0;</span>
        }
<span class="pc bpc" id="L87" title="2 of 4 branches missed.">        assert c &lt; 0x80;</span>
<span class="fc" id="L88">        _byteBuffer[_pos++] = (byte)c;</span>
<span class="fc" id="L89">    }</span>

    public final void appendAscii(CharSequence csq)
        throws IOException
    {
<span class="fc" id="L94">        appendAscii(csq, 0, csq.length());</span>
<span class="fc" id="L95">    }</span>

    @SuppressWarnings(&quot;deprecation&quot;)
    public final void appendAscii(CharSequence csq, int start, int end)
        throws IOException
    {
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (csq instanceof String) {</span>
            // Using deprecated String.getBytes intentionally, since it is
            // correct behavior in this case, and much faster.
<span class="fc" id="L104">            String str = (String)csq;</span>
<span class="fc" id="L105">            int len = end - start;</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            if (_pos + len &lt; _byteBuffer.length) {</span>
                // put String bytes directly into buffer
<span class="fc" id="L108">                str.getBytes(start, end, _byteBuffer, _pos);</span>
<span class="fc" id="L109">                _pos += len;</span>
            } else {
                do {
                    // flush the buffer on every loop
<span class="fc" id="L113">                    _out.write(_byteBuffer, 0, _pos);</span>
                    // check if we still need to split into chunks
<span class="fc bfc" id="L115" title="All 2 branches covered.">                    _pos = (end - start &gt; _byteBuffer.length</span>
<span class="fc" id="L116">                                ? _byteBuffer.length</span>
<span class="fc" id="L117">                                : end - start);</span>
<span class="fc" id="L118">                    str.getBytes(start, start + _pos, _byteBuffer, 0);</span>
<span class="fc" id="L119">                    start += _pos;</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                } while (start &lt; end);</span>
            }
<span class="fc" id="L122">        } else {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            for (int ii=start; ii &lt; end; ii++) {</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                if (_pos == _byteBuffer.length) {</span>
<span class="nc" id="L125">                    _out.write(_byteBuffer, 0, _pos);</span>
<span class="nc" id="L126">                    _pos = 0;</span>
                }
<span class="fc" id="L128">                char c = csq.charAt(ii);</span>
<span class="pc bpc" id="L129" title="2 of 4 branches missed.">                assert c &lt; 0x80;</span>
<span class="fc" id="L130">                _byteBuffer[_pos++] = (byte)c;</span>
            }
        }
<span class="fc" id="L133">    }</span>

    public final void appendUtf16(char c)
        throws IOException
    {
<span class="pc bpc" id="L138" title="2 of 4 branches missed.">        assert c &gt;= 0x80;</span>

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (_pos &gt; _byteBuffer.length - 3) {</span>
<span class="nc" id="L141">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="nc" id="L142">            _pos = 0;</span>
        }

<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (c &lt; 0x800) {</span>
<span class="fc" id="L146">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0xC0 | ( c &gt;&gt; 6        )) );</span>
<span class="fc" id="L147">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ( c       &amp; 0x3F)) );</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        } else if (c &lt; 0x10000) {</span>
<span class="fc" id="L149">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0xE0 | ( c &gt;&gt; 12       )) );</span>
<span class="fc" id="L150">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ((c &gt;&gt; 6) &amp; 0x3F)) );</span>
<span class="fc" id="L151">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ( c       &amp; 0x3F)) );</span>
        }
<span class="fc" id="L153">    }</span>

    public final void appendUtf16Surrogate(char leadSurrogate,
                                           char trailSurrogate)
        throws IOException
    {
        // Here we must convert a UTF-16 surrogate pair to UTF-8 bytes.

<span class="fc" id="L161">        int c = makeUnicodeScalar(leadSurrogate, trailSurrogate);</span>
<span class="pc bpc" id="L162" title="2 of 4 branches missed.">        assert c &gt;= 0x10000;</span>

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (_pos &gt; _byteBuffer.length - 4) {</span>
<span class="nc" id="L165">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="nc" id="L166">            _pos = 0;</span>
        }

<span class="fc" id="L169">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0xF0 | ( c &gt;&gt; 18        )) );</span>
<span class="fc" id="L170">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ((c &gt;&gt; 12) &amp; 0x3F)) );</span>
<span class="fc" id="L171">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ((c &gt;&gt; 6)  &amp; 0x3F)) );</span>
<span class="fc" id="L172">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ( c        &amp; 0x3F)) );</span>
<span class="fc" id="L173">    }</span>


    public final void flush()
        throws IOException
    {
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (_pos &gt; 0) {</span>
<span class="fc" id="L180">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="fc" id="L181">            _pos = 0;</span>
        }
<span class="fc" id="L183">        _out.flush();</span>
<span class="fc" id="L184">    }</span>

    public final void close()
        throws IOException
    {
        try
        {
<span class="fc" id="L191">            flush();</span>
        }
        finally
        {
<span class="fc" id="L195">            _out.close();</span>
        }
<span class="fc" id="L197">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>