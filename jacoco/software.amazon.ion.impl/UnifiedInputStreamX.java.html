<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnifiedInputStreamX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">UnifiedInputStreamX.java</span></div><h1>UnifiedInputStreamX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2009-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import software.amazon.ion.impl.IonReaderTextRawTokensX.IonReaderTextTokenException;
import software.amazon.ion.impl.UnifiedSavePointManagerX.SavePoint;

/**
 * This is a local stream abstraction, and implementation, that
 * allows the calling code to operate over final methods even
 * when the original data source is an interface, such a
 * &lt;code&gt;Reader&lt;/code&gt;.
 *
 * When passed a users data buffer it simply operates of the
 * entire buffer directly.
 *
 * When the input source is a stream is creates it's own local
 * buffers, using {@link #UnifiedInputBufferX} and {@link #UnifiedDataPageX}.
 * These allocate pages and loads them, a page at a time, from
 * the stream using the highest bandwidth stream interface available.
 *
 * In this class the unread is only allowed to unread characters
 * that it actually read.  This is checked, when possible, when
 * the local {@link #_debug} is true.  This is checked when
 * the unread is bad into data that is present in the current
 * buffer.  When the unread crosses a buffer boundary the unread
 * value is simply written into the space at the beginning of the
 * block, which is reserved for that purpose.  On all system
 * allocated pages the user data starts at an offset in from
 * the front of the buffer,  The offset is set by {@link #UNREAD_LIMIT}.
 * This is not necessary at either the beginning of the input
 * or for a user supplied buffer since the entire input is a
 * single buffer.
 *
 */
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">abstract class UnifiedInputStreamX</span>
    implements Closeable
{
    public static final int      EOF = -1;

    private static final boolean _debug = false;
            static final int     UNREAD_LIMIT = 10;

    static int DEFAULT_PAGE_SIZE;
    static {
        if (_debug) {
            DEFAULT_PAGE_SIZE = 32;
        }
        else {
<span class="fc" id="L66">            DEFAULT_PAGE_SIZE = 32*1024;</span>
        }
<span class="fc" id="L68">    }</span>

    //
    // member variables
    //
    boolean                 _eof;
    boolean                 _is_byte_data;
    boolean                 _is_stream;

    UnifiedInputBufferX      _buffer;
    int                     _max_char_value;
    int                     _pos;
    int                     _limit;

    // only 1 of these will be filled in depending on whether this is a byte
    // source or a character source
    Reader                  _reader;
    InputStream             _stream;
    byte[]                  _bytes;
    char[]                  _chars;


    UnifiedSavePointManagerX _save_points;


    // factories to construct an appropriate input stream
    // based on the input source
    public static UnifiedInputStreamX makeStream(CharSequence chars) {
<span class="fc" id="L96">        return new FromCharArray(chars, 0, chars.length());</span>
    }
    public static UnifiedInputStreamX makeStream(CharSequence chars, int offset, int length) {
<span class="nc" id="L99">        return new FromCharArray(chars, offset, length);</span>
    }
    public static UnifiedInputStreamX makeStream(char[] chars) {
<span class="nc" id="L102">        return new FromCharArray(chars, 0, chars.length);</span>
    }
    public static UnifiedInputStreamX makeStream(char[] chars, int offset, int length) {
<span class="fc" id="L105">        return new FromCharArray(chars, offset, length);</span>
    }
    public static UnifiedInputStreamX makeStream(Reader reader) throws IOException {
<span class="fc" id="L108">        return new FromCharStream(reader);</span>
    }
    public static UnifiedInputStreamX makeStream(byte[] buffer) {
<span class="nc" id="L111">        return new FromByteArray(buffer, 0, buffer.length);</span>
    }
    public static UnifiedInputStreamX makeStream(byte[] buffer, int offset, int length) {
<span class="fc" id="L114">        return new FromByteArray(buffer, offset, length);</span>
    }
    public static UnifiedInputStreamX makeStream(InputStream stream) throws IOException {
<span class="fc" id="L117">        return new FromByteStream(stream);</span>
    }
<span class="nc" id="L119">    public final InputStream getInputStream() { return _stream; }</span>
<span class="nc" id="L120">    public final Reader      getReader()      { return _reader; }</span>
<span class="fc" id="L121">    public final byte[]      getByteArray()   { return _bytes; }</span>
<span class="fc" id="L122">    public final char[]      getCharArray()   { return _chars; }</span>

    private final void init() {
        // _state = UIS_STATE.STATE_READING;
<span class="fc" id="L126">        _eof = false;</span>
<span class="fc" id="L127">        _max_char_value = _buffer.maxValue();</span>
<span class="fc" id="L128">        _save_points = new UnifiedSavePointManagerX(this);</span>
<span class="fc" id="L129">    }</span>

    public void close()
        throws IOException
    {
<span class="fc" id="L134">        _eof = true;</span>
<span class="fc" id="L135">        _buffer.clear();</span>
<span class="fc" id="L136">    }</span>

    public final boolean isEOF() {
<span class="fc" id="L139">        return _eof; // (_state == UIS_STATE.STATE_EOF);</span>
    }

    /**
     * used to find the current position of this stream in the
     * input source.
     * @return current &quot;file&quot; position
     */
    public long getPosition() {
<span class="fc" id="L148">        long file_pos = 0;</span>
<span class="fc" id="L149">        UnifiedDataPageX page = _buffer.getCurrentPage();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (page != null) {</span>
<span class="fc" id="L151">            file_pos = page.getFilePosition(_pos);</span>
        }
<span class="fc" id="L153">        return file_pos;</span>
    }

    /*
     * save point handling - most of the heavy lifting is handled
     * by the PageBuffer.  The local offset in the current page
     * is added by these routines (from the local member _pos)
     * when needed by the save point handling.
     *
     * these covers also handle keeping _save_point_active and
     * _save_point_limit up to date as they handle their normal
     * work.
     *
     * savepoints were not intended to overlap (save in a save
     * point) so while there isn't any obvious or intentional
     * reason this won't work, it's not planned for nor tested
     * and, therefore, likely to have problems.  There is no
     * need for overlapping save point for the parsing case.
     */
    public final SavePoint savePointAllocate() {
<span class="fc" id="L173">        SavePoint sp = _save_points.savePointAllocate();</span>
<span class="fc" id="L174">        return sp;</span>
    }

    protected final void save_point_reset_to_prev(SavePoint sp)
    {
<span class="fc" id="L179">        int             idx = sp.getPrevIdx();</span>
<span class="fc" id="L180">        UnifiedDataPageX curr = _buffer.getPage(idx);</span>
<span class="fc" id="L181">        int             pos = sp.getPrevPos();</span>
<span class="fc" id="L182">        int             limit = sp.getPrevLimit();</span>

<span class="fc" id="L184">        make_page_current(curr, idx, pos, limit);</span>
<span class="fc" id="L185">    }</span>

    protected final void make_page_current(UnifiedDataPageX curr, int idx, int pos, int limit)
    {
<span class="fc" id="L189">        _limit = limit;</span>
<span class="fc" id="L190">        _pos = pos;</span>
<span class="fc" id="L191">        _eof = false;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (is_byte_data()) {</span>
<span class="fc" id="L193">            _bytes = curr.getByteBuffer();</span>
        }
        else {
<span class="fc" id="L196">            _chars = curr.getCharBuffer();</span>
        }
<span class="fc" id="L198">        _buffer.setCurrentPage(idx, curr);</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (pos &gt; limit) {</span>
<span class="nc" id="L200">            refill_is_eof();</span>
<span class="nc" id="L201">            return;</span>
        }
<span class="fc" id="L203">    }</span>

    private final boolean is_byte_data() {
<span class="fc" id="L206">        return _is_byte_data;</span>
    }
    public final void unread(int c)
    {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (c == -1) {</span>
<span class="fc" id="L211">            return;</span>
        }
<span class="pc bpc" id="L213" title="2 of 4 branches missed.">        else if (c &lt; 0 || c &gt; _max_char_value) {</span>
<span class="nc" id="L214">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (_eof) {</span>
<span class="fc" id="L217">            _eof = false;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (_limit == -1) {</span>
<span class="fc" id="L219">                _limit = _pos;</span>
            }
        }
<span class="fc" id="L222">        _pos--;</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (_pos &gt;= 0) {</span>
<span class="fc" id="L224">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (_pos &lt; curr.getStartingOffset()) {</span>
                // here we've backed up past the beginning of the current
                // buffer.  This can only happen when this is a system
                // managed buffer, not a use supplied buffer (which has
                // only one page).  Or when the user has backed up past
                // the actual beginning of the input - which is an error.
<span class="fc" id="L231">                curr.inc_unread_count();</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">                if (is_byte_data()) {</span>
<span class="fc" id="L233">                    _bytes[_pos] = (byte)c;</span>
                }
                else {
<span class="fc" id="L236">                    _chars[_pos] = (char)c;</span>
                }
            }
            else {
                // we only allow unreading the character that was actually
                // read - and when we can, we verify this.  We will miss
                // cases when the character was in the preceding buffer
                // (handled above) when we just have to believe them.
                // TODO: add test only code that checks the previous buffer
                //       case.
<span class="fc" id="L246">                verify_matched_unread(c);</span>
            }
<span class="fc" id="L248">        }</span>
        else {
            // We don't seem to check for that elsewhere.
<span class="nc" id="L251">            _buffer.putCharAt(getPosition(), c);</span>
        }
<span class="fc" id="L253">    }</span>
    private final void verify_matched_unread(int c) {
        if (_debug) {
            if (is_byte_data()) {
                assert(_bytes[_pos] == (byte)c);
            }
            else {
                assert(_chars[_pos] == (char)c);
            }
        }
<span class="fc" id="L263">    }</span>
    public final boolean unread_optional_cr()
    {
<span class="nc" id="L266">        boolean did_unread = false;</span>
<span class="nc" id="L267">        UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
        int c;

        // if we're in the current buffer and we unread a
        // new line and we can see we were preceded by a
        // carriage return in which case we need to back up
        // 1 more position.
        // If we can't back up into a real data we don't
        // care about this since our next unread/read will
        // be work the same anyway since a new line will
        // just be a lone new line.
        // This corrects bug where the scanner reads a char
        // then a \r\n unreads the \n (the \r was eaten by
        // read()) unreads the char and that overwrites
        // the \r and has editted the buffer.  That's a bad
        // thing.
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (_pos &gt; curr.getStartingOffset()) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (is_byte_data()) {</span>
<span class="nc" id="L285">                c = _bytes[_pos-1] &amp; 0xff;</span>
            }
            else {
<span class="nc" id="L288">                c = _chars[_pos-1];</span>
            }
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (c == '\r') {</span>
<span class="nc" id="L291">                _pos--;</span>
            }
        }
<span class="nc" id="L294">        return did_unread;</span>
    }

    public final int read() throws IOException {
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (_pos &gt;= _limit) return read_helper();</span>
        // both bytes and chars might be null if this is empty input
        // otherwise we should have 1, and only 1, of these buffers set
<span class="pc bpc" id="L301" title="2 of 8 branches missed.">        assert((_bytes == null) ^ (_chars == null));</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        return (_is_byte_data) ? (_bytes[_pos++] &amp; 0xff) : _chars[_pos++];</span>
    }

    protected final int read_helper() throws IOException
    {
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (_eof) {</span>
<span class="fc" id="L308">            return EOF;</span>
        }
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (refill_helper()) {</span>
<span class="fc" id="L311">            return EOF;</span>
        }

<span class="fc bfc" id="L314" title="All 2 branches covered.">        int c = (is_byte_data()) ? (_bytes[_pos++] &amp; 0xff) : _chars[_pos++];</span>
<span class="fc" id="L315">        return c;</span>
    }

    private final boolean refill_helper() throws IOException
    {
<span class="fc" id="L320">        _limit = refill();</span>
        // done in refill: _pos = _buffer.getCurrentPage().getOriginalStartingOffset();
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (_pos &gt;= _limit) {</span>
<span class="fc" id="L323">            _eof = true;</span>
<span class="fc" id="L324">            return true;</span>
        }
<span class="fc" id="L326">        return false;</span>
    }

    public final void skip(int skipDistance) throws IOException
    {
<span class="fc" id="L331">        int remaining = _limit - _pos;</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (remaining &gt;= skipDistance) {</span>
<span class="fc" id="L334">            _pos += skipDistance;</span>
<span class="fc" id="L335">            remaining = 0;</span>
        }
        else {
<span class="fc" id="L338">            remaining = skipDistance;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            while (remaining &gt; 0) {</span>
<span class="fc" id="L340">                int ready = _limit - _pos;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">                if (ready &gt; remaining) {</span>
<span class="fc" id="L342">                    ready = remaining;</span>
                }
<span class="fc" id="L344">                _pos += ready;</span>
<span class="fc" id="L345">                remaining -= ready;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                if (remaining &gt; 0) {</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                    if (refill_helper()) {</span>
<span class="fc" id="L348">                        break;</span>
                    }
                }
<span class="fc" id="L351">            }</span>
        }
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (remaining &gt; 0) {</span>
<span class="fc" id="L354">            String message = &quot;unexpected EOF encountered during skip of &quot;</span>
                           + skipDistance
                           + &quot; at position &quot;
<span class="fc" id="L357">                           + getPosition();</span>
<span class="fc" id="L358">            throw new IOException(message);</span>
        }
<span class="fc" id="L360">        return;</span>
    }
    // NB this method does not follow the contract of InputStream.read, it will return 0 at EOF
    //    It is unclear what the implication to the rest of the system to make it 'conform'
    public final int read(byte[] dst, int offset, int length) throws IOException
    {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (!is_byte_data()) {</span>
<span class="nc" id="L367">            throw new IOException(&quot;byte read is not support over character sources&quot;);</span>
        }
<span class="fc" id="L369">        int remaining = length;</span>
<span class="pc bpc" id="L370" title="1 of 4 branches missed.">        while (remaining &gt; 0 &amp;&amp; !isEOF()) {</span>
<span class="fc" id="L371">            int ready = _limit - _pos;</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">            if (ready &gt; remaining) {</span>
<span class="fc" id="L373">                ready = remaining;</span>
            }
<span class="fc" id="L375">            System.arraycopy(_bytes, _pos, dst, offset, ready);</span>
<span class="fc" id="L376">            _pos += ready;</span>
<span class="fc" id="L377">            offset += ready;</span>
<span class="fc" id="L378">            remaining -= ready;</span>
<span class="pc bpc" id="L379" title="2 of 6 branches missed.">            if (remaining == 0 || _pos &lt; _limit || refill_helper()) {</span>
<span class="fc" id="L380">                break;</span>
            }
<span class="nc" id="L382">        }</span>
<span class="fc" id="L383">        return length - remaining;</span>
    }
    private int read_utf8(int c) throws IOException
    {
<span class="nc" id="L387">        int len = IonUTF8.getUTF8LengthFromFirstByte(c);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (int ii=1; ii&lt;len; ii++) {</span>
<span class="nc" id="L389">            int c2 = read();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (c2 == -1) {</span>
<span class="nc" id="L391">                throw new IonReaderTextTokenException(&quot;invalid UTF8 sequence encountered in stream&quot;);</span>
            }
<span class="nc" id="L393">            c |= (c2 &lt;&lt; (ii*8));</span>
        }
<span class="nc" id="L395">        c = IonUTF8.getScalarFrom4BytesReversed(c);</span>
<span class="nc" id="L396">        return c;</span>
    }

    /**
     * the refill method is the key override that is filled in by
     * the various subclasses.  It fills either the byte or char
     * array with a block of data from the input source.  As this
     * is a virtual function the right version will get called for
     * each source type.  Since it is only called once per block,
     * and from then on the final method which pulls data from
     * the block can return the value this should be a reasonable
     * performance trade off.
     * @return first value from the refilled input source or EOF
     * @throws IOException
     */
    protected int refill() throws IOException
    {
<span class="fc" id="L413">        UnifiedDataPageX  curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L414">        SavePoint sp = _save_points.savePointActiveTop();</span>

<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (!can_fill_new_page()) {</span>
            // aka: there can be only one!
            // (and it's used up)
<span class="fc" id="L419">            return refill_is_eof();</span>
        }

<span class="pc bpc" id="L422" title="1 of 4 branches missed.">        if (sp != null &amp;&amp; sp.getEndIdx() == _buffer.getCurrentPageIdx()) {</span>
            // also EOF but the case is odd enough to call it out
<span class="fc" id="L424">            return refill_is_eof();</span>
        }

        long file_position;
<span class="fc" id="L428">        int start_pos = UNREAD_LIMIT;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (curr == null) {</span>
<span class="fc" id="L430">            file_position = 0;</span>
<span class="fc" id="L431">            start_pos = 0;</span>
        }
        else {
<span class="fc" id="L434">            file_position = curr.getFilePosition(_pos);</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            if (file_position == 0) {</span>
                // unread before the beginning of file is not allowed,
                // so we don't have to leave room for it
<span class="nc" id="L438">                start_pos = 0;</span>
            }
        }

        // see if we are re-reading saved buffers
<span class="fc" id="L443">        int new_idx = _buffer.getNextFilledPageIdx();</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (new_idx &lt; 0) {</span>
            // there is no pre-filled page waiting for us, so we need to
            // read new data on a new page or over our current page
<span class="fc" id="L447">            curr = _buffer.getCurrentPage();</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">            boolean needs_new_page = (curr == null);</span>
<span class="fc" id="L449">            new_idx = _buffer.getCurrentPageIdx();</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if (_save_points.isSavePointOpen()) {</span>
<span class="fc" id="L451">                new_idx++;</span>
<span class="fc" id="L452">                needs_new_page = true;</span>
            }
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (needs_new_page) {</span>
<span class="fc" id="L455">                curr = _buffer.getEmptyPageIdx();</span>
            }
            //
            //  here we actually read data into our buffers -----
            //
<span class="fc" id="L460">            int read = load(curr, start_pos, file_position);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            if (read &lt; 1) {</span>
<span class="fc" id="L462">                return refill_is_eof();</span>
            }

<span class="pc bpc" id="L465" title="3 of 6 branches missed.">            assert(curr != null &amp;&amp; curr.getOffsetOfFilePosition(file_position) == start_pos);</span>
<span class="fc" id="L466">            set_current_page(new_idx, curr, start_pos);</span>
<span class="fc" id="L467">        }</span>
        else {
<span class="nc bnc" id="L469" title="All 4 branches missed.">            assert(!isEOF());</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (sp != null) {</span>
<span class="nc" id="L471">                int endidx = sp.getEndIdx();</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">                if (endidx != -1 &amp;&amp; endidx &lt; new_idx/*_buffer.getCurrentPageIdx()*/) {</span>
<span class="nc" id="L473">                    return refill_is_eof();</span>
                }
            }

<span class="nc" id="L477">            curr = _buffer.getPage(new_idx);</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">            assert(curr.getStartingFileOffset() == file_position);</span>

<span class="nc" id="L480">            set_current_page(new_idx, curr, curr.getStartingOffset());</span>

<span class="nc bnc" id="L482" title="All 4 branches missed.">            if (sp != null &amp;&amp; sp.getEndIdx() == new_idx /*_buffer.getCurrentPageIdx()*/ ) {</span>
                // the last page in the marked range will probably
                // require a different limit
<span class="nc" id="L485">                _limit = sp.getEndPos();</span>
            }
        }

<span class="pc bpc" id="L489" title="3 of 6 branches missed.">        assert(isEOF() ^ (_limit &gt; 0));  // xor: either we're at eof or we have data to read</span>
<span class="fc" id="L490">        return _limit;</span>
    }
    private void set_current_page(int new_page_idx, UnifiedDataPageX new_page, int pos)
    {
<span class="pc bpc" id="L494" title="4 of 8 branches missed.">        assert(new_page != null &amp;&amp; new_page_idx &gt;= 0 &amp;&amp; new_page_idx &lt;= _buffer.getPageCount() + 1);</span>

<span class="fc" id="L496">        UnifiedDataPageX curr = null;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        if (new_page_idx &lt; _buffer.getPageCount()) {</span>
<span class="fc" id="L498">            curr = _buffer.getPage(new_page_idx);</span>
        }

<span class="fc bfc" id="L501" title="All 2 branches covered.">        if (new_page != curr) {</span>
<span class="fc" id="L502">            _buffer.setPage(new_page_idx, new_page, true);</span>
        }

<span class="fc" id="L505">        make_page_current(new_page, new_page_idx, pos, new_page.getBufferLimit());</span>

<span class="fc" id="L507">        return;</span>
    }
    private int refill_is_eof() {
<span class="fc" id="L510">        _eof = true;</span>
<span class="fc" id="L511">        _limit = -1;</span>
<span class="fc" id="L512">        return _limit;</span>
    }

    private final boolean can_fill_new_page() {
<span class="fc" id="L516">        return _is_stream;</span>
    }

    protected final int load(UnifiedDataPageX curr, int start_pos, long file_position) throws IOException
    {
<span class="fc" id="L521">        int read = 0;</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (can_fill_new_page()) {</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (is_byte_data()) {</span>
<span class="fc" id="L524">                read = curr.load(_stream, start_pos, file_position);</span>
            }
            else {
<span class="fc" id="L527">                read = curr.load(_reader, start_pos, file_position);</span>
            }
        }
<span class="fc" id="L530">        return read;</span>
    }

    //
    // specialized subclasses that provide an appropriate constructor
    // and refill method tailored to efficiently use the data source
    //
    private static class FromCharArray extends UnifiedInputStreamX
    {
        FromCharArray(CharSequence chars, int offset, int length)
<span class="fc" id="L540">        {</span>
<span class="fc" id="L541">            _is_byte_data = false;</span>
<span class="fc" id="L542">            _is_stream = false;</span>
<span class="fc" id="L543">            _buffer = UnifiedInputBufferX.makePageBuffer(chars, offset, length);</span>
<span class="fc" id="L544">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L545">            make_page_current(curr, 0, offset, offset+length);</span>
<span class="fc" id="L546">            super.init();</span>
<span class="fc" id="L547">        }</span>
        FromCharArray(char[] charArray, int offset, int length)
<span class="fc" id="L549">        {</span>
<span class="fc" id="L550">            _is_byte_data = false;</span>
<span class="fc" id="L551">            _is_stream = false;</span>
<span class="fc" id="L552">            _buffer = UnifiedInputBufferX.makePageBuffer(charArray, offset, length);</span>
<span class="fc" id="L553">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L554">            make_page_current(curr, 0, offset, offset+length);</span>
<span class="fc" id="L555">            super.init();</span>
<span class="fc" id="L556">        }</span>
    }

    private static class FromCharStream extends UnifiedInputStreamX
    {
        FromCharStream(Reader reader) throws IOException
<span class="fc" id="L562">        {</span>
<span class="fc" id="L563">            _is_byte_data = false;</span>
<span class="fc" id="L564">            _is_stream = true;</span>
<span class="fc" id="L565">            _reader = reader;</span>
<span class="fc" id="L566">            _buffer = UnifiedInputBufferX.makePageBuffer(UnifiedInputBufferX.BufferType.CHARS, DEFAULT_PAGE_SIZE);</span>
<span class="fc" id="L567">            super.init();</span>
<span class="fc" id="L568">            _limit = refill();</span>
<span class="fc" id="L569">        }</span>

        @Override
        public void close()
            throws IOException
        {
<span class="nc" id="L575">            super.close();</span>
<span class="nc" id="L576">            _reader.close();</span>
<span class="nc" id="L577">        }</span>
    }


// FIXME: PERF_TEST was: private

static class FromByteArray extends UnifiedInputStreamX
    {
        FromByteArray(byte[] bytes, int offset, int length)
<span class="fc" id="L586">        {</span>
<span class="fc" id="L587">            _is_byte_data = true;</span>
<span class="fc" id="L588">            _is_stream = false;</span>
<span class="fc" id="L589">            _buffer = UnifiedInputBufferX.makePageBuffer(bytes, offset, length);</span>
<span class="fc" id="L590">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L591">            make_page_current(curr, 0, offset, offset+length);</span>
<span class="fc" id="L592">            super.init();</span>
<span class="fc" id="L593">        }</span>
    }

    private static class FromByteStream extends UnifiedInputStreamX
    {
        FromByteStream(InputStream stream) throws IOException
<span class="fc" id="L599">        {</span>
<span class="fc" id="L600">            _is_byte_data = true;</span>
<span class="fc" id="L601">            _is_stream = true;</span>
<span class="fc" id="L602">            _stream = stream;</span>
<span class="fc" id="L603">            _buffer = UnifiedInputBufferX.makePageBuffer(UnifiedInputBufferX.BufferType.BYTES, DEFAULT_PAGE_SIZE);</span>
<span class="fc" id="L604">            super.init();</span>
<span class="fc" id="L605">            _limit = refill();</span>
<span class="fc" id="L606">        }</span>

        @Override
        public void close()
            throws IOException
        {
<span class="fc" id="L612">            super.close();</span>
<span class="fc" id="L613">            _stream.close();</span>
<span class="fc" id="L614">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>