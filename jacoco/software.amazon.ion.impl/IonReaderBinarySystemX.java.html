<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderBinarySystemX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderBinarySystemX.java</span></div><h1>IonReaderBinarySystemX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2009-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.IonType.SYMBOL;
import static software.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Date;
import java.util.Iterator;
import software.amazon.ion.Decimal;
import software.amazon.ion.IntegerSize;
import software.amazon.ion.IonType;
import software.amazon.ion.NullValueException;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.Timestamp;
import software.amazon.ion.UnknownSymbolException;
import software.amazon.ion.impl.PrivateScalarConversions.AS_TYPE;
import software.amazon.ion.impl.PrivateScalarConversions.ValueVariant;

<span class="pc bpc" id="L36" title="1 of 2 branches missed.">class IonReaderBinarySystemX</span>
    extends IonReaderBinaryRawX
    implements PrivateReaderWriter
{
    SymbolTable _symbols;

    IonReaderBinarySystemX(UnifiedInputStreamX in)
    {
<span class="fc" id="L44">        super();</span>
<span class="fc" id="L45">        init_raw(in);</span>
        // TODO check IVM to determine version: amznlabs/ion-java#19, amznlabs/ion-java#24
<span class="fc" id="L47">        _symbols = SharedSymbolTable.getSystemSymbolTable(1);</span>
<span class="fc" id="L48">    }</span>


    //
    // public methods that typically user level methods
    // these are filled in by either the system reader
    // or the user reader.  Here they just fail.
    //

    public SymbolToken[] getTypeAnnotationSymbols()
    {
<span class="fc" id="L59">        load_annotations();</span>

<span class="fc" id="L61">        int count = _annotation_count;</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (count == 0) return SymbolToken.EMPTY_ARRAY;</span>

<span class="fc" id="L64">        SymbolTable symtab = getSymbolTable();</span>

<span class="fc" id="L66">        SymbolToken[] result = new SymbolToken[count];</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc" id="L69">            int sid = _annotation_ids[i];</span>
<span class="fc" id="L70">            String text = symtab.findKnownSymbol(sid);</span>
<span class="fc" id="L71">            result[i] = new SymbolTokenImpl(text, sid);</span>
        }

<span class="fc" id="L74">        return result;</span>
    }

    private void load_once()
    {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (_v.isEmpty()) {</span>
            try {
<span class="fc" id="L81">                load_scalar_value();</span>
            }
<span class="nc" id="L83">            catch (IOException e) {</span>
<span class="nc" id="L84">                error(e);</span>
<span class="fc" id="L85">            }</span>
        }
<span class="fc" id="L87">    }</span>

    //
    //  basic scalar value getters (for actual content)
    //
    protected final void prepare_value(int as_type) {
<span class="fc" id="L93">        load_once();</span>
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">        if (as_type != 0 &amp;&amp; !_v.hasValueOfType(as_type)) {</span>
            // we should never get here with a symbol asking for anything other
            // than a numeric cast (from some other numeric already loaded)
<span class="pc bpc" id="L97" title="3 of 4 branches missed.">            if (IonType.SYMBOL.equals(_value_type) &amp;&amp; !ValueVariant.isNumericType(as_type)) {</span>
<span class="nc bnc" id="L98" title="All 6 branches missed.">                assert(IonType.SYMBOL.equals(_value_type) &amp;&amp; !ValueVariant.isNumericType(as_type));</span>
            }

<span class="pc bpc" id="L101" title="1 of 2 branches missed.">            if (!_v.can_convert(as_type)) {</span>
<span class="nc" id="L102">                String message = &quot;can't cast from &quot;</span>
<span class="nc" id="L103">                    +PrivateScalarConversions.getValueTypeName(_v.getAuthoritativeType())</span>
                    +&quot; to &quot;
<span class="nc" id="L105">                    +PrivateScalarConversions.getValueTypeName(as_type);</span>
<span class="nc" id="L106">                throw new IllegalStateException(message);</span>
            }
<span class="fc" id="L108">            int fnid = _v.get_conversion_fnid(as_type);</span>
<span class="fc" id="L109">            _v.cast(fnid);</span>
        }
<span class="fc" id="L111">    }</span>

    /**
     * this checks the state of the raw reader to make sure
     * this is valid.  It also checks for an existing cached
     * value of the correct type.  It will either cast the
     * current value from an existing type to the type desired
     * or it will construct the desired type from the raw
     * input in the raw reader
     *
     * @param value_type desired value type (in local type terms)
     * @throws IOException
     */
    protected final void load_cached_value(int value_type) throws IOException
    {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (_v.isEmpty()) {</span>
<span class="fc" id="L127">            load_scalar_value();</span>
        }
<span class="fc" id="L129">    }</span>

    /** Utility method to convert an unsigned magnitude stored as a long to a {@link BigInteger}. */
    private static BigInteger unsignedLongToBigInteger(int signum, long val)
    {
<span class="fc" id="L134">        byte[] magnitude = {</span>
            (byte) ((val &gt;&gt; 56) &amp; 0xFF),
            (byte) ((val &gt;&gt; 48) &amp; 0xFF),
            (byte) ((val &gt;&gt; 40) &amp; 0xFF),
            (byte) ((val &gt;&gt; 32) &amp; 0xFF),
            (byte) ((val &gt;&gt; 24) &amp; 0xFF),
            (byte) ((val &gt;&gt; 16) &amp; 0xFF),
            (byte) ((val &gt;&gt;  8) &amp; 0xFF),
            (byte) (val &amp; 0xFF),
        };
<span class="fc" id="L144">        return new BigInteger(signum, magnitude);</span>
    }

<span class="fc" id="L147">    static final BigInteger MIN_LONG_VALUE = BigInteger.valueOf(Long.MIN_VALUE);</span>
<span class="fc" id="L148">    static final BigInteger MAX_LONG_VALUE = BigInteger.valueOf(Long.MAX_VALUE);</span>

    private final void load_scalar_value() throws IOException
    {
        // make sure we're trying to load a scalar value here
<span class="fc bfc" id="L153" title="All 2 branches covered.">        switch(_value_type) {</span>
        case NULL:
        case BOOL:
        case INT:
        case FLOAT:
        case DECIMAL:
        case TIMESTAMP:
        case SYMBOL:
        case STRING:
<span class="fc" id="L162">            break;</span>
        default:
<span class="fc" id="L164">            return;</span>
        }

        // this will be true when the value_type is null as
        // well as when we encounter a null of any other type
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (_value_is_null) {</span>
<span class="fc" id="L170">            _v.setValueToNull(_value_type);</span>
<span class="fc" id="L171">            _v.setAuthoritativeType(AS_TYPE.null_value);</span>
<span class="fc" id="L172">            return;</span>
        }

<span class="pc bpc" id="L175" title="1 of 8 branches missed.">        switch (_value_type) {</span>
        default:
<span class="nc" id="L177">            return;</span>
        case BOOL:
<span class="fc" id="L179">            _v.setValue(_value_is_true);</span>
<span class="fc" id="L180">            _v.setAuthoritativeType(AS_TYPE.boolean_value);</span>
<span class="fc" id="L181">            break;</span>
        case INT:
<span class="fc bfc" id="L183" title="All 2 branches covered.">            boolean is_negative = _value_tid == PrivateIonConstants.tidNegInt;</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (_value_len == 0) {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (is_negative) {</span>
<span class="nc" id="L187">                    throwIllegalNegativeZeroException();</span>
                }

<span class="fc" id="L190">                int v = 0;</span>
<span class="fc" id="L191">                _v.setValue(v);</span>
<span class="fc" id="L192">                _v.setAuthoritativeType(AS_TYPE.int_value);</span>
<span class="fc" id="L193">            }</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            else if (_value_len &lt;= Long.BYTES) {</span>
<span class="fc" id="L195">                long v = readULong(_value_len);</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">                if (v &lt; 0) {</span>
                    // we probably can't fit this magnitude properly into a Java long
<span class="fc bfc" id="L199" title="All 2 branches covered.">                    int signum = !is_negative ? 1 : -1;</span>
<span class="fc" id="L200">                    BigInteger big = unsignedLongToBigInteger(signum, v);</span>
<span class="fc" id="L201">                    _v.setValue(big);</span>
                    // boundary condition
<span class="fc bfc" id="L203" title="All 4 branches covered.">                    if (big.compareTo(MIN_LONG_VALUE) &lt; 0 || big.compareTo(MAX_LONG_VALUE) &gt; 0) {</span>
<span class="fc" id="L204">                        _v.setAuthoritativeType(AS_TYPE.bigInteger_value);</span>
                    } else {
                        // fits in long
<span class="fc" id="L207">                        _v.addValue(big.longValue()); // keep the BigInteger value set in case the user wants to resurrect it as such</span>
<span class="fc" id="L208">                        _v.setAuthoritativeType(AS_TYPE.long_value);</span>
                    }
<span class="fc" id="L210">                }</span>
                else {
<span class="fc bfc" id="L212" title="All 2 branches covered.">                    if (is_negative) {</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">                        if(v == 0) {</span>
<span class="nc" id="L214">                            throwIllegalNegativeZeroException();</span>
                        }
<span class="fc" id="L216">                        v = -v;</span>
                    }
<span class="fc bfc" id="L218" title="All 4 branches covered.">                    if (v &lt; Integer.MIN_VALUE || v &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L219">                        _v.setValue(v);</span>
<span class="fc" id="L220">                        _v.setAuthoritativeType(AS_TYPE.long_value);</span>
                    } else {
<span class="fc" id="L222">                        _v.setValue((int)v);</span>
<span class="fc" id="L223">                        _v.setAuthoritativeType(AS_TYPE.int_value);</span>
                    }
                }
<span class="fc" id="L226">            }</span>
            else {
<span class="fc" id="L228">                BigInteger v = readBigInteger(_value_len, is_negative);</span>
<span class="fc" id="L229">                _v.setValue(v);</span>
<span class="fc" id="L230">                _v.setAuthoritativeType(AS_TYPE.bigInteger_value);</span>
            }
<span class="fc" id="L232">            break;</span>
        case FLOAT:
            double d;
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            if (_value_len == 0) {</span>
<span class="nc" id="L236">                d = 0.0;</span>
            }
            else {
<span class="fc" id="L239">                d = readFloat(_value_len);</span>
            }
<span class="fc" id="L241">            _v.setValue(d);</span>
<span class="fc" id="L242">            _v.setAuthoritativeType(AS_TYPE.double_value);</span>
<span class="fc" id="L243">            break;</span>
        case DECIMAL:
<span class="fc" id="L245">            Decimal dec = readDecimal(_value_len);</span>
<span class="fc" id="L246">            _v.setValue(dec);</span>
<span class="fc" id="L247">            _v.setAuthoritativeType(AS_TYPE.decimal_value);</span>
<span class="fc" id="L248">            break;</span>
        case TIMESTAMP:
            // TODO: it looks like a 0 length return a null timestamp - is that right?
<span class="fc" id="L251">            Timestamp t = readTimestamp(_value_len);</span>
<span class="fc" id="L252">            _v.setValue(t);</span>
<span class="fc" id="L253">            _v.setAuthoritativeType(AS_TYPE.timestamp_value);</span>
<span class="fc" id="L254">            break;</span>
        case SYMBOL:
<span class="fc" id="L256">            long sid = readULong(_value_len);</span>
<span class="pc bpc" id="L257" title="2 of 4 branches missed.">            if (sid &lt; 0 || sid &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L258">                String message = &quot;symbol id [&quot;</span>
                               + sid
                               + &quot;] out of range &quot;
                               + &quot;(1-&quot;
                               + Integer.MAX_VALUE
                               + &quot;)&quot;;
<span class="nc" id="L264">                throwErrorAt(message);</span>
            }
            // TODO: is treating this as an int too misleading?
<span class="fc" id="L267">            _v.setValue((int)sid);</span>
<span class="fc" id="L268">            _v.setAuthoritativeType(AS_TYPE.int_value);</span>
<span class="fc" id="L269">            break;</span>
        case STRING:
<span class="fc" id="L271">            String s = readString(_value_len);</span>
<span class="fc" id="L272">            _v.setValue(s);</span>
<span class="fc" id="L273">            _v.setAuthoritativeType(AS_TYPE.string_value);</span>
            break;
        }
<span class="fc" id="L276">        _state = State.S_AFTER_VALUE;</span>
<span class="fc" id="L277">    }</span>

    //
    // public value routines
    //

    @Override
    public boolean isNullValue()
    {
<span class="fc" id="L286">        return _value_is_null;</span>
    }

    public boolean booleanValue()
    {
<span class="fc" id="L291">        prepare_value(AS_TYPE.boolean_value);</span>
<span class="fc" id="L292">        return _v.getBoolean();</span>
    }

    public double doubleValue()
    {
<span class="fc" id="L297">        prepare_value(AS_TYPE.double_value);</span>
<span class="fc" id="L298">        return _v.getDouble();</span>
    }

    public int intValue()
    {
<span class="pc bpc" id="L303" title="2 of 6 branches missed.">        if (_value_type != IonType.INT &amp;&amp;</span>
            _value_type != IonType.DECIMAL &amp;&amp;
            _value_type != IonType.FLOAT)
        {
<span class="fc" id="L307">            throw new IllegalStateException();</span>
        }

<span class="fc" id="L310">        prepare_value(AS_TYPE.int_value);</span>
<span class="fc" id="L311">        return _v.getInt();</span>
    }

    public long longValue()
    {
<span class="pc bpc" id="L316" title="1 of 6 branches missed.">        if (_value_type != IonType.INT &amp;&amp;</span>
            _value_type != IonType.DECIMAL &amp;&amp;
            _value_type != IonType.FLOAT)
        {
<span class="fc" id="L320">            throw new IllegalStateException();</span>
        }

<span class="fc" id="L323">        prepare_value(AS_TYPE.long_value);</span>
<span class="fc" id="L324">        return _v.getLong();</span>
    }

    public BigInteger bigIntegerValue()
    {
<span class="fc bfc" id="L329" title="All 6 branches covered.">        if (_value_type != IonType.INT &amp;&amp;</span>
            _value_type != IonType.DECIMAL &amp;&amp;
            _value_type != IonType.FLOAT)
        {
<span class="fc" id="L333">            throw new IllegalStateException();</span>
        }

<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (_value_is_null) {</span>
<span class="fc" id="L337">            return null;</span>
        }
<span class="fc" id="L339">        prepare_value(AS_TYPE.bigInteger_value);</span>
<span class="fc" id="L340">        return _v.getBigInteger();</span>
    }

    public BigDecimal bigDecimalValue()
    {
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (_value_is_null) {</span>
<span class="fc" id="L346">            return null;</span>
        }
<span class="fc" id="L348">        prepare_value(AS_TYPE.decimal_value);</span>
<span class="fc" id="L349">        return _v.getBigDecimal();</span>
    }

    public Decimal decimalValue()
    {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (_value_is_null) {</span>
<span class="fc" id="L355">            return null;</span>
        }
<span class="fc" id="L357">        prepare_value(AS_TYPE.decimal_value);</span>
<span class="fc" id="L358">        return _v.getDecimal();</span>
    }

    public Date dateValue()
    {
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (_value_is_null) {</span>
<span class="fc" id="L364">            return null;</span>
        }
<span class="fc" id="L366">        prepare_value(AS_TYPE.date_value);</span>
<span class="fc" id="L367">        return _v.getDate();</span>
    }

    public Timestamp timestampValue()
    {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (_value_is_null) {</span>
<span class="fc" id="L373">            return null;</span>
        }
<span class="fc" id="L375">        prepare_value(AS_TYPE.timestamp_value);</span>
<span class="fc" id="L376">        return _v.getTimestamp();</span>
    }

    @Override
    public IntegerSize getIntegerSize()
    {
<span class="fc" id="L382">        load_once();</span>
<span class="fc bfc" id="L383" title="All 4 branches covered.">        if (_value_type != IonType.INT || _v.isNull())</span>
        {
<span class="fc" id="L385">            return null;</span>
        }
<span class="fc" id="L387">        return PrivateScalarConversions.getIntegerSize(_v.getAuthoritativeType());</span>
    }

    // TODO amzn/ion-java#63 this needs to use the appropriate symbol table for user values

    public final String stringValue()
    {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (! IonType.isText(_value_type)) throw new IllegalStateException();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (_value_is_null) return null;</span>

<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (_value_type == SYMBOL) {</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if (!_v.hasValueOfType(AS_TYPE.string_value)) {</span>
<span class="fc" id="L399">                int sid = getSymbolId();</span>
<span class="fc" id="L400">                String name = _symbols.findKnownSymbol(sid);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                if (name == null) {</span>
<span class="fc" id="L402">                    throw new UnknownSymbolException(sid);</span>
                }
<span class="fc" id="L404">                _v.addValue(name);</span>
<span class="fc" id="L405">            }</span>
        }
        else {
<span class="fc" id="L408">            prepare_value(AS_TYPE.string_value);</span>
        }
<span class="fc" id="L410">        return _v.getString();</span>
    }

    public SymbolToken symbolValue()
    {
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (_value_type != SYMBOL) throw new IllegalStateException();</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (_value_is_null) return null;</span>

<span class="fc" id="L418">        int sid = getSymbolId();</span>
<span class="pc bpc" id="L419" title="2 of 4 branches missed.">        assert sid != UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L420">        String text = _symbols.findKnownSymbol(sid);</span>

<span class="fc" id="L422">        return new SymbolTokenImpl(text, sid);</span>
    }

    int getSymbolId()
    {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        if (_value_type != SYMBOL) throw new IllegalStateException();</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (_value_is_null) throw new NullValueException();</span>

<span class="fc" id="L430">        prepare_value(AS_TYPE.int_value);</span>
<span class="fc" id="L431">        return _v.getInt();</span>
    }

    public final String getFieldName()
    {
        String name;
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (_value_field_id == SymbolTable.UNKNOWN_SYMBOL_ID) {</span>
<span class="fc" id="L438">            name = null;</span>
        }
        else {
<span class="fc" id="L441">            name = _symbols.findKnownSymbol(_value_field_id);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (name == null) {</span>
<span class="fc" id="L443">                throw new UnknownSymbolException(_value_field_id);</span>
            }
        }
<span class="fc" id="L446">        return name;</span>
    }

    public SymbolToken getFieldNameSymbol()
    {
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (_value_field_id == SymbolTable.UNKNOWN_SYMBOL_ID) return null;</span>
<span class="fc" id="L452">        int sid = _value_field_id;</span>
<span class="fc" id="L453">        String text = _symbols.findKnownSymbol(sid);</span>
<span class="fc" id="L454">        return new SymbolTokenImpl(text, sid);</span>
    }

    public final Iterator&lt;String&gt; iterateTypeAnnotations()
    {
<span class="fc" id="L459">        String[] annotations = getTypeAnnotations();</span>
<span class="fc" id="L460">        return PrivateUtils.stringIterator(annotations);</span>
    }

    public final String[] getTypeAnnotations()
    {
<span class="fc" id="L465">        load_annotations();</span>
        String[] anns;
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (_annotation_count &lt; 1) {</span>
<span class="fc" id="L468">            anns = PrivateUtils.EMPTY_STRING_ARRAY;</span>
        }
        else {
<span class="fc" id="L471">            anns = new String[_annotation_count];</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">            for (int ii=0; ii&lt;_annotation_count; ii++) {</span>
<span class="fc" id="L473">                anns[ii] = _symbols.findKnownSymbol(_annotation_ids[ii]);</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">                if (anns[ii] == null) {</span>
<span class="fc" id="L475">                    throw new UnknownSymbolException(_annotation_ids[ii]);</span>
                }
            }
        }
<span class="fc" id="L479">        return anns;</span>
    }

    public final SymbolTable getSymbolTable()
    {
<span class="fc" id="L484">        return _symbols;</span>
    }

    // system readers don't skip any symbol tables
    public SymbolTable pop_passed_symbol_table()
    {
<span class="nc" id="L490">        return null;</span>
    }

    private void throwIllegalNegativeZeroException() {
<span class="fc" id="L494">        throw newErrorAt(&quot;negative zero is illegal in the binary format&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>