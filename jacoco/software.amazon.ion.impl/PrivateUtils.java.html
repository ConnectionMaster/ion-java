<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrivateUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">PrivateUtils.java</span></div><h1>PrivateUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static software.amazon.ion.SystemSymbols.IMPORTS;
import static software.amazon.ion.SystemSymbols.IMPORTS_SID;
import static software.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE;
import static software.amazon.ion.SystemSymbols.MAX_ID;
import static software.amazon.ion.SystemSymbols.MAX_ID_SID;
import static software.amazon.ion.SystemSymbols.NAME;
import static software.amazon.ion.SystemSymbols.NAME_SID;
import static software.amazon.ion.SystemSymbols.SYMBOLS;
import static software.amazon.ion.SystemSymbols.SYMBOLS_SID;
import static software.amazon.ion.SystemSymbols.VERSION;
import static software.amazon.ion.SystemSymbols.VERSION_SID;
import static software.amazon.ion.util.IonStreamUtils.isIonBinary;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.TimeZone;
import software.amazon.ion.IonException;
import software.amazon.ion.IonReader;
import software.amazon.ion.IonStruct;
import software.amazon.ion.IonSystem;
import software.amazon.ion.IonType;
import software.amazon.ion.IonValue;
import software.amazon.ion.SubstituteSymbolTableException;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.UnknownSymbolException;
import software.amazon.ion.ValueFactory;

/**
 * @deprecated This is an internal API that is subject to change without notice.
 */
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">@Deprecated</span>
<span class="nc" id="L64">public final class PrivateUtils</span>
{
    /** Just a zero-length byte array, used to avoid allocation. */
<span class="fc" id="L67">    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];</span>

    /** Just a zero-length String array, used to avoid allocation. */
<span class="fc" id="L70">    public final static String[] EMPTY_STRING_ARRAY = new String[0];</span>

    /** Just a zero-length int array, used to avoid allocation. */
<span class="fc" id="L73">    public final static int[] EMPTY_INT_ARRAY = new int[0];</span>

    public static final String ASCII_CHARSET_NAME = &quot;US-ASCII&quot;;

<span class="fc" id="L77">    public static final Charset ASCII_CHARSET =</span>
<span class="fc" id="L78">        Charset.forName(ASCII_CHARSET_NAME);</span>

    /** The string {@code &quot;UTF-8&quot;}. */
    public static final String UTF8_CHARSET_NAME = &quot;UTF-8&quot;;

<span class="fc" id="L83">    public static final Charset UTF8_CHARSET =</span>
<span class="fc" id="L84">        Charset.forName(UTF8_CHARSET_NAME);</span>


    /**
     * The UTC {@link TimeZone}.
     *
     * TODO determine if this is well-defined.
     */
<span class="fc" id="L92">    public static final TimeZone UTC = TimeZone.getTimeZone(&quot;UTC&quot;);</span>



<span class="fc" id="L96">    public static final ListIterator&lt;?&gt; EMPTY_ITERATOR = new ListIterator() {</span>
<span class="fc" id="L97">        public boolean hasNext()     { return false; }</span>
<span class="fc" id="L98">        public boolean hasPrevious() { return false; }</span>

<span class="fc" id="L100">        public Object  next()     { throw new NoSuchElementException(); }</span>
<span class="nc" id="L101">        public Object  previous() { throw new NoSuchElementException(); }</span>
<span class="nc" id="L102">        public void    remove()   { throw new IllegalStateException(); }</span>

<span class="fc" id="L104">        public int nextIndex()     { return  0; }</span>
<span class="fc" id="L105">        public int previousIndex() { return -1; }</span>

<span class="nc" id="L107">        public void add(Object o) { throw new UnsupportedOperationException(); }</span>
<span class="nc" id="L108">        public void set(Object o) { throw new UnsupportedOperationException(); }</span>
    };

    @SuppressWarnings(&quot;unchecked&quot;)
    public static final &lt;T&gt; ListIterator&lt;T&gt; emptyIterator()
    {
<span class="fc" id="L114">        return (ListIterator&lt;T&gt;) EMPTY_ITERATOR;</span>
    }

    public static boolean safeEquals(Object a, Object b)
    {
        // Written for the common case where they are not the same instance
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">        return (a != null ? a.equals(b) : b == null);</span>
    }

    /**
     * Replacement for Java6 {@link Arrays#copyOf(byte[], int)}.
     */
    public static byte[] copyOf(byte[] original, int newLength)
    {
<span class="fc" id="L128">        byte[] result = new byte[newLength];</span>
<span class="fc" id="L129">        System.arraycopy(original, 0, result, 0,</span>
<span class="fc" id="L130">                         Math.min(newLength, original.length));</span>
<span class="fc" id="L131">        return result;</span>
    }

    public static String[] copyOf(String[] original, int newLength)
    {
<span class="fc" id="L136">        String[] result = new String[newLength];</span>
<span class="fc" id="L137">        System.arraycopy(original, 0, result, 0,</span>
<span class="fc" id="L138">                         Math.min(newLength, original.length));</span>
<span class="fc" id="L139">        return result;</span>
    }

    public static &lt;T&gt; void addAll(Collection&lt;T&gt; dest, Iterator&lt;T&gt; src)
    {
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (src != null)</span>
        {
<span class="nc bnc" id="L146" title="All 2 branches missed.">            while (src.hasNext())</span>
            {
<span class="nc" id="L148">                T value = src.next();</span>
<span class="nc" id="L149">                dest.add(value);</span>
<span class="nc" id="L150">            }</span>
        }
<span class="nc" id="L152">    }</span>

    public static &lt;T&gt; void addAllNonNull(Collection&lt;T&gt; dest, Iterator&lt;T&gt; src)
    {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (src != null)</span>
        {
<span class="fc bfc" id="L158" title="All 2 branches covered.">            while (src.hasNext())</span>
            {
<span class="fc" id="L160">                T value = src.next();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">                if (value != null)</span>
                {
<span class="fc" id="L163">                    dest.add(value);</span>
                }
<span class="fc" id="L165">            }</span>
        }
<span class="fc" id="L167">    }</span>

    /**
     * @return not null
     */
    public static SymbolTokenImpl newSymbolToken(String text, int sid)
    {
<span class="fc" id="L174">        return new SymbolTokenImpl(text, sid);</span>
    }

    /**
     * @return not null
     */
    public static SymbolTokenImpl newSymbolToken(int sid)
    {
<span class="fc" id="L182">        return new SymbolTokenImpl(sid);</span>
    }

    /**
     * Checks symbol content.
     * @return not null
     */
    public static SymbolToken newSymbolToken(SymbolTable symtab,
                                             String text)
    {
        // TODO amzn/ion-java#21 symtab should not be null
<span class="fc" id="L193">        text.getClass(); // quick null check</span>

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        SymbolToken tok = (symtab == null ? null : symtab.find(text));</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (tok == null)</span>
        {
<span class="fc" id="L198">            tok = new SymbolTokenImpl(text, UNKNOWN_SYMBOL_ID);</span>
        }
<span class="fc" id="L200">        return tok;</span>
    }

    /**
     * @return not null
     */
    public static SymbolToken newSymbolToken(SymbolTable symtab,
                                             int sid)
    {
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (sid &lt; 1) throw new IllegalArgumentException();</span>

        // TODO amzn/ion-java#21 symtab should not be null
<span class="nc bnc" id="L212" title="All 2 branches missed.">        String text = (symtab == null ? null : symtab.findKnownSymbol(sid));</span>
<span class="nc" id="L213">        return new SymbolTokenImpl(text, sid);</span>
    }

    /**
     * Validates each text element.
     * @param text may be null or empty.
     * @return not null.
     */
    public static SymbolToken[] newSymbolTokens(SymbolTable symtab,
                                                String... text)
    {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (text != null)</span>
        {
<span class="fc" id="L226">            int count = text.length;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (count != 0)</span>
            {
<span class="fc" id="L229">                SymbolToken[] result = new SymbolToken[count];</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                for (int i = 0; i &lt; count; i++)</span>
                {
<span class="fc" id="L232">                    String s = text[i];</span>
<span class="fc" id="L233">                    result[i] = newSymbolToken(symtab, s);</span>
                }
<span class="fc" id="L235">                return result;</span>
            }
        }
<span class="fc" id="L238">        return SymbolToken.EMPTY_ARRAY;</span>
    }

    /**
     * @param syms may be null or empty.
     * @return not null.
     */
    public static SymbolToken[] newSymbolTokens(SymbolTable symtab,
                                                int... syms)
    {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (syms != null)</span>
        {
<span class="nc" id="L250">            int count = syms.length;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (syms.length != 0)</span>
            {
<span class="nc" id="L253">                SymbolToken[] result = new SymbolToken[count];</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                for (int i = 0; i &lt; count; i++)</span>
                {
<span class="nc" id="L256">                    int s = syms[i];</span>
<span class="nc" id="L257">                    result[i] = newSymbolToken(symtab, s);</span>
                }
<span class="nc" id="L259">                return result;</span>
            }
        }
<span class="nc" id="L262">        return SymbolToken.EMPTY_ARRAY;</span>
    }


    public static SymbolToken localize(SymbolTable symtab,
                                       SymbolToken sym)
    {
<span class="fc" id="L269">        String text = sym.getText();</span>
<span class="fc" id="L270">        int sid = sym.getSid();</span>

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (symtab != null)  // TODO amzn/ion-java#21 require symtab</span>
        {
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (text == null)</span>
            {
<span class="fc" id="L276">                text = symtab.findKnownSymbol(sid);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                if (text != null)</span>
                {
<span class="fc" id="L279">                    sym = new SymbolTokenImpl(text, sid);</span>
                }
            }
            else
            {
<span class="fc" id="L284">                SymbolToken newSym = symtab.find(text);</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">                if (newSym != null)</span>
                {
<span class="fc" id="L287">                    sym = newSym;</span>
                }
<span class="fc bfc" id="L289" title="All 2 branches covered.">                else if (sid &gt;= 0)</span>
                {
                    // We can't trust the sid, discard it.
<span class="fc" id="L292">                    sym = new SymbolTokenImpl(text, UNKNOWN_SYMBOL_ID);</span>
                }
<span class="fc" id="L294">            }</span>
        }
<span class="nc bnc" id="L296" title="All 4 branches missed.">        else if (text != null &amp;&amp; sid &gt;= 0)</span>
        {
            // We can't trust the sid, discard it.
<span class="nc" id="L299">            sym = new SymbolTokenImpl(text, UNKNOWN_SYMBOL_ID);</span>
        }
<span class="fc" id="L301">        return sym;</span>
    }


    /**
    *
    * @param syms may be mutated, replacing entries with localized updates!
    */
    public static void localize(SymbolTable symtab,
                                SymbolToken[] syms,
                                int count)
    {
<span class="nc bnc" id="L313" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="nc" id="L315">            SymbolToken sym = syms[i];</span>
<span class="nc" id="L316">            SymbolToken updated = localize(symtab, sym);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (updated != sym) syms[i] = updated;</span>
        }
<span class="nc" id="L319">    }</span>

    /**
     *
     * @param syms may be mutated, replacing entries with localized updates!
     */
    public static void localize(SymbolTable symtab,
                                SymbolToken[] syms)
    {
<span class="nc" id="L328">        localize(symtab, syms, syms.length);</span>
<span class="nc" id="L329">    }</span>


    /**
     * Extracts the non-null text from a list of symbol tokens.
     *
     * @return not null.
     *
     * @throws UnknownSymbolException if any token is missing text.
     */
    public static String[] toStrings(SymbolToken[] symbols, int count)
    {
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (count == 0) return PrivateUtils.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L343">        String[] annotations = new String[count];</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc" id="L346">            SymbolToken tok = symbols[i];</span>
<span class="fc" id="L347">            String text = tok.getText();</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (text == null)</span>
            {
<span class="fc" id="L350">                throw new UnknownSymbolException(tok.getSid());</span>
            }
<span class="fc" id="L352">            annotations[i] = text;</span>
        }
<span class="fc" id="L354">        return annotations;</span>
    }

    public static int[] toSids(SymbolToken[] symbols, int count)
    {
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (count == 0) return PrivateUtils.EMPTY_INT_ARRAY;</span>

<span class="nc" id="L361">        int[] sids = new int[count];</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="nc" id="L364">            sids[i] = symbols[i].getSid();</span>
        }
<span class="nc" id="L366">        return sids;</span>
    }

    //========================================================================

    /**
     * Encodes a String into bytes of a given encoding.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#encode(String)} and
     * {@link String#getBytes(String)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param s the string to encode.
     *
     * @return the encoded string, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static byte[] encode(String s, Charset charset)
    {
<span class="fc" id="L387">        CharsetEncoder encoder = charset.newEncoder();</span>
        try
        {
<span class="fc" id="L390">            ByteBuffer buffer = encoder.encode(CharBuffer.wrap(s));</span>
<span class="fc" id="L391">            byte[] bytes = buffer.array();</span>

            // Make another copy iff there's garbage after the limit.
<span class="fc" id="L394">            int limit = buffer.limit();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (limit &lt; bytes.length)</span>
            {
<span class="fc" id="L397">                bytes = copyOf(bytes, limit);</span>
            }

<span class="fc" id="L400">            return bytes;</span>
        }
<span class="nc" id="L402">        catch (CharacterCodingException e)</span>
        {
<span class="nc" id="L404">            throw new IonException(&quot;Invalid string data&quot;, e);</span>
        }
    }


    /**
     * Decodes a byte sequence into a string, given a {@link Charset}.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#decode(ByteBuffer)} and
     * {@link String#String(byte[], Charset)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param bytes the data to decode.
     *
     * @return the decoded string, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static String decode(byte[] bytes, Charset charset)
    {
<span class="fc" id="L425">        CharsetDecoder decoder = charset.newDecoder();</span>
        try
        {
<span class="fc" id="L428">            CharBuffer buffer = decoder.decode(ByteBuffer.wrap(bytes));</span>
<span class="fc" id="L429">            return buffer.toString();</span>
        }
<span class="fc" id="L431">        catch (CharacterCodingException e)</span>
        {
<span class="fc" id="L433">            String message =</span>
<span class="fc" id="L434">                &quot;Input is not valid &quot; + charset.displayName() + &quot; data&quot;;</span>
<span class="fc" id="L435">            throw new IonException(message, e);</span>
        }
    }


    /**
     * Encodes a String into UTF-8 bytes.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#encode(String)} and
     * {@link String#getBytes(String)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param s the string to encode.
     *
     * @return the encoded UTF-8 bytes, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static byte[] utf8(String s)
    {
<span class="fc" id="L456">        return encode(s, UTF8_CHARSET);</span>
    }

    /**
     * Decodes a UTF-8 byte sequence to a String.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#decode(ByteBuffer)} and
     * {@link String#String(byte[], Charset)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param bytes the data to decode.
     *
     * @return the decoded string, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static String utf8(byte[] bytes)
    {
<span class="fc" id="L475">        return decode(bytes, UTF8_CHARSET);</span>
    }


    /**
     * This differs from {@link #utf8(String)} by using our custem encoder.
     * Not sure which is better.
     * TODO benchmark the two approaches
     */
    public static byte[] convertUtf16UnitsToUtf8(String text)
    {
<span class="fc" id="L486">        byte[] data = new byte[4*text.length()];</span>
<span class="fc" id="L487">        int limit = 0;</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">        for (int i = 0; i &lt; text.length(); i++)</span>
        {
<span class="fc" id="L490">            char c = text.charAt(i);</span>
<span class="fc" id="L491">            limit += IonUTF8.convertToUTF8Bytes(c, data, limit,</span>
                                                data.length - limit);
        }

<span class="fc" id="L495">        byte[] result = new byte[limit];</span>
<span class="fc" id="L496">        System.arraycopy(data, 0, result, 0, limit);</span>
<span class="fc" id="L497">        return result;</span>
    }


    //========================================================================

    /**
     * Calls {@link InputStream#read(byte[], int, int)} until the buffer is
     * filled or EOF is encountered.
     * This method will block until the request is satisfied.
     *
     * @param in        The stream to read from.
     * @param buf       The buffer to read to.
     *
     * @return the number of bytes read from the stream.  May be less than
     *  {@code buf.length} if EOF is encountered before reading that far.
     *
     * @see #readFully(InputStream, byte[], int, int)
     */
    public static int readFully(InputStream in, byte[] buf)
    throws IOException
    {
<span class="nc" id="L519">        return readFully(in, buf, 0, buf.length);</span>
    }


    /**
     * Calls {@link InputStream#read(byte[], int, int)} until the requested
     * length is read or EOF is encountered.
     * This method will block until the request is satisfied.
     *
     * @param in        The stream to read from.
     * @param buf       The buffer to read to.
     * @param offset    The offset of the buffer to read from.
     * @param length    The length of the data to read.
     *
     * @return the number of bytes read from the stream.  May be less than
     *  {@code length} if EOF is encountered before reading that far.
     *
     * @see #readFully(InputStream, byte[])
     */
    public static int readFully(InputStream in, byte[] buf,
                                int offset, int length)
    throws IOException
    {
<span class="fc" id="L542">        int readBytes = 0;</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        while (readBytes &lt; length)</span>
        {
<span class="fc" id="L545">            int amount = in.read(buf, offset, length - readBytes);</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">            if (amount &lt; 0)</span>
            {
                // EOF
<span class="nc" id="L549">                return readBytes;</span>
            }
<span class="fc" id="L551">            readBytes += amount;</span>
<span class="fc" id="L552">            offset += amount;</span>
<span class="fc" id="L553">        }</span>
<span class="fc" id="L554">        return readBytes;</span>
    }


    public static byte[] loadFileBytes(File file)
        throws IOException
    {
<span class="fc" id="L561">        long len = file.length();</span>
<span class="pc bpc" id="L562" title="2 of 4 branches missed.">        if (len &lt; 0 || len &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L563">            throw new IllegalArgumentException(&quot;File too long: &quot; + file);</span>
        }

<span class="fc" id="L566">        byte[] buf = new byte[(int) len];</span>

<span class="fc" id="L568">        FileInputStream in = new FileInputStream(file);</span>
        try {
<span class="fc" id="L570">            int readBytesCount = in.read(buf);</span>
<span class="pc bpc" id="L571" title="2 of 4 branches missed.">            if (readBytesCount != len || in.read() != -1)</span>
            {
<span class="nc" id="L573">                throw new IOException(&quot;Read the wrong number of bytes from &quot;</span>
                                       + file);
            }
        }
        finally {
<span class="fc" id="L578">            in.close();</span>
        }

<span class="fc" id="L581">        return buf;</span>
    }

    public static String utf8FileToString(File file)
        throws IonException, IOException
    {
<span class="fc" id="L587">        byte[] utf8Bytes = PrivateUtils.loadFileBytes(file);</span>
<span class="fc" id="L588">        String s = utf8(utf8Bytes);</span>
<span class="fc" id="L589">        return s;</span>
    }


    public static String loadReader(java.io.Reader in)
        throws IOException
    {
<span class="nc" id="L596">        StringBuilder buf = new StringBuilder(2048);</span>

<span class="nc" id="L598">        char[] chars = new char[2048];</span>

        int len;
<span class="nc bnc" id="L601" title="All 2 branches missed.">        while ((len = in.read(chars)) != -1)</span>
        {
<span class="nc" id="L603">            buf.append(chars, 0, len);</span>
        }

<span class="nc" id="L606">        return buf.toString();</span>
    }


    public static boolean streamIsIonBinary(PushbackInputStream pushback)
        throws IonException, IOException
    {
<span class="nc" id="L613">        boolean isBinary = false;</span>
<span class="nc" id="L614">        byte[] cookie = new byte[PrivateIonConstants.BINARY_VERSION_MARKER_SIZE];</span>

<span class="nc" id="L616">        int len = readFully(pushback, cookie);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (len == PrivateIonConstants.BINARY_VERSION_MARKER_SIZE) {</span>
<span class="nc" id="L618">            isBinary = isIonBinary(cookie);</span>
        }
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (len &gt; 0) {</span>
<span class="nc" id="L621">            pushback.unread(cookie, 0, len);</span>
        }
<span class="nc" id="L623">        return isBinary;</span>
    }


    /**
     * Create a value iterator from a reader.
     * Primarily a trampoline for access permission.
     */
    public static Iterator&lt;IonValue&gt; iterate(ValueFactory valueFactory,
                                             IonReader input)
     {
<span class="fc" id="L634">        return new IonIteratorImpl(valueFactory, input);</span>
     }

    //========================================================================
    // Symbol Table helpers

    /**
     * Checks the passed in value and returns whether or not
     * the value could be a local symbol table.  It does this
     * by checking the type and annotations.
     *
     * @return boolean true if v can be a local symbol table otherwise false
     */
    public static boolean valueIsLocalSymbolTable(PrivateIonValue v)
    {
<span class="fc bfc" id="L649" title="All 2 branches covered.">        return (v instanceof IonStruct</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                &amp;&amp; v.findTypeAnnotation(ION_SYMBOL_TABLE) == 0);</span>
    }


    /** Indicates whether a table is shared but not a system table. */
    public static final boolean symtabIsSharedNotSystem(SymbolTable symtab)
    {
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        return (symtab != null</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">                &amp;&amp; symtab.isSharedTable()</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">                &amp;&amp; ! symtab.isSystemTable());</span>
    }


    public static boolean symtabIsLocalAndNonTrivial(SymbolTable symtab)
    {
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (symtab == null) return false;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (!symtab.isLocalTable()) return false;</span>

        // If symtab has imports we must retain it.
        // Note that I chose to retain imports even in the degenerate case
        // where the imports have no symbols.
<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (symtab.getImportedTables().length &gt; 0) {</span>
<span class="nc" id="L672">            return true;</span>
        }

<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (symtab.getImportedMaxId() &lt; symtab.getMaxId()) {</span>
<span class="nc" id="L676">            return true;</span>
        }

<span class="nc" id="L679">        return false;</span>
    }


    /**
     * Is the table null, system, or local without imported symbols?
     */
    public static boolean isTrivialTable(SymbolTable table)
    {
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (table == null)         return true;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (table.isSystemTable()) return true;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (table.isLocalTable()) {</span>
            // this is only true when there are no local
            // symbols defined
            // and there are no imports with any symbols
<span class="nc bnc" id="L694" title="All 2 branches missed.">            if (table.getMaxId() == table.getSystemSymbolTable().getMaxId()) {</span>
<span class="nc" id="L695">                return true;</span>
            }
        }
<span class="nc" id="L698">        return false;</span>
    }


    public static SymbolTable systemSymtab(int version)
    {
<span class="fc" id="L704">        return SharedSymbolTable.getSystemSymbolTable(version);</span>
    }


    public static SymbolTable newSharedSymtab(IonStruct ionRep)
    {
<span class="fc" id="L710">        return SharedSymbolTable.newSharedSymbolTable(ionRep);</span>
    }


    public static SymbolTable newSharedSymtab(IonReader reader,
                                              boolean alreadyInStruct)
    {
<span class="fc" id="L717">        return SharedSymbolTable.newSharedSymbolTable(reader, alreadyInStruct);</span>
    }


    /**
     * As per {@link IonSystem#newSharedSymbolTable(String, int, Iterator, SymbolTable...)},
     * any duplicate or null symbol texts are skipped.
     * Therefore, &lt;b&gt;THIS METHOD IS NOT SUITABLE WHEN READING SERIALIZED
     * SHARED SYMBOL TABLES&lt;/b&gt; since that scenario must preserve all sids.
     *
     * @param priorSymtab may be null.
     */
    public static SymbolTable newSharedSymtab(String name,
                                              int version,
                                              SymbolTable priorSymtab,
                                              Iterator&lt;String&gt; symbols)
    {
<span class="fc" id="L734">        return SharedSymbolTable.newSharedSymbolTable(name,</span>
                                                      version,
                                                      priorSymtab,
                                                      symbols);
    }

    public static SymbolTable newSubstituteSymtab(SymbolTable original,
                                                  int version,
                                                  int maxId)
    {
<span class="fc" id="L744">        return new SubstituteSymbolTable(original, version, maxId);</span>
    }


    /**
     * Creates a mutable copy of this local symbol table. The cloned table
     * will be created in the context of the same {@link ValueFactory}.
     * &lt;p&gt;
     * Note that the resulting symbol table holds a distinct, deep copy of the
     * given table, adding symbols on either instances will not modify the
     * other.
     *
     * @param symtab
     *
     * @return a new mutable {@link SymbolTable} instance; not null
     *
     * @throws IllegalArgumentException
     *          if the given table is not a local symbol table
     * @throws SubstituteSymbolTableException
     *          if any imported table by the given local symbol table is a
     *          substituted table (whereby no exact match was found in its
     *          catalog)
     */
    // TODO We need to think about providing a suitable recovery process
    //      or configuration for users to properly handle the case when the
    //      local symtab has substituted symtabs for imports.
    public static SymbolTable copyLocalSymbolTable(SymbolTable symtab)
        throws SubstituteSymbolTableException
    {
<span class="fc bfc" id="L773" title="All 2 branches covered.">        if (! symtab.isLocalTable())</span>
        {
<span class="fc" id="L775">            String message = &quot;symtab should be a local symtab&quot;;</span>
<span class="fc" id="L776">            throw new IllegalArgumentException(message);</span>
        }

<span class="fc" id="L779">        SymbolTable[] imports =</span>
<span class="fc" id="L780">            ((LocalSymbolTable) symtab).getImportedTablesNoCopy();</span>

        // Iterate over each import, we assume that the list of imports
        // rarely exceeds 5.
<span class="fc bfc" id="L784" title="All 2 branches covered.">        for (int i = 0; i &lt; imports.length; i++)</span>
        {
<span class="fc bfc" id="L786" title="All 2 branches covered.">            if (imports[i].isSubstitute())</span>
            {
<span class="fc" id="L788">                String message =</span>
                    &quot;local symtabs with substituted symtabs for imports &quot; +
                    &quot;(indicating no exact match within the catalog) cannot &quot; +
                    &quot;be copied&quot;;
<span class="fc" id="L792">                throw new SubstituteSymbolTableException(message);</span>
            }
        }

<span class="fc" id="L796">        return ((LocalSymbolTable) symtab).makeCopy();</span>
    }

    /**
     * Trampoline to {@link LocalSymbolTableAsStruct.Factory#Factory(ValueFactory)}
     * @param imageFactory
     *          the ValueFactory from which to construct the IonStruct representation of the LST
     * @return a new {@link LocalSymbolTableAsStruct.Factory}
     * @deprecated due to DOM entanglement. Streaming applications should use
     *             {@value LocalSymbolTable#DEFAULT_LST_FACTORY}.
     */
    @Deprecated
    public static PrivateLocalSymbolTableFactory newLocalSymbolTableAsStructFactory(ValueFactory imageFactory)
    {
<span class="fc" id="L810">        return new LocalSymbolTableAsStruct.Factory(imageFactory);</span>
    }

    /**
     * Returns a minimal symtab, either system or local depending on the
     * given values, that supports representation as an IonStruct. If the
     * imports are empty, the default system symtab is returned.
     *
     * @param lstFactory
     *          the factory to use to build the local symbol table, never null
     * @param defaultSystemSymtab
     *          the default system symtab, which will be used if the first
     *          import in {@code imports} isn't a system symtab, never null
     * @param imports
     * the set of shared symbol tables to import; may be null or empty.
     * The first (and only the first) may be a system table, in which case the
     * {@code defaultSystemSymtab} is ignored.
     */
    public static SymbolTable initialSymtab(PrivateLocalSymbolTableFactory lstFactory,
                                            SymbolTable defaultSystemSymtab,
                                            SymbolTable... imports)
    {
<span class="pc bpc" id="L832" title="1 of 4 branches missed.">        if (imports == null || imports.length == 0)</span>
        {
<span class="fc" id="L834">            return defaultSystemSymtab;</span>
        }

<span class="pc bpc" id="L837" title="1 of 4 branches missed.">        if (imports.length == 1 &amp;&amp; imports[0].isSystemTable())</span>
        {
<span class="nc" id="L839">            return imports[0];</span>
        }

<span class="fc" id="L842">        return lstFactory.newLocalSymtab(defaultSystemSymtab, imports);</span>
    }


    /**
     * Trampoline to
     * {@link LocalSymbolTableAsStruct#getIonRepresentation()};
     */
    public static IonStruct symtabTree(SymbolTable symtab)
    {
<span class="fc" id="L852">        return ((LocalSymbolTableAsStruct)symtab).getIonRepresentation();</span>
    }

    /**
     * Determines, for two local symbol tables, whether the passed-in {@code superset} symtab is an extension
     * of {@code subset}.  This works independent of implementation details--particularly in cases
     * where {@link LocalSymbolTable#symtabExtends(SymbolTable)} cannot be used.
     *
     * @see #symtabExtends(SymbolTable, SymbolTable)
     */
    private static boolean localSymtabExtends(SymbolTable superset, SymbolTable subset)
    {
<span class="fc bfc" id="L864" title="All 2 branches covered.">        if (subset.getMaxId() &gt; superset.getMaxId())</span>
        {
            // the subset has more symbols
<span class="fc" id="L867">            return false;</span>
        }

        // NB this API almost certainly requires cloning--symbol table's API doesn't give us a way to polymorphically
        //    get this without materializing an array
<span class="fc" id="L872">        final SymbolTable[] supersetImports     = superset.getImportedTables();</span>
<span class="fc" id="L873">        final SymbolTable[] subsetImports       = subset.getImportedTables();</span>

        // TODO this is over-strict, but not as strict as LocalSymbolTable.symtabExtends()
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        if (supersetImports.length != subsetImports.length)</span>
        {
<span class="nc" id="L878">            return false;</span>
        }
        // NB we cannot trust Arrays.equals--we don't know how an implementation will implement it...
<span class="fc bfc" id="L881" title="All 2 branches covered.">        for (int i = 0; i &lt; supersetImports.length; i++)</span>
        {
<span class="fc" id="L883">            final SymbolTable supersetImport = supersetImports[i];</span>
<span class="fc" id="L884">            final SymbolTable subsetImport = subsetImports[i];</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (!supersetImport.getName().equals(subsetImport.getName())</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">                 || supersetImport.getVersion() != subsetImport.getVersion())</span>
            {
                // bad match on import
<span class="fc" id="L889">                return false;</span>
            }
        }

        // all the imports lined up, lets make sure the locals line up too
<span class="fc" id="L894">        final Iterator&lt;String&gt; supersetIter     = superset.iterateDeclaredSymbolNames();</span>
<span class="fc" id="L895">        final Iterator&lt;String&gt; subsetIter       = subset.iterateDeclaredSymbolNames();</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        while (subsetIter.hasNext())</span>
        {
<span class="fc" id="L898">            final String nextSubsetSymbol       = subsetIter.next();</span>
<span class="fc" id="L899">            final String nextSupersetSymbol     = supersetIter.next();</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">            if (!nextSubsetSymbol.equals(nextSupersetSymbol))</span>
            {
                // local symbol mismatch
<span class="fc" id="L903">                return false;</span>
            }
<span class="fc" id="L905">        }</span>

        // we made it this far--superset is really a superset of subset
<span class="fc" id="L908">        return true;</span>
    }

    /**
     * Determines whether the passed-in {@code superset} symtab is an extension
     * of {@code subset}.
     * &lt;p&gt;
     * If both are LSTs, their imported tables and locally declared symbols are
     * exhaustively checked, which can be expensive. Callers of this method
     * should cache the results of these comparisons.
     *
     * @param superset
     *                  either a system or local symbol table
     * @param subset
     *                  either a system or local symbol table
     *
     * @return true if {@code superset} extends {@code subset}, false if not
     */
    public static boolean symtabExtends(SymbolTable superset, SymbolTable subset)
    {
<span class="pc bpc" id="L928" title="2 of 6 branches missed.">        assert superset.isSystemTable() || superset.isLocalTable();</span>
<span class="pc bpc" id="L929" title="2 of 6 branches missed.">        assert subset.isSystemTable() || subset.isLocalTable();</span>

        // NB: system symtab 1.0 is a singleton, hence if both symtabs
        //     are one this will be true.
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">        if (superset == subset) return true;</span>

        // If the subset's symtab is a system symtab, the superset's is always
        // an extension of the subset's as system symtab-ness is irrelevant to
        // the conditions for copy opt. to be safe.
        // TODO amzn/ion-java#24 System symtab-ness ARE relevant if there's multiple
        //      versions.
<span class="fc bfc" id="L940" title="All 2 branches covered.">        if (subset.isSystemTable()) return true;</span>

        // From here on, subset is a LST because isSystemTable() is false.

<span class="fc bfc" id="L944" title="All 2 branches covered.">        if (superset.isLocalTable())</span>
        {
<span class="pc bpc" id="L946" title="3 of 4 branches missed.">            if (superset instanceof LocalSymbolTable &amp;&amp; subset instanceof LocalSymbolTable)</span>
            {
                // use the internal comparison
<span class="nc" id="L949">                return ((LocalSymbolTable) superset).symtabExtends(subset);</span>
            }
            // TODO reason about symbol tables that don't extend LocalSymbolTable but are still local
<span class="fc" id="L952">            return localSymtabExtends(superset, subset);</span>
        }

        // From here on, superset is a system symtab.

        // If LST subset has no local symbols or imports, and it's system
        // symbols are same as those of system symtab superset's, then
        // superset extends subset
<span class="fc bfc" id="L960" title="All 2 branches covered.">        return subset.getMaxId() == superset.getMaxId();</span>
    }


    /**
     * Determines whether the passed-in data type is a scalar and not a symbol.
     */
    public static boolean isNonSymbolScalar(IonType type)
    {
<span class="fc bfc" id="L969" title="All 4 branches covered.">        return ! IonType.isContainer(type) &amp;&amp; ! type.equals(IonType.SYMBOL);</span>
    }


    /**
     * Returns the symbol ID matching a system symbol text of a
     * local or shared symtab field.
     */
    public static final int getSidForSymbolTableField(String text)
    {
<span class="fc" id="L979">        final int shortestFieldNameLength = 4; // 'name'</span>

<span class="pc bpc" id="L981" title="2 of 4 branches missed.">        if (text != null &amp;&amp; text.length() &gt;= shortestFieldNameLength)</span>
        {
<span class="fc" id="L983">            int c = text.charAt(0);</span>
<span class="pc bpc" id="L984" title="5 of 6 branches missed.">            switch (c)</span>
            {
                case 'v':
<span class="nc bnc" id="L987" title="All 2 branches missed.">                    if (VERSION.equals(text))</span>
                    {
<span class="nc" id="L989">                        return VERSION_SID;</span>
                    }
                    break;
                case 'n':
<span class="nc bnc" id="L993" title="All 2 branches missed.">                    if (NAME.equals(text))</span>
                    {
<span class="nc" id="L995">                        return NAME_SID;</span>
                    }
                    break;
                case 's':
<span class="nc bnc" id="L999" title="All 2 branches missed.">                    if (SYMBOLS.equals(text))</span>
                    {
<span class="nc" id="L1001">                        return  SYMBOLS_SID;</span>
                    }
                    break;

                case 'i':
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                    if (IMPORTS.equals(text))</span>
                    {
<span class="nc" id="L1008">                        return IMPORTS_SID;</span>
                    }
                    break;
                case 'm':
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                    if (MAX_ID.equals(text))</span>
                    {
<span class="nc" id="L1014">                        return MAX_ID_SID;</span>
                    }
                    break;
                default:
                    break;
            }
        }
<span class="fc" id="L1021">        return UNKNOWN_SYMBOL_ID;</span>
    }


    //========================================================================


    /**
     * Private to route clients through the static methods, which can
     * optimize the empty-list case.
     */
    private static final class StringIterator implements Iterator&lt;String&gt;
    {
        private final String[] _values;
        private int            _pos;
        private final int      _len;

<span class="fc" id="L1038">        StringIterator(String[] values, int len) {</span>
<span class="fc" id="L1039">            _values = values;</span>
<span class="fc" id="L1040">            _len = len;</span>
<span class="fc" id="L1041">        }</span>
        public boolean hasNext() {
<span class="fc bfc" id="L1043" title="All 2 branches covered.">            return (_pos &lt; _len);</span>
        }
        public String next() {
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">            if (!hasNext()) throw new NoSuchElementException();</span>
<span class="fc" id="L1047">            return _values[_pos++];</span>
        }
        public void remove() {
<span class="nc" id="L1050">            throw new UnsupportedOperationException();</span>
        }
    }

    public static final Iterator&lt;String&gt; stringIterator(String... values)
    {
<span class="pc bpc" id="L1056" title="1 of 4 branches missed.">        if (values == null || values.length == 0)</span>
        {
<span class="fc" id="L1058">            return PrivateUtils.&lt;String&gt;emptyIterator();</span>
        }
<span class="fc" id="L1060">        return new StringIterator(values, values.length);</span>
    }

    public static final Iterator&lt;String&gt; stringIterator(String[] values, int len)
    {
<span class="nc bnc" id="L1065" title="All 6 branches missed.">        if (values == null || values.length == 0 || len == 0)</span>
        {
<span class="nc" id="L1067">            return PrivateUtils.&lt;String&gt;emptyIterator();</span>
        }
<span class="nc" id="L1069">        return new StringIterator(values, len);</span>
    }

    /**
     * Private to route clients through the static methods, which can
     * optimize the empty-list case.
     */
    private static final class IntIterator implements Iterator&lt;Integer&gt;
    {
        private final int []  _values;
        private int           _pos;
        private final int     _len;

        IntIterator(int[] values) {
<span class="nc" id="L1083">            this(values, 0, values.length);</span>
<span class="nc" id="L1084">        }</span>
<span class="nc" id="L1085">        IntIterator(int[] values, int off, int len) {</span>
<span class="nc" id="L1086">            _values = values;</span>
<span class="nc" id="L1087">            _len = len;</span>
<span class="nc" id="L1088">            _pos = off;</span>
<span class="nc" id="L1089">        }</span>
        public boolean hasNext() {
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            return (_pos &lt; _len);</span>
        }
        public Integer next() {
<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (!hasNext()) throw new NoSuchElementException();</span>
<span class="nc" id="L1095">            int value = _values[_pos++];</span>
<span class="nc" id="L1096">            return value;</span>
        }
        public void remove() {
<span class="nc" id="L1099">            throw new UnsupportedOperationException();</span>
        }
    }

    public static final Iterator&lt;Integer&gt; intIterator(int... values)
    {
<span class="nc bnc" id="L1105" title="All 4 branches missed.">        if (values == null || values.length == 0)</span>
        {
<span class="nc" id="L1107">            return PrivateUtils.&lt;Integer&gt;emptyIterator();</span>
        }
<span class="nc" id="L1109">        return new IntIterator(values);</span>
    }

    public static final Iterator&lt;Integer&gt; intIterator(int[] values, int len)
    {
<span class="nc bnc" id="L1114" title="All 6 branches missed.">        if (values == null || values.length == 0 || len == 0)</span>
        {
<span class="nc" id="L1116">            return PrivateUtils.&lt;Integer&gt;emptyIterator();</span>
        }
<span class="nc" id="L1118">        return new IntIterator(values, 0, len);</span>
    }


    //========================================================================


    public static void writeAsBase64(InputStream byteStream, Appendable out)
        throws IOException
    {
<span class="fc" id="L1128">        Base64Encoder.TextStream ts = new Base64Encoder.TextStream(byteStream);</span>

        for (;;) {
<span class="fc" id="L1131">            int c = ts.read();</span>
<span class="fc bfc" id="L1132" title="All 2 branches covered.">            if (c == -1) break;</span>
<span class="fc" id="L1133">            out.append((char) c);</span>
<span class="fc" id="L1134">        }</span>
<span class="fc" id="L1135">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>