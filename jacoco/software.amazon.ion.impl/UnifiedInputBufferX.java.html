<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnifiedInputBufferX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">UnifiedInputBufferX.java</span></div><h1>UnifiedInputBufferX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2009-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;


<span class="pc bpc" id="L18" title="1 of 2 branches missed.">abstract class UnifiedInputBufferX</span>
{
<span class="fc" id="L20">    public enum BufferType { BYTES, CHARS }</span>

    protected int               _page_size;
    protected UnifiedDataPageX[] _buffers;
    protected int               _buffer_current;
    protected int               _buffer_count;
    protected int               _locks;

    public static UnifiedInputBufferX makePageBuffer(byte[] bytes, int offset, int length) {
<span class="fc" id="L29">        UnifiedInputBufferX buf = new UnifiedInputBufferX.Bytes(bytes, offset, length);</span>
<span class="fc" id="L30">        return buf;</span>
    }
    public static UnifiedInputBufferX makePageBuffer(char[] chars, int offset, int length) {
<span class="fc" id="L33">        UnifiedInputBufferX buf = new UnifiedInputBufferX.Chars(chars, offset, length);</span>
<span class="fc" id="L34">        return buf;</span>
    }
    public static UnifiedInputBufferX makePageBuffer(CharSequence chars, int offset, int length) {
<span class="fc" id="L37">        char [] char_array = chars_make_char_array(chars, offset, length);</span>
<span class="fc" id="L38">        UnifiedInputBufferX buf = makePageBuffer(char_array, 0, length);</span>
<span class="fc" id="L39">        return buf;</span>
    }
    public static UnifiedInputBufferX makePageBuffer(BufferType bufferType, int initialPageSize)
    {
        UnifiedInputBufferX buf;
<span class="pc bpc" id="L44" title="1 of 3 branches missed.">        switch(bufferType) {</span>
        case CHARS:
<span class="fc" id="L46">            buf = new UnifiedInputBufferX.Chars(initialPageSize);</span>
<span class="fc" id="L47">            break;</span>
        case BYTES:
<span class="fc" id="L49">            buf = new UnifiedInputBufferX.Bytes(initialPageSize);</span>
<span class="fc" id="L50">            break;</span>
        default:
<span class="nc" id="L52">            throw new IllegalArgumentException(&quot;invalid buffer type&quot;);</span>
        }
<span class="fc" id="L54">        return buf;</span>
    }
    protected static final char[] chars_make_char_array(CharSequence chars,
                                                         int offset,
                                                         int length)
    {
<span class="fc" id="L60">        char[] char_array = new char[length];</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        for (int ii=offset; ii&lt;length; ii++) {</span>
<span class="fc" id="L62">            char_array[ii] = chars.charAt(ii);</span>
        }
<span class="fc" id="L64">        return char_array;</span>
    }
<span class="fc" id="L66">    private UnifiedInputBufferX(int initialPageSize) {</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (initialPageSize &lt; 0) {</span>
<span class="nc" id="L68">            throw new IllegalArgumentException(&quot;page size must be &gt; 0&quot;);</span>
        }
<span class="fc" id="L70">        _page_size = initialPageSize;</span>
<span class="fc" id="L71">        _buffers = new UnifiedDataPageX[10];</span>
<span class="fc" id="L72">    }</span>

    public abstract BufferType getType();
    public abstract int maxValue();

    public final void putCharAt(long fileOffset, int c) {
<span class="nc bnc" id="L78" title="All 4 branches missed.">        if (c &lt; 0 || c &gt; maxValue()) throw new IllegalArgumentException(&quot;value (&quot;+c+&quot;)is out of range (0 to &quot;+maxValue()+&quot;)&quot;);</span>

        // since we start at _curr the common case find the buffer immediately
<span class="nc" id="L81">        UnifiedDataPageX page = null;</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        for (int ii=_buffer_current; ii&gt;=0; ii--) {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">            if (_buffers[ii].containsOffset(fileOffset)) {</span>
<span class="nc" id="L84">                page = _buffers[ii];</span>
<span class="nc" id="L85">                break;</span>
            }
        }
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (page == null) throw new IllegalArgumentException();</span>
<span class="nc" id="L89">        int offset = (int)(fileOffset - page.getStartingFileOffset());</span>
<span class="nc" id="L90">        page.putValue(offset, c);</span>
<span class="nc" id="L91">    }</span>

    public final UnifiedDataPageX getCurrentPage() {
<span class="fc" id="L94">        return _buffers[_buffer_current];</span>
    }

    public final int getCurrentPageIdx()   {
<span class="fc" id="L98">        return _buffer_current;</span>
    }

    public final int getPageCount() {
<span class="fc" id="L102">        return _buffer_count;</span>
    }

    public final void incLock() {
<span class="fc" id="L106">        _locks++;</span>
<span class="fc" id="L107">    }</span>
    public final boolean decLock() {
<span class="fc" id="L109">        _locks--;</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        return (_locks == 0);</span>
    }

    public final UnifiedDataPageX getPage(int pageIdx) {
<span class="pc bpc" id="L114" title="2 of 4 branches missed.">        if (pageIdx &lt; 0 || pageIdx &gt;= _buffer_count) {</span>
<span class="nc" id="L115">            throw new IndexOutOfBoundsException();</span>
        }
<span class="fc" id="L117">        return _buffers[pageIdx];</span>
    }

    protected final int getNextFilledPageIdx() {
<span class="fc" id="L121">        int idx = _buffer_current + 1;</span>

<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (idx &lt; _buffer_count) {</span>
<span class="nc" id="L124">            UnifiedDataPageX p = _buffers[idx];</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (p != null) {</span>
<span class="nc" id="L126">                _buffer_current = idx;</span>
<span class="nc" id="L127">                return idx;</span>
            }
        }
<span class="fc" id="L130">        return -1;</span>
    }

    protected final UnifiedDataPageX getEmptyPageIdx() {
<span class="fc" id="L134">        UnifiedDataPageX next = null;</span>

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (_buffer_count &lt; _buffers.length) {</span>
<span class="fc" id="L137">            next = _buffers[_buffer_count];</span>
        }
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (next == null) {</span>
<span class="fc" id="L140">            next = make_page(_page_size);</span>
        }
        else {
<span class="nc bnc" id="L143" title="All 4 branches missed.">            assert(_buffer_count == (_buffer_current + 1));</span>
        }
<span class="fc" id="L145">        return next;</span>
    }

    abstract protected UnifiedDataPageX make_page(int page_size);

    protected final UnifiedDataPageX setCurrentPage(int idx, UnifiedDataPageX curr) {
<span class="fc" id="L151">        setPage(idx, curr, true);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (idx != _buffer_current) {</span>
<span class="nc" id="L153">            _buffer_current = idx;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (idx &gt;= _buffer_count) {</span>
<span class="nc" id="L155">                _buffer_count = idx + 1;</span>
            }
        }
<span class="fc" id="L158">        UnifiedDataPageX p = _buffers[idx];</span>
<span class="fc" id="L159">        return p;</span>
    }

    protected final void setPage(int idx, UnifiedDataPageX curr, boolean recycleOldPage)
    {
<span class="fc" id="L164">        int oldlen = _buffers.length;</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (idx &gt;= oldlen) {</span>
<span class="nc" id="L166">            int newlen = oldlen * 2;</span>
<span class="nc" id="L167">            UnifiedDataPageX[] newbuf = new UnifiedDataPageX[newlen];</span>
<span class="nc" id="L168">            System.arraycopy(_buffers, 0, newbuf, 0, oldlen);</span>
<span class="nc" id="L169">            _buffers = newbuf;</span>
        }
<span class="fc" id="L171">        UnifiedDataPageX prev = _buffers[idx];</span>
<span class="fc" id="L172">        _buffers[idx] = curr;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (idx &gt;= _buffer_count) {</span>
<span class="fc" id="L174">            _buffer_count = idx + 1;</span>
        }
        // if the caller wants us to we'll hold onto this
        // page for a bit, since it's now available
<span class="pc bpc" id="L178" title="4 of 8 branches missed.">        if (recycleOldPage</span>
         &amp;&amp; prev != null
         &amp;&amp; prev != curr
         &amp;&amp; (idx + 1) &lt; _buffers.length // it's not worth reallocating the _buffers array for this
         ) {
<span class="nc" id="L183">            _buffers[idx+1] = prev;</span>
        }
<span class="fc" id="L185">    }</span>

    /**
     * resets the buffer list to start at the current page
     * this releases any &quot;extra&quot; pages.  This does hold
     * on to 1 extra page, if there is one, since two pages
     * if a common occurrence for values that cross the
     * page boundary.
     *
     * when this exits there will be either just the current
     * page in the buffer list or the current page and 1
     * preallocated page just after it (in idx 1).
     */
    protected final void resetToCurrentPage()
    {
<span class="fc" id="L200">        int p0_idx = getCurrentPageIdx();</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (p0_idx &gt; 0) {</span>
            // this is a common &quot;do nothing&quot; case, it happens
            // when we reset to the page and there are no saved
            // pages - i.e. the mark is contained in curr
<span class="nc" id="L205">            release_pages_to(p0_idx);</span>
        }
<span class="fc" id="L207">    }</span>

    private final void release_pages_to(int p0_idx) {
<span class="nc bnc" id="L210" title="All 4 branches missed.">        assert(p0_idx &gt; 0);</span>

        // we'll try to save the now unneeded 0th empty page
<span class="nc" id="L213">        UnifiedDataPageX empty_page = _buffers[0];</span>

        // now bump all the page ptrs down to release the
        // pages that precede the current page
<span class="nc" id="L217">        int dst = 0;</span>
<span class="nc" id="L218">        int src = p0_idx;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        while (src&lt;_buffer_count) {</span>
<span class="nc" id="L220">            _buffers[dst++] = _buffers[src++];</span>
        }

        // clear any trailing page ptrs
<span class="nc" id="L224">        int end = _buffer_count + 1; // we may have an extra page ptr saved at buffer[count]</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (end &gt;= _buffers.length) {</span>
<span class="nc" id="L226">            end = _buffers.length;</span>
        }
<span class="nc bnc" id="L228" title="All 2 branches missed.">        while (dst &lt; end) {</span>
<span class="nc" id="L229">            _buffers[dst++] = null;</span>
        }

<span class="nc" id="L232">        _buffer_current -= p0_idx;</span>
<span class="nc" id="L233">        _buffer_count -= p0_idx;</span>
<span class="nc" id="L234">        _buffers[_buffer_count] = empty_page;</span>
<span class="nc" id="L235">    }</span>

    /**
     * this clears all the pages out, except to save
     * one page (unallocated)
     *
     */
    protected final void clear() {
<span class="fc" id="L243">        UnifiedDataPageX curr = getCurrentPage();</span>

<span class="fc bfc" id="L245" title="All 2 branches covered.">        for (int ii=0; ii&lt;_buffers.length; ii++) {</span>
<span class="fc" id="L246">            _buffers[ii] = null;</span>
        }

        // curr is null when underlying stream is empty.
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (curr != null)</span>
        {
<span class="fc" id="L252">            _buffers[0] = curr;</span>
<span class="fc" id="L253">            curr.reset(0);</span>
        }

<span class="fc" id="L256">        _buffer_count = 0;</span>
<span class="fc" id="L257">        _buffer_current = 0;</span>
<span class="fc" id="L258">    }</span>

    static class Bytes extends UnifiedInputBufferX {
        protected Bytes(int initialPageSize) {
<span class="fc" id="L262">            super(initialPageSize);</span>
<span class="fc" id="L263">        }</span>
        protected Bytes(byte[] bytes, int offset, int length) {
<span class="fc" id="L265">            super(length);</span>
<span class="fc" id="L266">            _buffers[0] = new UnifiedDataPageX.Bytes(bytes, offset, length);</span>
<span class="fc" id="L267">            _buffer_current = 0;</span>
<span class="fc" id="L268">            _buffer_count = 1;</span>
<span class="fc" id="L269">        }</span>
        @Override
<span class="nc" id="L271">        public final BufferType getType() { return BufferType.BYTES; }</span>

        @Override
        protected final UnifiedDataPageX make_page(int page_size) {
<span class="fc" id="L275">            UnifiedDataPageX p = new UnifiedDataPageX.Bytes(page_size);</span>
<span class="fc" id="L276">            return p;</span>
        }

        @Override
<span class="fc" id="L280">        public final int maxValue() { return 0xff; }</span>

    }
    static class Chars extends UnifiedInputBufferX {
        protected Chars(int initialPageSize) {
<span class="fc" id="L285">            super(initialPageSize);</span>
<span class="fc" id="L286">        }</span>
        /** Retains a reference to the chars array! */
        protected Chars(char[] chars, int offset, int length) {
<span class="fc" id="L289">            super(offset + length);</span>
<span class="fc" id="L290">            _buffers[0] = new UnifiedDataPageX.Chars(chars, offset, length);</span>
<span class="fc" id="L291">            _buffer_current = 0;</span>
<span class="fc" id="L292">            _buffer_count = 1;</span>

<span class="fc" id="L294">        }</span>
        /**
         * Makes a copy of the {@link CharSequence}.
         */
        protected Chars(CharSequence chars, int offset, int length) {
<span class="nc" id="L299">            this(chars_make_char_array(chars, offset, length), 0, length);</span>
<span class="nc" id="L300">        }</span>
        @Override
<span class="nc" id="L302">        public final BufferType getType() { return BufferType.CHARS; }</span>

        @Override
        protected final UnifiedDataPageX make_page(int page_size) {
<span class="fc" id="L306">            UnifiedDataPageX p = new UnifiedDataPageX.Chars(page_size);</span>
<span class="fc" id="L307">            return p;</span>
        }

        @Override
<span class="fc" id="L311">        public final int maxValue() { return 0xffff; }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>