<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SharedSymbolTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">SharedSymbolTable.java</span></div><h1>SharedSymbolTable.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.SystemSymbols.ION;
import static software.amazon.ion.SystemSymbols.ION_1_0;
import static software.amazon.ion.SystemSymbols.NAME_SID;
import static software.amazon.ion.SystemSymbols.SYMBOLS_SID;
import static software.amazon.ion.SystemSymbols.VERSION_SID;
import static software.amazon.ion.impl.PrivateUtils.getSidForSymbolTableField;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import software.amazon.ion.IonException;
import software.amazon.ion.IonReader;
import software.amazon.ion.IonStruct;
import software.amazon.ion.IonSystem;
import software.amazon.ion.IonType;
import software.amazon.ion.IonWriter;
import software.amazon.ion.ReadOnlyValueException;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.SystemSymbols;

/**
 * An &lt;em&gt;immutable&lt;/em&gt; shared symbol table, supporting (non-system) shared
 * symbol tables and system symbol tables.
 * &lt;p&gt;
 * Instances of this class are safe for use by multiple threads.
 */
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">final class SharedSymbolTable</span>
    implements SymbolTable
{
    /**
     * The array of system symbols as defined by Ion 1.0.
     */
<span class="fc" id="L55">    private static final String[] SYSTEM_SYMBOLS =</span>
    {
        SystemSymbols.ION,
        SystemSymbols.ION_1_0,
        SystemSymbols.ION_SYMBOL_TABLE,
        SystemSymbols.NAME,
        SystemSymbols.VERSION,
        SystemSymbols.IMPORTS,
        SystemSymbols.SYMBOLS,
        SystemSymbols.MAX_ID,
        SystemSymbols.ION_SHARED_SYMBOL_TABLE
    };

    /**
     * The &lt;b&gt;singleton&lt;/b&gt; instance of Ion 1.0 system symbol table.
     * &lt;p&gt;
     * TODO amzn/ion-java#34 Optimize system symtabs by using our custom backing impl.
     */
    private static final SymbolTable ION_1_0_SYSTEM_SYMTAB;
    static
    {
<span class="fc" id="L76">        Map&lt;String, Integer&gt; systemSymbolsMap = new HashMap&lt;String, Integer&gt;();</span>

<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (int i = 0; i &lt; SYSTEM_SYMBOLS.length; i++)</span>
        {
<span class="fc" id="L80">            systemSymbolsMap.put(SYSTEM_SYMBOLS[i], i+1);</span>
        }

<span class="fc" id="L83">        ION_1_0_SYSTEM_SYMTAB =</span>
            new SharedSymbolTable(ION, 1, SYSTEM_SYMBOLS, systemSymbolsMap);
<span class="fc" id="L85">    }</span>

    /**
     * The name of this shared symbol table. If this is a system symbol
     * table, it is {@link SystemSymbols#ION}.
     */
    private final String                        myName;

    /**
     * The version of this shared symbol table.
     */
    private final int                           myVersion;

    /**
     * The names (aka text) of declared symbols in this shared symbol
     * table (that are not imported from some other symbol table); never null.
     * The sid of the first element is 1.
     * &lt;p&gt;
     * Note that null references are valid elements within this member field,
     * denoting undefined symbol IDs (&quot;gaps&quot;).
     */
    private final String[]                      mySymbolNames;

    /**
     * Map of symbol names to symbol ids of declared symbols.
     */
    private final Map&lt;String, Integer&gt;          mySymbolsMap;

    //==========================================================================
    // Private constructor(s) and static factory methods
    //==========================================================================

    private SharedSymbolTable(String name, int version,
                              List&lt;String&gt; symbolsList,
                              Map&lt;String, Integer&gt; symbolsMap)
<span class="fc" id="L120">    {</span>
<span class="fc" id="L121">        myName          = name;</span>
<span class="fc" id="L122">        myVersion       = version;</span>
<span class="fc" id="L123">        mySymbolsMap    = symbolsMap;</span>

        // Construct primitive fixed-length array from the passed-in List
<span class="fc" id="L126">        mySymbolNames   = symbolsList.toArray(new String[symbolsList.size()]);</span>
<span class="fc" id="L127">    }</span>

    private SharedSymbolTable(String name, int version,
                              String[] symbolNames,
                              Map&lt;String, Integer&gt; symbolsMap)
<span class="fc" id="L132">    {</span>
<span class="fc" id="L133">        myName          = name;</span>
<span class="fc" id="L134">        myVersion       = version;</span>
<span class="fc" id="L135">        mySymbolsMap    = symbolsMap;</span>

<span class="fc" id="L137">        mySymbolNames   = symbolNames;</span>
<span class="fc" id="L138">    }</span>

    /**
     * Constructs a new shared symbol table from the parameters.
     * &lt;p&gt;
     * As per {@link IonSystem#newSharedSymbolTable(String, int, Iterator, SymbolTable...)},
     * any duplicate or null symbol texts are skipped.
     * &lt;p&gt;
     * Therefore, &lt;b&gt;THIS METHOD IS NOT SUITABLE WHEN READING SERIALIZED
     * SHARED SYMBOL TABLES&lt;/b&gt; since that scenario must preserve all sids.
     *
     * @param name              the name of the new shared symbol table
     * @param version           the version of the new shared symbol table
     * @param priorSymtab       may be null
     * @param symbols           never null
     */
    static SymbolTable newSharedSymbolTable(String name, int version,
                                            SymbolTable priorSymtab,
                                            Iterator&lt;String&gt; symbols)
    {
<span class="fc bfc" id="L158" title="All 4 branches covered.">        if (name == null || name.length() &lt; 1)</span>
        {
<span class="fc" id="L160">            throw new IllegalArgumentException(&quot;name must be non-empty&quot;);</span>
        }
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (version &lt; 1)</span>
        {
<span class="fc" id="L164">            throw new IllegalArgumentException(&quot;version must be at least 1&quot;);</span>
        }

<span class="fc" id="L167">        List&lt;String&gt; symbolsList = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L168">        Map&lt;String, Integer&gt; symbolsMap = new HashMap&lt;String, Integer&gt;();</span>

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        assert version ==</span>
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">            (priorSymtab == null ? 1 : priorSymtab.getVersion() + 1);</span>

<span class="fc" id="L173">        prepSymbolsListAndMap(priorSymtab, symbols, symbolsList, symbolsMap);</span>

        // We have all necessary data, pass it over to the private constructor.
<span class="fc" id="L176">        return new SharedSymbolTable(name, version, symbolsList, symbolsMap);</span>
    }

    /**
     * Constructs a new shared symbol table represented by the passed in
     * {@link IonStruct}.
     *
     * @param ionRep
     *          the {@link IonStruct} representing the new shared symbol table
     * @return
     */
    static SymbolTable newSharedSymbolTable(IonStruct ionRep)
    {
<span class="fc" id="L189">        IonReader reader = new IonReaderTreeSystem(ionRep);</span>
<span class="fc" id="L190">        return newSharedSymbolTable(reader, false);</span>
    }

    /**
     * Constructs a new shared symbol table represented by the current value
     * of the passed in {@link IonReader}.
     *
     * @param reader
     *          the {@link IonReader} positioned on the shared symbol table
     *          represented as an {@link IonStruct}
     * @param isOnStruct
     *          denotes whether the {@link IonReader} is already positioned on
     *          the struct; false if it is positioned before the struct
     * @return
     */
    static SymbolTable newSharedSymbolTable(IonReader reader,
                                            boolean isOnStruct)
    {
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (! isOnStruct)</span>
        {
<span class="fc" id="L210">            IonType t = reader.next();</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (t != IonType.STRUCT)</span>
            {
<span class="nc" id="L213">                throw new IonException(&quot;invalid symbol table image passed &quot; +</span>
                                &quot;into reader, &quot; + t + &quot; encountered when a &quot; +
                                &quot;struct was expected&quot;);
            }
        }

<span class="fc" id="L219">        String name = null;</span>
<span class="fc" id="L220">        int version = -1;</span>
<span class="fc" id="L221">        List&lt;String&gt; symbolsList = new ArrayList&lt;String&gt;();</span>

<span class="fc" id="L223">        reader.stepIn();</span>

<span class="fc" id="L225">        IonType fieldType = null;</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        while ((fieldType = reader.next()) != null)</span>
        {
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (reader.isNullValue()) continue;</span>

<span class="fc" id="L230">            SymbolToken symTok = reader.getFieldNameSymbol();</span>
<span class="fc" id="L231">            int sid = symTok.getSid();</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            if (sid == SymbolTable.UNKNOWN_SYMBOL_ID)</span>
            {
                // This is a user-defined IonReader or a pure DOM, fall
                // back to text
<span class="nc" id="L236">                final String fieldName = reader.getFieldName();</span>
<span class="nc" id="L237">                sid = getSidForSymbolTableField(fieldName);</span>
            }

            // TODO amzn/ion-java#35 If there's more than one 'symbols' or 'imports'
            //      field, they will be merged together.
            // TODO amzn/ion-java#36 Switching over SIDs doesn't cover the case
            //      where the relevant field names are defined by a prev LST;
            //      the prev LST could have 'symbols' defined locally with a
            //      different SID!
<span class="fc bfc" id="L246" title="All 4 branches covered.">            switch (sid)</span>
            {
                case VERSION_SID:
<span class="fc bfc" id="L249" title="All 2 branches covered.">                    if (fieldType == IonType.INT)</span>
                    {
<span class="fc" id="L251">                        version = reader.intValue();</span>
                    }
                    break;
                case NAME_SID:
<span class="fc bfc" id="L255" title="All 2 branches covered.">                    if (fieldType == IonType.STRING)</span>
                    {
<span class="fc" id="L257">                        name = reader.stringValue();</span>
                    }
                    break;
                case SYMBOLS_SID:
                    // As per the Spec, other field types are treated as
                    // empty lists
<span class="fc bfc" id="L263" title="All 2 branches covered.">                    if (fieldType == IonType.LIST)</span>
                    {
<span class="fc" id="L265">                        reader.stepIn();</span>
                        {
                            IonType t;
<span class="fc bfc" id="L268" title="All 2 branches covered.">                            while ((t = reader.next()) != null)</span>
                            {
<span class="fc" id="L270">                                String text = null;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                                if (t == IonType.STRING</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                                    &amp;&amp; ! reader.isNullValue())</span>
                                {
                                    // As per the Spec, if any element of
                                    // the list is the empty string or any
                                    // other type, treat it as null
<span class="fc" id="L277">                                    text = reader.stringValue();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                                    if (text.length() == 0) text = null;</span>
                                }
<span class="fc" id="L280">                                symbolsList.add(text);</span>
<span class="fc" id="L281">                            }</span>
                        }
<span class="fc" id="L283">                        reader.stepOut();</span>
                    }
                    break;
                default:
                    break;
            }
<span class="fc" id="L289">        }</span>

<span class="fc" id="L291">        reader.stepOut();</span>

<span class="fc bfc" id="L293" title="All 4 branches covered.">        if (name == null || name.length() == 0)</span>
        {
<span class="fc" id="L295">            String message =</span>
                &quot;shared symbol table is malformed: field 'name' &quot; +
                &quot;must be a non-empty string.&quot;;
<span class="fc" id="L298">            throw new IonException(message);</span>
        }

        // As per the Spec, if 'version' field is missing or not at
        // least 1, treat it as 1.
<span class="fc bfc" id="L303" title="All 2 branches covered.">        version = (version &lt; 1) ? 1 : version;</span>

<span class="fc" id="L305">        Map&lt;String, Integer&gt; symbolsMap = null;</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (! symbolsList.isEmpty())</span>
        {
<span class="fc" id="L308">            symbolsMap = new HashMap&lt;String, Integer&gt;();</span>
<span class="fc" id="L309">            transferNonExistingSymbols(symbolsList, symbolsMap);</span>
        }
        else
        {
            // Empty Map is more efficient than an empty HashMap
<span class="fc" id="L314">            symbolsMap = Collections.emptyMap();</span>
        }

        // We have all necessary data, pass it over to the private constructor.
<span class="fc" id="L318">        return new SharedSymbolTable(name, version, symbolsList, symbolsMap);</span>
    }

    /**
     * Gets a specific version of the system symbol table.
     *
     * @param version
     *          the specified version of the system symbol table; currently,
     *          only version 1 (Ion 1.0) is supported
     * @return
     *
     * @throws IllegalArgumentException if the specified version isn't supported
     */
    static SymbolTable getSystemSymbolTable(int version)
    {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">        if (version != 1)</span>
        {
<span class="nc" id="L335">            throw new IllegalArgumentException(&quot;only Ion 1.0 system &quot; +</span>
                        &quot;symbols are supported&quot;);
        }

<span class="fc" id="L339">        return ION_1_0_SYSTEM_SYMTAB;</span>
    }

    //==========================================================================
    // Static methods relating to construction
    //==========================================================================

    private static void putToMapIfNotThere(Map&lt;String, Integer&gt; symbolsMap,
                                           String text, int sid)
    {
        // When there's a duplicate mapping for the symbol text, don't
        // replace the lower sid. This pattern avoids double-lookup in the
        // common scenario and only performs a second lookup when there's
        // a duplicate.
<span class="fc" id="L353">        Integer extantSid = symbolsMap.put(text, sid);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (extantSid != null)</span>
        {
            // We always insert symbols with increasing sids
<span class="pc bpc" id="L357" title="2 of 4 branches missed.">            assert extantSid &lt; sid;</span>
<span class="fc" id="L358">            symbolsMap.put(text, extantSid);</span>
        }
<span class="fc" id="L360">    }</span>

    /**
     * Collects the necessary symbols from {@code priorSymtab} and
     * {@code symbols}, and load them into the passed-in {@code symbolsList} and
     * {@code symbolsMap}.
     */
    private static void
    prepSymbolsListAndMap(SymbolTable priorSymtab, Iterator&lt;String&gt; symbols,
                          List&lt;String&gt; symbolsList,
                          Map&lt;String, Integer&gt; symbolsMap)
    {
<span class="fc" id="L372">        int sid = 1;</span>

        // Collect from passed-in priorSymtab
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (priorSymtab != null)</span>
        {
<span class="fc" id="L377">            Iterator&lt;String&gt; priorSymbols =</span>
<span class="fc" id="L378">                priorSymtab.iterateDeclaredSymbolNames();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            while (priorSymbols.hasNext())</span>
            {
<span class="fc" id="L381">                String text = priorSymbols.next();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                if (text != null)</span>
                {
<span class="pc bpc" id="L384" title="2 of 4 branches missed.">                    assert text.length() &gt; 0;</span>
<span class="fc" id="L385">                    putToMapIfNotThere(symbolsMap, text, sid);</span>
                }

                // NB: Null entries must be added in the sid sequence
                //     to retain compat. with the prior version.
<span class="fc" id="L390">                symbolsList.add(text);</span>

<span class="fc" id="L392">                sid++;</span>
<span class="fc" id="L393">            }</span>
        }

        // Collect from passed-in symbols
<span class="fc bfc" id="L397" title="All 2 branches covered.">        while (symbols.hasNext())</span>
        {
<span class="fc" id="L399">            String text = symbols.next();</span>
            // TODO amzn/ion-java#12 What about empty symbols?
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (symbolsMap.get(text) == null)</span>
            {
<span class="fc" id="L403">                putToMapIfNotThere(symbolsMap, text, sid);</span>
<span class="fc" id="L404">                symbolsList.add(text);</span>
<span class="fc" id="L405">                sid++;</span>
            }
<span class="fc" id="L407">        }</span>
<span class="fc" id="L408">    }</span>

    /**
     * Transfer symbols from {@code symbolsList} to {@code symbolsMap} that
     * doesn't already exist in the map.
     */
    private static void
    transferNonExistingSymbols(List&lt;String&gt; symbolsList,
                               Map&lt;String, Integer&gt; symbolsMap)
    {
<span class="fc" id="L418">        int sid = 1;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (String text : symbolsList)</span>
        {
<span class="pc bpc" id="L421" title="2 of 6 branches missed.">            assert text == null || text.length() &gt; 0;</span>

<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (text != null)</span>
            {
<span class="fc" id="L425">                putToMapIfNotThere(symbolsMap, text, sid);</span>
            }

<span class="fc" id="L428">            sid++;</span>
<span class="fc" id="L429">        }</span>
<span class="fc" id="L430">    }</span>

    //==========================================================================
    // Public methods
    //==========================================================================

    public String getName()
    {
<span class="fc" id="L438">        return myName;</span>
    }

    public int getVersion()
    {
<span class="fc" id="L443">        return myVersion;</span>
    }

    public boolean isLocalTable()
    {
<span class="fc" id="L448">        return false;</span>
    }

    public boolean isSharedTable()
    {
<span class="fc" id="L453">        return true;</span>
    }

    public boolean isSubstitute()
    {
<span class="fc" id="L458">        return false;</span>
    }

    public boolean isSystemTable()
    {
<span class="fc" id="L463">        return ION.equals(myName);</span>
    }

    public boolean isReadOnly()
    {
<span class="fc" id="L468">        return true;</span>
    }

    public void makeReadOnly()
    {
        // No-op
<span class="nc" id="L474">    }</span>

    public SymbolTable getSystemSymbolTable()
    {
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (isSystemTable()) return this;</span>

<span class="fc" id="L480">        return null; // non-system shared table</span>
    }

    public String getIonVersionId()
    {
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (isSystemTable())</span>
        {
<span class="fc" id="L487">            int id = getVersion();</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            if (id != 1)</span>
            {
<span class="nc" id="L490">                throw new IonException(&quot;unrecognized system version &quot; +</span>
                		&quot;encountered: &quot; + id);
            }

<span class="fc" id="L494">            return ION_1_0;</span>
        }

<span class="fc" id="L497">        return null; // non-system shared tables aren't tied to an Ion version</span>
    }

    public SymbolTable[] getImportedTables()
    {
<span class="fc" id="L502">        return null;</span>
    }

    public int getImportedMaxId()
    {
<span class="fc" id="L507">        return 0;</span>
    }

    public int getMaxId()
    {
<span class="fc" id="L512">        return mySymbolNames.length;</span>
    }

    public SymbolToken intern(String text)
    {
<span class="fc" id="L517">        SymbolToken symTok = find(text);</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (symTok == null)</span>
        {
<span class="fc" id="L520">            throw new ReadOnlyValueException(SymbolTable.class);</span>
        }

<span class="fc" id="L523">        return symTok;</span>
    }

    public SymbolToken find(String text)
    {
<span class="fc" id="L528">        text.getClass(); // fast null check</span>

<span class="fc" id="L530">        Integer sid = mySymbolsMap.get(text);</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (sid != null)</span>
        {
<span class="pc bpc" id="L533" title="2 of 4 branches missed.">            assert sid != UNKNOWN_SYMBOL_ID;</span>

<span class="fc" id="L535">            int offset = sid - 1;</span>
<span class="fc" id="L536">            String internedText = mySymbolNames[offset];</span>

<span class="pc bpc" id="L538" title="2 of 4 branches missed.">            assert internedText != null;</span>

<span class="fc" id="L540">            return new SymbolTokenImpl(internedText, sid);</span>
        }

<span class="fc" id="L543">        return null;</span>
    }

    public int findSymbol(String name)
    {
<span class="fc" id="L548">        Integer sid = mySymbolsMap.get(name);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (sid != null)</span>
        {
<span class="fc" id="L551">            return sid;</span>
        }

<span class="fc" id="L554">        return UNKNOWN_SYMBOL_ID;</span>
    }

    public String findKnownSymbol(int id)
    {
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (id &lt; 0)</span>
        {
<span class="nc" id="L561">            throw new IllegalArgumentException(&quot;symbol IDs must be &gt;= 0&quot;);</span>
        }

<span class="fc" id="L564">        int offset = id - 1;</span>
<span class="fc bfc" id="L565" title="All 4 branches covered.">        if (id != 0 &amp;&amp; offset &lt; mySymbolNames.length)</span>
        {
<span class="fc" id="L567">            return mySymbolNames[offset];</span>
        }

<span class="fc" id="L570">        return null;</span>
    }

    public Iterator&lt;String&gt; iterateDeclaredSymbolNames()
    {
<span class="fc" id="L575">        return Collections</span>
<span class="fc" id="L576">            .unmodifiableList(Arrays.asList(mySymbolNames)) // unsupported remove()</span>
<span class="fc" id="L577">            .iterator();</span>
    }

    public void writeTo(IonWriter writer) throws IOException
    {
<span class="fc" id="L582">        IonReader reader = new SymbolTableReader(this);</span>
<span class="fc" id="L583">        writer.writeValues(reader);</span>
<span class="fc" id="L584">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>