<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderTextRawTokensX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderTextRawTokensX.java</span></div><h1>IonReaderTextRawTokensX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2009-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1;
import static software.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2;
import static software.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3;
import static software.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1;
import static software.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2;
import static software.amazon.ion.impl.IonTokenConstsX.CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3;
import static software.amazon.ion.util.IonTextUtils.printCodePointAsString;

import java.io.IOException;
import software.amazon.ion.IonException;
import software.amazon.ion.IonType;
import software.amazon.ion.UnexpectedEofException;
import software.amazon.ion.impl.IonTokenConstsX.CharacterSequence;
import software.amazon.ion.impl.UnifiedSavePointManagerX.SavePoint;
import software.amazon.ion.util.IonTextUtils;

/**
 * Tokenizer for the Ion text parser in IonTextIterator. This
 * reads bytes and returns the interesting tokens it recognizes
 * or an error.  While, currently, this does UTF-8 decoding
 * as it goes that is unnecessary.  The main entry point is
 * lookahead(n) which gets the token type n tokens ahead (0
 * is the next token).  The tokens type, its starting offset
 * in the input stream and its ending offset in the input stream
 * are cached, so lookahead() can be called repeatedly with
 * little overhead.  This supports a 7 token lookahead and requires
 * a &quot;recompile&quot; to change this limit.  (this could be &quot;fixed&quot;
 * but seems unnecessary at this time - the limit is in
 * IonTextTokenizer._token_lookahead_size which is 1 larger than
 * the size of the lookahead allowed)  Tokens are consumed by
 * a call to consumeToken, or the helper consumeTokenAsString.
 * The informational interfaces - getValueStart(), getValueEnd()
 * getValueAsString() can be used to get the contents of the
 * value once the caller has decided how to use it.
 *
 *  This is a copy and paste from IonTextTokenize on the introduction of
 *  the new input abstraction IonInputStream as the source of characters
 *  and bytes for the reader.
 *
 *  This variation does NOT make local copies of the tokens.  It does
 *  start &quot;marking&quot; at the beginning of the token and the end.  The stream
 *  will buffer the input until the mark is released.
 *
 *  The result is that only the most recent token is available to the
 *  calling reader.
 *
 */
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">final class IonReaderTextRawTokensX</span>
{
    static final boolean _debug = false;

<span class="fc" id="L68">    private static final Appendable NULL_APPENDABLE = new Appendable()</span>
<span class="fc" id="L69">    {</span>
        public Appendable append(CharSequence csq) throws IOException
        {
<span class="nc" id="L72">            return this;</span>
        }

        public Appendable append(CharSequence csq, int start, int end)
            throws IOException
        {
<span class="nc" id="L78">            return this;</span>
        }

        public Appendable append(char c) throws IOException
        {
<span class="fc" id="L83">            return this;</span>
        }
    };

    static final int   BASE64_EOF = 128; // still a byte, not -1, none of the low 6 bits on
<span class="fc" id="L88">    static final int[] BASE64_CHAR_TO_BIN = Base64Encoder.Base64EncodingCharToInt;</span>
<span class="fc" id="L89">    static final int   BASE64_TERMINATOR_CHAR = Base64Encoder.Base64EncodingTerminator;</span>

<span class="fc" id="L91">    private UnifiedInputStreamX  _stream = null;</span>
<span class="fc" id="L92">    private int                 _token = -1;</span>
    /** are we at the beginning of this token (false == done with it) */
    private boolean             _unfinished_token;
    private long                _line_count;
    private long                _line_starting_position;
<span class="fc" id="L97">    private boolean             _line_count_has_cached = false;</span>
    private long                _line_count_cached;
    private long                _line_offset_cached;

    /** number of base64 decoded bytes in the stack, used to decode base64 */
    private int                 _base64_prefetch_count;
    /**
     * since this &quot;stack&quot; will only 0-2 bytes deep, we'll just shift them
     * into an int
     */
    private int                 _base64_prefetch_stack;


    /**
     * IonTokenReader constructor requires a UnifiedInputStream
     * as the source of bytes/chars that serve as the basic input
     *
     * @param iis wrapped input stream
     */
    public IonReaderTextRawTokensX(UnifiedInputStreamX iis) {
<span class="nc" id="L117">        this(iis, 1, 1);</span>
<span class="nc" id="L118">    }</span>

    public IonReaderTextRawTokensX(UnifiedInputStreamX iis, long starting_line,
                                   long starting_column)
<span class="fc" id="L122">    {</span>
<span class="fc" id="L123">        _stream = iis;</span>
<span class="fc" id="L124">        _line_count = starting_line;</span>
<span class="fc" id="L125">        _line_starting_position = _stream.getPosition() - starting_column;</span>
<span class="fc" id="L126">    }</span>

    public void close()
        throws IOException
    {
<span class="fc" id="L131">        _stream.close();</span>
<span class="fc" id="L132">    }</span>

<span class="fc" id="L134">    public int  getToken()      { return _token; }</span>
<span class="fc" id="L135">    public long getLineNumber() { return _line_count; }</span>
    public long getLineOffset() {
<span class="fc" id="L137">        long stream_position = _stream.getPosition();</span>
<span class="fc" id="L138">        long offset = stream_position - _line_starting_position;</span>
<span class="fc" id="L139">        return offset;</span>
    }

<span class="fc" id="L142">    UnifiedInputStreamX getSourceStream() { return this._stream; }</span>

    public final boolean isBufferedInput()
    {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        boolean is_buffered = ! _stream._is_stream;</span>
<span class="fc" id="L147">        return is_buffered;</span>
    }

    protected String input_position() {
<span class="fc" id="L151">        String s = &quot; at line &quot;</span>
<span class="fc" id="L152">                + getLineNumber()</span>
                + &quot; offset &quot;
<span class="fc" id="L154">                + getLineOffset();</span>
<span class="fc" id="L155">        return s;</span>
    }
<span class="fc" id="L157">    public final boolean isUnfinishedToken() { return  _unfinished_token; }</span>

    public final void tokenIsFinished() {
<span class="fc" id="L160">        _unfinished_token = false;</span>
<span class="fc" id="L161">        _base64_prefetch_count = 0;</span>
<span class="fc" id="L162">    }</span>

    //
    //  character routines to fetch characters and
    //  handle look ahead and line counting and such
    //
    protected final int read_char() throws IOException
    {
<span class="fc" id="L170">        int c = _stream.read();</span>
<span class="fc bfc" id="L171" title="All 4 branches covered.">        if (c == '\r' || c == '\n') {</span>
<span class="fc" id="L172">            c = line_count(c);</span>
        }
<span class="fc" id="L174">        return c;</span>
    }

    /**
     * NOT for use outside of string/symbol/clob!
     * Absorbs backslash-NL pairs, returning
     * {@link #CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1} etc.
     */
    protected final int read_string_char(ProhibitedCharacters prohibitedCharacters) throws IOException
    {
<span class="fc" id="L184">        int c = _stream.read();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (prohibitedCharacters.includes(c)) {</span>
<span class="nc" id="L186">            error(&quot;invalid character [&quot; + printCodePointAsString(c) + &quot;]&quot;);</span>
        }
        // the c == '\\' clause will cause us to eat ALL slash-newlines
<span class="fc bfc" id="L189" title="All 6 branches covered.">        if (c == '\r' || c == '\n' || c == '\\') {</span>
<span class="fc" id="L190">            c = line_count(c);</span>
        }
<span class="fc" id="L192">        return c;</span>
    }

    private final void unread_char(int c)
    {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (c &lt; 0) {</span>
<span class="pc bpc" id="L198" title="4 of 8 branches missed.">            switch (c) {</span>
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<span class="fc" id="L200">                line_count_unread(c);</span>
<span class="fc" id="L201">                _stream.unread('\n');</span>
<span class="fc" id="L202">                break;</span>
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<span class="fc" id="L204">                line_count_unread(c);</span>
<span class="fc" id="L205">                _stream.unread('\r');</span>
<span class="fc" id="L206">                break;</span>
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<span class="fc" id="L208">                line_count_unread(c);</span>
<span class="fc" id="L209">                _stream.unread('\n');</span>
<span class="fc" id="L210">                _stream.unread('\r');</span>
<span class="fc" id="L211">                break;</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
<span class="nc" id="L213">                _stream.unread('\n');</span>
<span class="nc" id="L214">                _stream.unread('\\');</span>
<span class="nc" id="L215">                break;</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
<span class="nc" id="L217">                _stream.unread('\r');</span>
<span class="nc" id="L218">                _stream.unread('\\');</span>
<span class="nc" id="L219">                break;</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<span class="nc" id="L221">                _stream.unread('\n');</span>
<span class="nc" id="L222">                _stream.unread('\r');</span>
<span class="nc" id="L223">                _stream.unread('\\');</span>
<span class="nc" id="L224">                break;</span>
            case UnifiedInputStreamX.EOF:
<span class="fc" id="L226">                _stream.unread(UnifiedInputStreamX.EOF);</span>
<span class="fc" id="L227">                break;</span>
            default:
<span class="nc bnc" id="L229" title="All 2 branches missed.">                assert false</span>
                    : &quot;INVALID SPECIAL CHARACTER ENCOUNTERED: &quot; + c;
            }
        }
        else  {
<span class="fc" id="L234">            _stream.unread(c);</span>
        }
<span class="fc" id="L236">    }</span>

    private final int line_count_unread(int c) {
<span class="pc bpc" id="L239" title="8 of 14 branches missed.">        assert( c == CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1</span>
             || c == CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2
             || c == CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3
             || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1
             || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2
             || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3
        );
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (_line_count_has_cached) {</span>
<span class="fc" id="L247">            _line_count = _line_count_cached;</span>
<span class="fc" id="L248">            _line_starting_position = _line_offset_cached;</span>
<span class="fc" id="L249">            _line_count_has_cached = false;</span>
        }
<span class="fc" id="L251">        return c;</span>
    }
    private final int line_count(int c) throws IOException
    {
        // check for the slash new line case (and we'l
        // consume both here it that's what we find
<span class="pc bpc" id="L257" title="1 of 4 branches missed.">        switch (c) {</span>
        case '\\':
            {
<span class="fc" id="L260">                int c2 = _stream.read();</span>
<span class="fc bfc" id="L261" title="All 3 branches covered.">                switch (c2) {</span>
                case '\r':  // DOS &lt;cr&gt;&lt;lf&gt;  or old Mac &lt;cr&gt;
<span class="fc" id="L263">                    int c3 = _stream.read();</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">                    if (c3 != '\n') {</span>
<span class="fc" id="L265">                        unread_char(c3);</span>
<span class="fc" id="L266">                        c = CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2;</span>
                    }
                    else {
<span class="fc" id="L269">                        c = CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3;</span>
                    }
<span class="fc" id="L271">                    break;</span>
                case '\n':
                    // Unix and new Mac (also Unix) &lt;lf&gt;
<span class="fc" id="L274">                    c = CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1;</span>
<span class="fc" id="L275">                    break;</span>
                default:
                    // not a slash new line, so we'll just return the slash
                    // leave it to be handled elsewhere
<span class="fc" id="L279">                    unread_char(c2);</span>
<span class="fc" id="L280">                    return c;</span>
                }
            }
<span class="fc" id="L283">            break;</span>
        case '\r':
            {
                // convert '\r' or '\r\n' into the appropriate CHAR_SEQ
                // pseudo character
<span class="fc" id="L288">                int c2 = _stream.read();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                if (c2 == '\n') {</span>
<span class="fc" id="L290">                    c = CHAR_SEQ_NEWLINE_SEQUENCE_3;</span>
                }
                else {
<span class="fc" id="L293">                    unread_char(c2);</span>
<span class="fc" id="L294">                    c = CHAR_SEQ_NEWLINE_SEQUENCE_2;</span>
                }
            }
<span class="fc" id="L297">            break;</span>
        case '\n':
<span class="fc" id="L299">            c = CHAR_SEQ_NEWLINE_SEQUENCE_1;</span>
<span class="fc" id="L300">            break;</span>
        default:
<span class="nc" id="L302">            throw new IllegalStateException();</span>
        }

        // before we adjust the line count we save it so that
        // we can recover from a unread of a line terminator
        // note that we can only recover from a single line
        // terminator unread, but that should be enough.  We
        // only unread whitespace if it's a delimiter, and
        // then we only have to unread a single instance.
<span class="fc" id="L311">        _line_count_cached = _line_count;</span>
<span class="fc" id="L312">        _line_offset_cached = _line_starting_position;</span>
<span class="fc" id="L313">        _line_count_has_cached = true;</span>

        // anything else (and that should only be either a new line
        // of IonTokenConsts.ESCAPED_NEWLINE_SEQUENCE passed in) we will
        // return the char unchanged and line count
<span class="fc" id="L318">        _line_count++;</span>
        // since we want the first character of the line to be 1, not 0:
<span class="fc" id="L320">        _line_starting_position = _stream.getPosition() - 1;</span>

<span class="fc" id="L322">        return c;</span>
    }

    /**
     * peeks into the input stream to see if the next token
     * would be a double colon.  If indeed this is the case
     * it skips the two colons and returns true.  If not
     * it unreads the 1 or 2 real characters it read and
     * return false.
     * It always consumes any preceding whitespace.
     * @return true if the next token is a double colon, false otherwise
     * @throws IOException
     */
    public final boolean skipDoubleColon() throws IOException
    {
<span class="fc" id="L337">        int c = skip_over_whitespace();</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (c != ':') {</span>
<span class="fc" id="L339">            unread_char(c);</span>
<span class="fc" id="L340">            return false;</span>
        }
<span class="fc" id="L342">        c = read_char();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (c != ':') {</span>
<span class="fc" id="L344">            unread_char(c);</span>
<span class="fc" id="L345">            unread_char(':');</span>
<span class="fc" id="L346">            return false;</span>
        }
<span class="fc" id="L348">        return true;</span>
    }


    /**
     * peeks into the input stream to see if we have an
     * unquoted symbol that resolves to one of the ion
     * types.  If it does it consumes the input and
     * returns the type keyword id.  If not is unreads
     * the non-whitespace characters and the dot, which
     * the input argument 'c' should be.
     */
    public final int peekNullTypeSymbol() throws IOException
    {
        // the '.' has to follow the 'null' immediately
<span class="fc" id="L363">        int c = read_char();</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (c != '.') {</span>
<span class="fc" id="L365">            unread_char(c);</span>
<span class="fc" id="L366">            return IonTokenConstsX.KEYWORD_none;</span>
        }

        // we have a dot, start reading through the following non-whitespace
        // and we'll collect it so that we can unread it in the event
        // we don't actually see a type name
<span class="fc" id="L372">        int[] read_ahead = new int[IonTokenConstsX.TN_MAX_NAME_LENGTH + 1];</span>
<span class="fc" id="L373">        int read_count = 0;</span>
<span class="fc" id="L374">        int possible_names = IonTokenConstsX.KW_ALL_BITS;</span>

<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        while (read_count &lt; IonTokenConstsX.TN_MAX_NAME_LENGTH + 1) {</span>
<span class="fc" id="L377">            c = read_char();</span>
<span class="fc" id="L378">            read_ahead[read_count++] = c;</span>
<span class="fc" id="L379">            int letter_idx = IonTokenConstsX.typeNameLetterIdx(c);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if (letter_idx &lt; 1) {</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">                if (IonTokenConstsX.isValidTerminatingCharForInf(c)) {</span>
                    // it's not a letter we care about but it is
                    // a valid end of const, so maybe we have a keyword now
                    // we always exit the loop here since we look
                    // too far so any letter is invalid at pos 10
<span class="fc" id="L386">                    break;</span>
                }
<span class="nc" id="L388">                return peekNullTypeSymbolUndo(read_ahead, read_count);</span>
            }
<span class="fc" id="L390">            int mask = IonTokenConstsX.typeNamePossibilityMask(read_count - 1, letter_idx);</span>
<span class="fc" id="L391">            possible_names &amp;= mask;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if (possible_names == 0) {</span>
                // in this case it can't be a valid keyword since
                // it has identifier chars (letters) at 1 past the
                // last possible end (at least)
<span class="nc" id="L396">                return peekNullTypeSymbolUndo(read_ahead, read_count);</span>
            }
<span class="fc" id="L398">        }</span>
        // now lets get the keyword value from our bit mask
        // at this point we can fail since we may have hit
        // a valid terminator before we're done with all key
        // words.  We even have to check the length.
        // for example &quot;in)&quot; matches both letters to the
        // typename int and terminates validly - but isn't
        // long enough, but with length we have enough to be sure
        // with the actual type names we're using in 1.0
<span class="fc" id="L407">        int kw = IonTokenConstsX.typeNameKeyWordFromMask(possible_names, read_count-1);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (kw == IonTokenConstsX.KEYWORD_unrecognized) {</span>
<span class="nc" id="L409">            peekNullTypeSymbolUndo(read_ahead, read_count);</span>
        }
        else {
            // since we're accepting the rest we aren't unreading anything
            // else - but we still have to unread the character that stopped us
<span class="fc" id="L414">            unread_char(c);</span>
        }
<span class="fc" id="L416">        return kw;</span>
    }
    private final int peekNullTypeSymbolUndo(int[] read_ahead, int read_count)
    {
<span class="fc" id="L420">        String type_error = &quot;&quot;;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (int ii=0; ii&lt;read_count; ii++) {</span>
            // this (string concatenation) is horrible, but we're about throw anyway
<span class="fc" id="L423">            type_error += (char)read_ahead[ii];</span>
        }

<span class="fc" id="L426">        String message = &quot;invalid type name on a typed null value&quot;;</span>
<span class="nc" id="L427">        error(message); // this throws so we won't actually return</span>
<span class="nc" id="L428">        return IonTokenConstsX.KEYWORD_unrecognized;</span>
    }

    /**
     * peeks into the input stream to see what non-whitespace
     * character is coming up.  If it is a double quote or
     * a triple quote this returns true as either distinguished
     * the contents of a lob as distinctly a clob.  Otherwise
     * it returns false.
     * In either case it unreads whatever non-whitespace it read
     * to decide.
     * @return true if the next token is a double or triple quote, false otherwise
     * @throws IOException
     */
    public final int peekLobStartPunctuation() throws IOException
    {
<span class="fc" id="L444">        int c = skip_over_lob_whitespace();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (c == '&quot;') {</span>
            //unread_char(c);
<span class="fc" id="L447">            return IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE;</span>
        }
<span class="fc bfc" id="L449" title="All 2 branches covered.">        if (c != '\'') {</span>
<span class="fc" id="L450">            unread_char(c);</span>
<span class="fc" id="L451">            return IonTokenConstsX.TOKEN_ERROR;</span>
        }
<span class="fc" id="L453">        c = read_char();</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (c != '\'') {</span>
<span class="fc" id="L455">            unread_char(c);</span>
<span class="fc" id="L456">            unread_char('\'');</span>
<span class="fc" id="L457">            return IonTokenConstsX.TOKEN_ERROR;</span>
        }
<span class="fc" id="L459">        c = read_char();</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (c != '\'') {</span>
<span class="nc" id="L461">            unread_char(c);</span>
<span class="nc" id="L462">            unread_char('\'');</span>
<span class="nc" id="L463">            unread_char('\'');</span>
<span class="nc" id="L464">            return IonTokenConstsX.TOKEN_ERROR;</span>
        }
<span class="fc" id="L466">        return IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE;</span>
    }

    /** Expects optional whitespace then }} */
    protected final void skip_clob_close_punctuation() throws IOException {
<span class="fc" id="L471">        int c = skip_over_clob_whitespace();</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">        if (c == '}') {</span>
<span class="fc" id="L473">            c = read_char();</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (c == '}') {</span>
<span class="fc" id="L475">                return;</span>
            }
<span class="nc" id="L477">            unread_char(c);</span>
<span class="nc" id="L478">            c = '}';</span>
        }
<span class="fc" id="L480">        unread_char(c);</span>
<span class="nc" id="L481">        error(&quot;invalid closing puctuation for CLOB&quot;);</span>
<span class="nc" id="L482">    }</span>


    protected final void finish_token(SavePoint sp) throws IOException
    {
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">        if (_unfinished_token) {</span>
<span class="fc" id="L488">            int c = skip_to_end(sp);</span>
<span class="fc" id="L489">            unread_char(c);</span>
<span class="fc" id="L490">            _unfinished_token = false;</span>
        }
<span class="fc" id="L492">    }</span>

    private final int skip_to_end(SavePoint sp)  throws IOException
    {
        int c;

        // FIXME lots of inconsistency here!
        // Sometimes the token's first character is still on the stream,
        // sometimes it's already been consumed.

<span class="pc bpc" id="L502" title="2 of 17 branches missed.">        switch (_token) {</span>
        case IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC:
<span class="nc" id="L504">            c = skip_over_number(sp);</span>
<span class="nc" id="L505">            break;</span>
        case IonTokenConstsX.TOKEN_INT:
<span class="fc" id="L507">            c = skip_over_int(sp);</span>
<span class="fc" id="L508">            break;</span>
        case IonTokenConstsX.TOKEN_HEX:
<span class="fc" id="L510">            c = skipOverRadix(sp, Radix.HEX);</span>
<span class="fc" id="L511">            break;</span>
        case IonTokenConstsX.TOKEN_BINARY:
<span class="fc" id="L513">            c = skipOverRadix(sp, Radix.BINARY);</span>
<span class="fc" id="L514">            break;</span>
        case IonTokenConstsX.TOKEN_DECIMAL:
<span class="fc" id="L516">            c = skip_over_decimal(sp);</span>
<span class="fc" id="L517">            break;</span>
        case IonTokenConstsX.TOKEN_FLOAT:
<span class="fc" id="L519">            c = skip_over_float(sp);</span>
<span class="fc" id="L520">            break;</span>
        case IonTokenConstsX.TOKEN_TIMESTAMP:
<span class="fc" id="L522">            c = skip_over_timestamp(sp);</span>
<span class="fc" id="L523">            break;</span>
        case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
<span class="fc" id="L525">            c = skip_over_symbol_identifier(sp);</span>
<span class="fc" id="L526">            break;</span>
        case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
            // Initial single-quote has been consumed!
<span class="pc bpc" id="L529" title="2 of 4 branches missed.">            assert(!is_2_single_quotes_helper());</span>
<span class="fc" id="L530">            c = skip_single_quoted_string(sp);</span>
<span class="fc" id="L531">            break;</span>
        case IonTokenConstsX.TOKEN_SYMBOL_OPERATOR:
            // Initial operator char has NOT been consumed
<span class="fc" id="L534">            c = skip_over_symbol_operator(sp);</span>
<span class="fc" id="L535">            break;</span>
        case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="fc" id="L537">            skip_double_quoted_string_helper(); // FIXME Why no sp here?</span>
<span class="fc" id="L538">            c = skip_over_whitespace();</span>
<span class="fc" id="L539">            break;</span>
        case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="fc" id="L541">            skip_triple_quoted_string(sp);</span>
<span class="fc" id="L542">            c = skip_over_whitespace();</span>
<span class="fc" id="L543">            break;</span>

        case IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE:
            // works just like a pair of nested structs
            // since &quot;skip_over&quot; doesn't care about formal
            // syntax (like requiring field names);
<span class="fc" id="L549">            skip_over_blob(sp);</span>
<span class="fc" id="L550">            c = read_char();</span>
<span class="fc" id="L551">            break;</span>
        case IonTokenConstsX.TOKEN_OPEN_BRACE:
<span class="pc bpc" id="L553" title="2 of 4 branches missed.">            assert( sp == null ); // you can't save point a scanned struct (right now anyway)</span>
<span class="fc" id="L554">            skip_over_struct();</span>
<span class="fc" id="L555">            c = read_char();</span>
<span class="fc" id="L556">            break;</span>
        case IonTokenConstsX.TOKEN_OPEN_PAREN:
<span class="fc" id="L558">            skip_over_sexp(); // you can't save point a scanned sexp (right now anyway)</span>
<span class="fc" id="L559">            c = read_char();</span>
<span class="fc" id="L560">            break;</span>
        case IonTokenConstsX.TOKEN_OPEN_SQUARE:
<span class="fc" id="L562">            skip_over_list();  // you can't save point a scanned list (right now anyway)</span>
<span class="fc" id="L563">            c = read_char();</span>
<span class="fc" id="L564">            break;</span>
        case IonTokenConstsX.TOKEN_DOT:
        case IonTokenConstsX.TOKEN_COMMA:
        case IonTokenConstsX.TOKEN_COLON:
        case IonTokenConstsX.TOKEN_DOUBLE_COLON:
        case IonTokenConstsX.TOKEN_CLOSE_PAREN:
        case IonTokenConstsX.TOKEN_CLOSE_BRACE:
        case IonTokenConstsX.TOKEN_CLOSE_SQUARE:
        case IonTokenConstsX.TOKEN_CLOSE_DOUBLE_BRACE:
        case IonTokenConstsX.TOKEN_ERROR:
        case IonTokenConstsX.TOKEN_EOF:
        default:
<span class="nc" id="L576">            c = -1; // makes eclipse happy</span>
<span class="nc" id="L577">            error(&quot;token &quot;+IonTokenConstsX.getTokenName(_token)+</span>
                  &quot; unexpectedly encounterd as \&quot;unfinished\&quot;&quot;);
            break;
        }
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (IonTokenConstsX.isWhitespace(c)) {</span>
<span class="fc" id="L582">            c = skip_over_whitespace();</span>
        }
<span class="fc" id="L584">        _unfinished_token = false;</span>
<span class="fc" id="L585">        return c;</span>
    }

    public final long getStartingOffset() throws IOException
    {
        int c;
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if (_unfinished_token) {</span>
<span class="nc" id="L592">            c = skip_to_end(null);</span>
        }
        else {
<span class="fc" id="L595">            c = skip_over_whitespace();</span>
        }
<span class="fc" id="L597">        unread_char(c);</span>
<span class="fc" id="L598">        long pos = _stream.getPosition();</span>
<span class="fc" id="L599">        return pos;</span>
    }

    public final int nextToken() throws IOException
    {
<span class="fc" id="L604">        int t = -1;</span>
        int c, c2;

<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        if (_unfinished_token) {</span>
<span class="nc" id="L608">            c = skip_to_end(null);</span>
        }
        else {
<span class="fc" id="L611">            c = skip_over_whitespace();</span>
        }
<span class="fc" id="L613">        _unfinished_token = true;</span>

<span class="pc bpc" id="L615" title="1 of 19 branches missed.">        switch (c) {</span>
        case -1:
<span class="fc" id="L617">            return next_token_finish(IonTokenConstsX.TOKEN_EOF, true);</span>
        case '/':
<span class="fc" id="L619">            unread_char(c);</span>
<span class="fc" id="L620">            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</span>
        case ':':
<span class="fc" id="L622">            c2 = read_char();</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            if (c2 != ':') {</span>
<span class="fc" id="L624">                unread_char(c2);</span>
<span class="fc" id="L625">                return next_token_finish(IonTokenConstsX.TOKEN_COLON, true);</span>
            }
<span class="fc" id="L627">            return next_token_finish(IonTokenConstsX.TOKEN_DOUBLE_COLON, true);</span>
        case '{':
<span class="fc" id="L629">            c2 = read_char();</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">            if (c2 != '{') {</span>
<span class="fc" id="L631">                unread_char(c2);</span>
<span class="fc" id="L632">                return next_token_finish(IonTokenConstsX.TOKEN_OPEN_BRACE, true); // CAS: 9 nov 2009</span>
            }
<span class="fc" id="L634">            return next_token_finish(IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE, true);</span>
        case '}':
            // detection of double closing braces is done
            // in the parser in the blob and clob handling
            // state - it's otherwise ambiguous with closing
            // two structs together. see tryForDoubleBrace() below
<span class="fc" id="L640">            return next_token_finish(IonTokenConstsX.TOKEN_CLOSE_BRACE, false);</span>
        case '[':
<span class="fc" id="L642">            return next_token_finish(IonTokenConstsX.TOKEN_OPEN_SQUARE, true); // CAS: 9 nov 2009</span>
        case ']':
<span class="fc" id="L644">            return next_token_finish(IonTokenConstsX.TOKEN_CLOSE_SQUARE, false);</span>
        case '(':
<span class="fc" id="L646">            return next_token_finish(IonTokenConstsX.TOKEN_OPEN_PAREN, true); // CAS: 9 nov 2009</span>
        case ')':
<span class="fc" id="L648">            return next_token_finish(IonTokenConstsX.TOKEN_CLOSE_PAREN, false);</span>
        case ',':
<span class="fc" id="L650">            return next_token_finish(IonTokenConstsX.TOKEN_COMMA, false);</span>
        case '.':
<span class="fc" id="L652">            c2 = read_char();</span>
<span class="fc" id="L653">            unread_char(c2);</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            if (IonTokenConstsX.isValidExtendedSymbolCharacter(c2)) {</span>
<span class="nc" id="L655">                unread_char('.');</span>
<span class="nc" id="L656">                return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</span>
            }
<span class="fc" id="L658">            return next_token_finish(IonTokenConstsX.TOKEN_DOT, false);</span>
        case '\'':
<span class="fc bfc" id="L660" title="All 2 branches covered.">            if (is_2_single_quotes_helper()) {</span>
<span class="fc" id="L661">                return next_token_finish(IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE, true);</span>
            }
            // unread_char(c);
<span class="fc" id="L664">            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_QUOTED, true);</span>
        case '+':
<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (peek_inf_helper(c)) // this will consume the inf if it succeeds</span>
            {
<span class="fc" id="L668">                return next_token_finish(IonTokenConstsX.TOKEN_FLOAT_INF, false);</span>
            }
<span class="fc" id="L670">            unread_char(c);</span>
<span class="fc" id="L671">            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</span>
        case '#':
        case '&lt;': case '&gt;': case '*': case '=': case '^': case '&amp;': case '|':
        case '~': case ';': case '!': case '?': case '@': case '%': case '`':
<span class="fc" id="L675">            unread_char(c);</span>
<span class="fc" id="L676">            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</span>
        case '&quot;':
<span class="fc" id="L678">            return next_token_finish(IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE, true);</span>
        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
        case 's': case 't': case 'u': case 'v': case 'w': case 'x':
        case 'y': case 'z':
        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
        case 'Y': case 'Z':
        case '$': case '_':
<span class="fc" id="L690">            unread_char(c);</span>
<span class="fc" id="L691">            return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER, true);</span>
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
<span class="fc" id="L694">            t = scan_for_numeric_type(c);</span>
<span class="fc" id="L695">            unread_char(c);</span>
<span class="fc" id="L696">            return next_token_finish(t, true);</span>
        case '-':
            // see if we have a number or what might be an extended symbol
<span class="fc" id="L699">            c2 = read_char();</span>
<span class="fc" id="L700">            unread_char(c2);</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">            if (IonTokenConstsX.isDigit(c2)) {</span>
<span class="fc" id="L702">                t = scan_negative_for_numeric_type(c);</span>
<span class="fc" id="L703">                unread_char(c);</span>
<span class="fc" id="L704">                return next_token_finish(t, true);</span>
            }
<span class="fc bfc" id="L706" title="All 2 branches covered.">            else if (peek_inf_helper(c)) // this will consume the inf if it succeeds</span>
            {
<span class="fc" id="L708">                return next_token_finish(IonTokenConstsX.TOKEN_FLOAT_MINUS_INF, false);</span>
            }
            else {
<span class="fc" id="L711">                unread_char(c);</span>
<span class="fc" id="L712">                return next_token_finish(IonTokenConstsX.TOKEN_SYMBOL_OPERATOR, true);</span>
            }
        default:
<span class="nc" id="L715">            bad_token_start(c); // throws</span>
        }
<span class="nc" id="L717">        throw new IonException(&quot;invalid state: next token switch shouldn't exit&quot;);</span>
    }
    private final int next_token_finish(int token, boolean content_is_waiting) {
<span class="fc" id="L720">        _token = token;</span>
<span class="fc" id="L721">        _unfinished_token = content_is_waiting;</span>
<span class="fc" id="L722">        return _token;</span>
    }

    /**
     * Defines strategies to apply when comments are encountered.
     */
<span class="fc" id="L728">    private enum CommentStrategy</span>
    {
        /**
         * Skip over all of the comment's text.
         */
<span class="fc" id="L733">        IGNORE</span>
        {

            @Override
            boolean onComment(IonReaderTextRawTokensX tokenizer)
                throws IOException
            {
<span class="fc" id="L740">                int next = tokenizer.read_char();</span>
<span class="fc bfc" id="L741" title="All 3 branches covered.">                switch(next) {</span>
                case '/':
<span class="fc" id="L743">                    tokenizer.skip_single_line_comment();</span>
<span class="fc" id="L744">                    return true; // valid comment</span>
                case '*':
<span class="fc" id="L746">                    tokenizer.skip_block_comment();</span>
<span class="fc" id="L747">                    return true; // valid comment</span>
                default:
<span class="fc" id="L749">                    tokenizer.unread_char(next);</span>
<span class="fc" id="L750">                    return false; // invalid comment</span>
                }
            }

        },
        /**
         * If it's a valid comment, throw an error.
         */
<span class="fc" id="L758">        ERROR</span>
        {

            @Override
            boolean onComment(IonReaderTextRawTokensX tokenizer)
                throws IOException
            {
<span class="fc" id="L765">                int next = tokenizer.read_char();</span>
<span class="pc bpc" id="L766" title="1 of 4 branches missed.">                if (next == '/' || next == '*')</span>
                {
<span class="nc" id="L768">                    tokenizer.error(&quot;Illegal comment&quot;);</span>
                }
                else
                {
<span class="nc" id="L772">                    tokenizer.unread_char(next);</span>
                }
<span class="nc" id="L774">                return false; // invalid comment</span>
            }

        },
        /**
         * A '/' character has been found, so break the loop as it may be a valid blob character.
         */
<span class="fc" id="L781">        BREAK</span>
        {

            @Override
            boolean onComment(IonReaderTextRawTokensX tokenizer)
                throws IOException
            {
<span class="fc" id="L788">                return false;</span>
            }

        };

        /**
         * Called when positioned after the first '/'.
         * @return true if a valid comment was found, otherwise false
         * @throws IonReaderTextTokenException when the ERROR strategy encounters a comment
         */
        abstract boolean onComment(IonReaderTextRawTokensX tokenizer) throws IOException;
    }

    /**
     * Skip over any whitespace, ignoring any comments.
     * @return the next character in the stream
     * @throws IOException
     */
    private final int skip_over_whitespace() throws IOException
    {
<span class="fc" id="L808">        return skip_over_whitespace(CommentStrategy.IGNORE);</span>
    }

    /**
     * Skip over any whitespace, applying the given CommentStrategy to
     * any comments found.
     * @param commentStrategy the strategy to use upon encountering comments.
     * @return the next character in the stream
     * @throws IOException
     */
    private final int skip_over_whitespace(CommentStrategy commentStrategy) throws IOException
    {
<span class="fc" id="L820">        skip_whitespace(commentStrategy);</span>
<span class="fc" id="L821">        return read_char();</span>
    }

    /**
     * The type of lob is not yet known. Break the loop on encountering
     * a / character and defer to the blob validation.
     * @return the next character in the stream
     * @throws IOException
     */
    private final int skip_over_lob_whitespace() throws IOException
    {
<span class="fc" id="L832">        return skip_over_blob_whitespace();</span>
    }

    /**
     * Skip over whitespace, but not the / character, as it's a valid
     * Base64 character.
     * @return the next character in the stream
     * @throws IOException
     */
    private final int skip_over_blob_whitespace() throws IOException
    {
<span class="fc" id="L843">        return skip_over_whitespace(CommentStrategy.BREAK);</span>
    }

    /**
     * Skip over the whitespace after the clob string and before the closing
     * braces. Throw if a comment is encountered.
     * @return the next character in the stream
     * @throws IOException
     */
    private final int skip_over_clob_whitespace() throws IOException
    {
<span class="fc" id="L854">        return skip_over_whitespace(CommentStrategy.ERROR);</span>
    }

    /**
     * Skips whitespace and comments and finishes at the starting position
     * of the next token.
     * @return true if whitespace or comments were encountered
     * @throws IOException
     */
    protected final boolean skip_whitespace() throws IOException
    {
<span class="fc" id="L865">        return skip_whitespace(CommentStrategy.IGNORE);</span>
    }

    /**
     * Skips whitespace and applies the given CommentStrategy to any comments
     * found. Finishes at the starting position of the next token.
     * @param commentStrategy
     * @return true if whitespace was skipped and/or comments ignored
     * @throws IOException
     */
    private final boolean skip_whitespace(CommentStrategy commentStrategy) throws IOException
    {
<span class="fc" id="L877">        boolean any_whitespace = false;</span>
        int c;

        loop: for (;;) {
<span class="fc" id="L881">            c = read_char();</span>
<span class="fc bfc" id="L882" title="All 4 branches covered.">            switch (c) {</span>
            case -1:
<span class="fc" id="L884">                break loop;</span>
            case ' ':
            case '\t':
            // new line normalization and counting is handled in read_char
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<span class="fc" id="L894">                any_whitespace = true;</span>
<span class="fc" id="L895">                break;</span>
            case '/':
<span class="fc bfc" id="L897" title="All 2 branches covered.">                if (!commentStrategy.onComment(this))</span>
                {
<span class="fc" id="L899">                    break loop;</span>
                }
<span class="fc" id="L901">                any_whitespace = true;</span>
<span class="fc" id="L902">                break;</span>
            default:
<span class="fc" id="L904">                break loop;</span>
            }
        }
<span class="fc" id="L907">        unread_char(c);</span>
<span class="fc" id="L908">        return any_whitespace;</span>
    }

    private final void skip_single_line_comment() throws IOException
    {
        for (;;) {
<span class="fc" id="L914">            int c = read_char();</span>
<span class="fc bfc" id="L915" title="All 3 branches covered.">            switch (c) {</span>
            // new line normalization and counting is handled in read_char
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<span class="fc" id="L923">                return;</span>
            case -1:
<span class="fc" id="L925">                return;</span>
            default:
                break; // and read another character
            }
<span class="fc" id="L929">        }</span>
    }

    private final void skip_block_comment() throws IOException
    {
        int c;
        for (;;) {
<span class="fc" id="L936">            c = this.read_char();</span>
<span class="pc bpc" id="L937" title="1 of 3 branches missed.">            switch (c) {</span>
                case '*':
                    // read back to back '*'s until you hit a '/' and terminate the comment
                    // or you see a non-'*'; in which case you go back to the outer loop.
                    // this just avoids the read-unread pattern on every '*' in a line of '*'
                    // commonly found at the top and bottom of block comments
                    for (;;) {
<span class="fc" id="L944">                        c = this.read_char();</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">                        if (c == '/') return;</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">                        if (c != '*') break;</span>
                    }
                    break;
                case -1:
<span class="nc" id="L950">                    bad_token_start(c);</span>
                default:
<span class="fc" id="L952">                    break;</span>
            }
        }
    }

    /**
     * this peeks ahead to see if the next two characters
     * are single quotes. this would finish off a triple
     * quote when the first quote has been read.
     * if it succeeds it &quot;consumes&quot; the two quotes
     * it reads.
     * if it fails it unreads
     * @return true if the next two characters are single quotes
     * @throws IOException
     */
    private final boolean is_2_single_quotes_helper() throws IOException
    {
<span class="fc" id="L969">        int c = read_char();</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">        if (c != '\'') {</span>
<span class="fc" id="L971">            unread_char(c);</span>
<span class="fc" id="L972">            return false;</span>
        }
<span class="fc" id="L974">        c = read_char();</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">        if (c != '\'') {</span>
<span class="fc" id="L976">            unread_char(c);</span>
<span class="fc" id="L977">            unread_char('\'');</span>
<span class="fc" id="L978">            return false;</span>
        }
<span class="fc" id="L980">        return true;</span>
    }

    private final boolean peek_inf_helper(int c) throws IOException
    {
<span class="fc bfc" id="L985" title="All 4 branches covered.">        if (c != '+' &amp;&amp; c != '-') return false;</span>
<span class="fc" id="L986">        c = read_char();</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if (c == 'i') {</span>
<span class="fc" id="L988">            c = read_char();</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">            if (c == 'n') {</span>
<span class="fc" id="L990">                c = read_char();</span>
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">                if (c == 'f') {</span>
<span class="fc" id="L992">                    c = read_char();</span>
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                    if (is_value_terminating_character(c)) {</span>
<span class="fc" id="L994">                        unread_char(c);</span>
<span class="fc" id="L995">                        return true;</span>
                    }
<span class="nc" id="L997">                    unread_char(c);</span>
<span class="nc" id="L998">                    c = 'f';</span>
                }
<span class="nc" id="L1000">                unread_char(c);</span>
<span class="nc" id="L1001">                c = 'n';</span>
            }
<span class="nc" id="L1003">            unread_char(c);</span>
<span class="nc" id="L1004">            c = 'i';</span>
        }
<span class="fc" id="L1006">        unread_char(c);</span>
<span class="fc" id="L1007">        return false;</span>
    }

    /**
     * we encountered a character that starts a number,
     * a digit or a dash (minus).  Now we'll scan a little
     * ways ahead to spot some of the numeric types.
     *
     * this only looks far enough (2 or 6 chars) to identify
     * hex and timestamps
     * it might encounter a decimal or a 'd' or an 'e' and
     * decide this token is float or decimal (or int if we
     * hit a non-numeric char) but it may return TOKEN_UNKNOWN_NUMERIC;
     *
     * if will unread everything it's read, and the character
     * passed in as the first digit encountered
     *
     * @param c first char of number read by caller
     * @return numeric token type
     * @throws IOException
     */
    private final int scan_for_numeric_type(int c1) throws IOException
    {
<span class="fc" id="L1030">        int   t = IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC;</span>
<span class="fc" id="L1031">        int[] read_chars = new int[6];</span>
<span class="fc" id="L1032">        int   read_char_count = 0;</span>
        int   c;

<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">        if (!IonTokenConstsX.isDigit(c1)) {</span>
<span class="nc" id="L1036">            error(String.format(&quot;Expected digit, got U+%04X&quot;, c1));</span>
        }

        // the caller needs to unread this if they want to: read_chars[read_char_count++] = c1;

<span class="fc" id="L1041">        c = read_char();</span>
<span class="fc" id="L1042">        read_chars[read_char_count++] = c;</span>

<span class="fc bfc" id="L1044" title="All 2 branches covered.">        if (c1 == '0') {</span>
            // check for hex
<span class="fc bfc" id="L1046" title="All 6 branches covered.">            switch(c) {</span>
            case 'x':
            case 'X':
<span class="fc" id="L1049">                t = IonTokenConstsX.TOKEN_HEX;</span>
<span class="fc" id="L1050">                break;</span>
            case 'd':
            case 'D':
<span class="fc" id="L1053">                t = IonTokenConstsX.TOKEN_DECIMAL;</span>
<span class="fc" id="L1054">                break;</span>
            case 'e':
            case 'E':
<span class="fc" id="L1057">                t = IonTokenConstsX.TOKEN_FLOAT;</span>
<span class="fc" id="L1058">                break;</span>
            case 'b':
            case 'B':
<span class="fc" id="L1061">                t = IonTokenConstsX.TOKEN_BINARY;</span>
<span class="fc" id="L1062">                break;</span>
            case '.':
                // the decimal might have an 'e' somewhere down the line so we
                // don't really know the type here
<span class="fc" id="L1066">                break;</span>
            default:
<span class="fc bfc" id="L1068" title="All 2 branches covered.">                if (is_value_terminating_character(c)) {</span>
<span class="fc" id="L1069">                    t = IonTokenConstsX.TOKEN_INT;</span>
                }
                break;
            }
        }
<span class="fc bfc" id="L1074" title="All 2 branches covered.">        if (t == IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC) { // oh for goto :(</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">            if (IonTokenConstsX.isDigit(c)) { // 2nd digit</span>
                // it might be a timestamp if we have 4 digits, a dash,
                // and a digit
<span class="fc" id="L1078">                c = read_char();</span>
<span class="fc" id="L1079">                read_chars[read_char_count++] = c;</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">                if (IonTokenConstsX.isDigit(c)) { // digit 3</span>
<span class="fc" id="L1081">                    c = read_char();</span>
<span class="fc" id="L1082">                    read_chars[read_char_count++] = c;</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                    if (IonTokenConstsX.isDigit(c)) {</span>
                        // last digit of possible year
<span class="fc" id="L1085">                        c = read_char();</span>
<span class="fc" id="L1086">                        read_chars[read_char_count++] = c;</span>
<span class="fc bfc" id="L1087" title="All 4 branches covered.">                        if (c == '-' || c =='T') {</span>
                            // we have dddd- or ddddT looks like a timestamp
                            // (or invalid input)
<span class="fc" id="L1090">                            t = IonTokenConstsX.TOKEN_TIMESTAMP;</span>
                        }
                    }
                }
            }
        }

        // unread whatever we read, including the passed in char
        do {
<span class="fc" id="L1099">            read_char_count--;</span>
<span class="fc" id="L1100">            c = read_chars[read_char_count];</span>
<span class="fc" id="L1101">            unread_char(c);</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        } while (read_char_count &gt; 0);</span>

<span class="fc" id="L1104">        return t;</span>
    }

    private final boolean is_value_terminating_character(int c)
        throws IOException
    {
        boolean isTerminator;

<span class="fc bfc" id="L1112" title="All 3 branches covered.">        switch (c) {</span>
            case '/':
            // this is terminating only if it starts a comment of some sort
<span class="fc" id="L1115">            c = read_char();</span>
<span class="fc" id="L1116">            unread_char(c);  // we never &quot;keep&quot; this character</span>
<span class="fc bfc" id="L1117" title="All 4 branches covered.">            isTerminator = (c == '/' || c == '*');</span>
<span class="fc" id="L1118">            break;</span>
        // new line normalization and counting is handled in read_char
        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<span class="fc" id="L1126">            isTerminator = true;</span>
<span class="fc" id="L1127">            break;</span>
        default:
<span class="fc" id="L1129">            isTerminator = IonTextUtils.isNumericStop(c);</span>
            break;
        }

<span class="fc" id="L1133">        return isTerminator;</span>
    }

    /**
     * variant of scan_numeric_type where the passed in
     * start character was preceded by a minus sign.
     * this will also unread the minus sign.
     *
     * @param c first char of number read by caller
     * @return numeric token type
     * @throws IOException
     */
    private final int scan_negative_for_numeric_type(int c) throws IOException
    {
<span class="pc bpc" id="L1147" title="2 of 4 branches missed.">        assert(c == '-');</span>
<span class="fc" id="L1148">        c = read_char();</span>
<span class="fc" id="L1149">        int t = scan_for_numeric_type(c);</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        if (t == IonTokenConstsX.TOKEN_TIMESTAMP) {</span>
<span class="nc" id="L1151">            bad_token(c);</span>
        }
<span class="fc" id="L1153">        unread_char(c); // and the caller need to unread the '-'</span>
<span class="fc" id="L1154">        return t;</span>
    }

    // TODO: need new test cases since stepping out over values
    //       (or next-ing over them) is quite different from
    //       fully parsing them.  It is generally more lenient
    //       and that may not be best.

    /**
     * this is used to load a previously marked set of bytes
     * into the StringBuilder without escaping.  It expects
     * the caller to have set a save point so that the EOF
     * will stop us at the right time.
     * This does handle UTF8 decoding and surrogate encoding
     * as the bytes are transfered.
     */
    protected void load_raw_characters(StringBuilder sb) throws IOException
    {
<span class="nc" id="L1172">        int c = read_char();</span>
        for (;;) {
<span class="nc" id="L1174">            c = read_char();</span>
<span class="nc bnc" id="L1175" title="All 3 branches missed.">            switch (c) {</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
            // WAS: case IonTokenConstsX.ESCAPED_NEWLINE_SEQUENCE:
<span class="nc" id="L1180">                continue;</span>
            case -1:
<span class="nc" id="L1182">                return;</span>
            default:
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                if (!IonTokenConstsX.is7bitValue(c)) {</span>
<span class="nc" id="L1185">                    c = read_large_char_sequence(c);</span>
                }
            }
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            if (IonUTF8.needsSurrogateEncoding(c)) {</span>
<span class="nc" id="L1189">                sb.append(IonUTF8.highSurrogate(c));</span>
<span class="nc" id="L1190">                c = IonUTF8.lowSurrogate(c);</span>
            }
<span class="nc" id="L1192">            sb.append((char)c);</span>
        }
    }

    protected void skip_over_struct() throws IOException
    {
<span class="fc" id="L1198">        skip_over_container('}');</span>
<span class="fc" id="L1199">    }</span>
    protected void skip_over_list() throws IOException
    {
<span class="fc" id="L1202">        skip_over_container(']');</span>
<span class="fc" id="L1203">    }</span>
    protected void skip_over_sexp() throws IOException
    {
<span class="fc" id="L1206">        skip_over_container(')');</span>
<span class="fc" id="L1207">    }</span>
    private void skip_over_container(int terminator) throws IOException
    {
<span class="pc bpc" id="L1210" title="2 of 8 branches missed.">        assert( terminator == '}' || terminator == ']' || terminator == ')' );</span>
        int c;

        for (;;) {
<span class="fc" id="L1214">            c = skip_over_whitespace();</span>
<span class="pc bpc" id="L1215" title="1 of 8 branches missed.">            switch (c) {</span>
            case -1:
<span class="nc" id="L1217">                unexpected_eof();</span>
            case '}':
            case ']':
            case ')':
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">                if (c == terminator) { // no point is checking this on every char</span>
<span class="fc" id="L1222">                    return;</span>
                }
                break;
            case '&quot;':
<span class="fc" id="L1226">                skip_double_quoted_string_helper();</span>
<span class="fc" id="L1227">                break;</span>
            case '\'':
<span class="fc bfc" id="L1229" title="All 2 branches covered.">                if (is_2_single_quotes_helper()) {</span>
<span class="fc" id="L1230">                    skip_triple_quoted_string(null);</span>
                }
                else {
<span class="fc" id="L1233">                    c = skip_single_quoted_string(null);</span>
<span class="fc" id="L1234">                    unread_char(c);</span>
                }
<span class="fc" id="L1236">                break;</span>
            case '(':
<span class="fc" id="L1238">                skip_over_container(')');</span>
<span class="fc" id="L1239">                break;</span>
            case '[':
<span class="fc" id="L1241">                skip_over_container(']');</span>
<span class="fc" id="L1242">                break;</span>
            case '{':
                // this consumes lobs as well since the double
                // braces count correctly and the contents
                // of either clobs or blobs will be just content
<span class="fc" id="L1247">                c = read_char();</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">                if (c == '{') {</span>
                    // 2nd '{' - it's a lob of some sort - let's find out what sort
<span class="fc" id="L1250">                    c = skip_over_lob_whitespace();</span>

                    int lobType;
<span class="fc bfc" id="L1253" title="All 2 branches covered.">                    if (c == '&quot;') {</span>
                        // clob, double quoted
<span class="fc" id="L1255">                        lobType = IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE;</span>
                    }
<span class="fc bfc" id="L1257" title="All 2 branches covered.">                    else if (c == '\'') {</span>
                        // clob, triple quoted - or error
<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">                        if (!is_2_single_quotes_helper()) {</span>
<span class="nc" id="L1260">                            error(&quot;invalid single quote in lob content&quot;);</span>
                        }
<span class="fc" id="L1262">                        lobType = IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE;</span>
                    }
                    else {
                        // blob
<span class="fc" id="L1266">                        unread_char(c);</span>
<span class="fc" id="L1267">                        lobType = IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE;</span>
                    }

<span class="fc" id="L1270">                    skip_over_lob(lobType, null);</span>
<span class="fc" id="L1271">                }</span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">                else if (c == '}') {</span>
                    // do nothing, we just opened and closed an empty struct
                    // move on, there's nothing to see here ...
                }
                else {
<span class="fc" id="L1277">                    unread_char(c);</span>
<span class="fc" id="L1278">                    skip_over_container('}');</span>
                }
<span class="fc" id="L1280">                break;</span>
            default:
<span class="fc" id="L1282">                break;</span>
            }
        }
    }

    private int skip_over_number(SavePoint sp) throws IOException
    {
<span class="fc" id="L1289">        int c = read_char();</span>

        // first consume any leading 0 to get it out of the way
<span class="fc bfc" id="L1292" title="All 2 branches covered.">        if (c == '-') {</span>
<span class="fc" id="L1293">            c = read_char();</span>
        }
        // could be a long int, a decimal, a float
        // it cannot be a hex or a valid timestamp
        // so scan digits - if decimal can more digits
        // if d or e eat possible sign
        // scan to end of digits
<span class="fc" id="L1300">        c = skip_over_digits(c);</span>
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">        if (c == '.') {</span>
<span class="nc" id="L1302">            c = read_char();</span>
<span class="nc" id="L1303">            c = skip_over_digits(c);</span>
        }
<span class="pc bpc" id="L1305" title="1 of 8 branches missed.">        if (c == 'd' || c == 'D' || c == 'e' || c == 'E') {</span>
<span class="fc" id="L1306">            c = read_char();</span>
<span class="fc bfc" id="L1307" title="All 4 branches covered.">            if (c == '-' || c == '+') {</span>
<span class="fc" id="L1308">                c = read_char();</span>
            }
<span class="fc" id="L1310">            c = skip_over_digits(c);</span>
        }
<span class="pc bpc" id="L1312" title="1 of 2 branches missed.">        if (!is_value_terminating_character(c)) {</span>
<span class="nc" id="L1313">            bad_token(c);</span>
        }
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">        if (sp != null) {</span>
<span class="nc" id="L1316">            sp.markEnd(-1);</span>
        }
<span class="fc" id="L1318">        return c;</span>
    }
    private int skip_over_int(SavePoint sp) throws IOException
    {
<span class="fc" id="L1322">        int c = read_char();</span>
<span class="fc bfc" id="L1323" title="All 2 branches covered.">        if (c == '-') {</span>
<span class="fc" id="L1324">            c = read_char();</span>
        }
<span class="fc" id="L1326">        c = skip_over_digits(c);</span>
<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">        if (!is_value_terminating_character(c)) {</span>
<span class="nc" id="L1328">            bad_token(c);</span>
        }
<span class="pc bpc" id="L1330" title="1 of 2 branches missed.">        if (sp != null) {</span>
<span class="nc" id="L1331">            sp.markEnd(-1);</span>
        }
<span class="fc" id="L1333">        return c;</span>
    }
    private int skip_over_digits(int c) throws IOException
    {
<span class="fc bfc" id="L1337" title="All 2 branches covered.">        while (IonTokenConstsX.isDigit(c)) {</span>
<span class="fc" id="L1338">            c = read_char();</span>
        }
<span class="fc" id="L1340">        return c;</span>
    }

    private int skipOverRadix(SavePoint sp, Radix radix) throws IOException
    {
        int c;

<span class="fc" id="L1347">        c = read_char();</span>
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        if (c == '-') {</span>
<span class="fc" id="L1349">            c = read_char();</span>
        }
<span class="pc bpc" id="L1351" title="2 of 4 branches missed.">        assert(c == '0');</span>
<span class="fc" id="L1352">        c = read_char();</span>
<span class="fc" id="L1353">        radix.assertPrefix(c);</span>

<span class="fc" id="L1355">        c = readNumeric(NULL_APPENDABLE, radix);</span>

<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">        if (!is_value_terminating_character(c)) {</span>
<span class="nc" id="L1358">            bad_token(c);</span>
        }
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">        if (sp != null) {</span>
<span class="nc" id="L1361">            sp.markEnd(-1);</span>
        }

<span class="fc" id="L1364">        return c;</span>
    }

    private int skip_over_decimal(SavePoint sp) throws IOException
    {
<span class="fc" id="L1369">        int c = skip_over_number(sp);</span>
<span class="fc" id="L1370">        return c;</span>
    }
    private int skip_over_float(SavePoint sp) throws IOException
    {
<span class="fc" id="L1374">        int c = skip_over_number(sp);</span>
<span class="fc" id="L1375">        return c;</span>
    }
    private int skip_over_timestamp(SavePoint sp) throws IOException
    {
        // we know we have dddd- or ddddT we don't know what follows
        // is should be dddd-mm
<span class="fc" id="L1381">        int c = skip_timestamp_past_digits(4);</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        if (c == 'T') {</span>
            // yyyyT
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">            if (sp != null) {</span>
<span class="nc" id="L1385">                sp.markEnd(0);</span>
            }
<span class="fc" id="L1387">            return skip_over_whitespace(); // prefetch</span>
        }
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">        if (c != '-') {</span>
<span class="nc" id="L1390">            error(&quot;invalid timestamp encountered&quot;);</span>
        }
        // yyyy-mmT
        // yyyy-mm-ddT
        // yyyy-mm-ddT+hh:mm
        // yyyy-mm-ddThh:mm+hh:mm
        // yyyy-mm-ddThh:mm:ss+hh:mm
        // yyyy-mm-ddThh:mm:ss.dddd+hh:mm
        // yyyy-mm-ddThh:mmZ
        // yyyy-mm-ddThh:mm:ssZ
        // yyyy-mm-ddThh:mm:ss.ddddZ
<span class="fc" id="L1401">        c = skip_timestamp_past_digits(2);</span>
<span class="fc bfc" id="L1402" title="All 2 branches covered.">        if (c == 'T') {</span>
            // yyyy-mmT
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">            if (sp != null) {</span>
<span class="nc" id="L1405">                sp.markEnd(0);</span>
            }
<span class="fc" id="L1407">            return skip_over_whitespace(); // prefetch</span>
        }
<span class="fc" id="L1409">        skip_timestamp_validate(c, '-');</span>
<span class="fc" id="L1410">        c = skip_timestamp_past_digits(2);</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">        if ( c != 'T' ) {</span>
<span class="fc" id="L1412">            return skip_timestamp_finish(c, sp);</span>
        }
<span class="fc" id="L1414">        c = read_char();</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        if (!IonTokenConstsX.isDigit(c)) {</span>
            // yyyy-mm-ddT
<span class="fc" id="L1417">            return skip_timestamp_finish(skip_optional_timestamp_offset(c), sp);</span>
        }
        // one hour digit already read above
<span class="fc" id="L1420">        c = skip_timestamp_past_digits(1);</span>
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">        if (c != ':') {</span>
<span class="nc" id="L1422">            bad_token(c);</span>
        }
<span class="fc" id="L1424">        c = skip_timestamp_past_digits(2);</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">        if (c != ':') {</span>
            // yyyy-mm-ddThh:mm?
<span class="fc" id="L1427">            return skip_timestamp_offset_or_z(c, sp);</span>
        }
<span class="fc" id="L1429">        c = skip_timestamp_past_digits(2);</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        if (c != '.') {</span>
            // yyyy-mm-ddThh:mm:ss?
<span class="fc" id="L1432">            return skip_timestamp_offset_or_z(c, sp);</span>
        }
<span class="fc" id="L1434">        c = read_char();</span>
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">        if (IonTokenConstsX.isDigit(c)) {</span>
<span class="fc" id="L1436">            c = skip_over_digits(c);</span>
        }
        // yyyy-mm-ddThh:mm:ss.ddd?

<span class="fc" id="L1440">        return skip_timestamp_offset_or_z(c, sp);</span>
    }

    private int skip_timestamp_finish(int c, SavePoint sp) throws IOException {
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">        if (!is_value_terminating_character(c)) {</span>
<span class="nc" id="L1445">            bad_token(c);</span>
        }
<span class="pc bpc" id="L1447" title="1 of 2 branches missed.">        if (sp != null) {</span>
<span class="nc" id="L1448">            sp.markEnd(-1);</span>
        }
<span class="fc" id="L1450">        return c;</span>
    }
    private int skip_optional_timestamp_offset(int c) throws IOException
    {
<span class="pc bpc" id="L1454" title="2 of 4 branches missed.">        if (c == '-' || c == '+') {</span>
<span class="nc" id="L1455">            c = skip_timestamp_past_digits(2);</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">            if (c != ':') {</span>
<span class="nc" id="L1457">                bad_token( c );</span>
            }
<span class="nc" id="L1459">            c = skip_timestamp_past_digits(2);</span>
        }
<span class="fc" id="L1461">        return c;</span>
    }
    private int skip_timestamp_offset_or_z(int c, SavePoint sp) throws IOException
    {
<span class="fc bfc" id="L1465" title="All 4 branches covered.">        if (c == '-' || c == '+') {</span>
<span class="fc" id="L1466">            c = skip_timestamp_past_digits(2);</span>
<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">            if (c != ':') {</span>
<span class="nc" id="L1468">                bad_token( c );</span>
            }
<span class="fc" id="L1470">            c = skip_timestamp_past_digits(2);</span>
        }
<span class="pc bpc" id="L1472" title="3 of 4 branches missed.">        else if (c == 'Z' || c == 'z') {</span>
<span class="fc" id="L1473">            c = read_char();</span>
        } else {
<span class="nc" id="L1475">            bad_token(c);</span>
        }
<span class="fc" id="L1477">        return skip_timestamp_finish(c, sp);</span>
    }
    private final void skip_timestamp_validate(int c, int expected) {
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">        if (c != expected) {</span>
<span class="nc" id="L1481">            error(&quot;invalid character '&quot;+(char)c+</span>
                  &quot;' encountered in timestamp (when '&quot;+(char)expected+
                  &quot;' was expected&quot;);
        }
<span class="fc" id="L1485">    }</span>

    /**
     * Helper method for skipping embedded digits inside a timestamp value.
     * This overload skips exactly the number indicated, and errors if a
     * non-digit is encountered.
     */
    private final int skip_timestamp_past_digits(int len) throws IOException
    {
        // special case of the other overload
<span class="fc" id="L1495">        return skip_timestamp_past_digits(len, len);</span>
    }

    /**
     * Helper method for skipping embedded digits inside a timestamp value
     * This overload skips at least min and at most max digits, and errors
     * if a non-digit is encountered in the first min characters read
     */
    private final int skip_timestamp_past_digits(int min, int max)
        throws IOException
    {
        int c;

        // scan the first min characters insuring they're digits
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        while (min &gt; 0) {</span>
<span class="fc" id="L1510">            c = read_char();</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">            if (!IonTokenConstsX.isDigit(c)) {</span>
<span class="nc" id="L1512">                error(&quot;invalid character '&quot;+(char)c+&quot;' encountered in timestamp&quot;);</span>
            }
<span class="fc" id="L1514">            --min;</span>
<span class="fc" id="L1515">            --max;</span>
        }
        // stop at the first non digit between min and max
<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">        while (max &gt; 0) {</span>
<span class="nc" id="L1519">            c = read_char();</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">            if (!IonTokenConstsX.isDigit(c)) {</span>
<span class="nc" id="L1521">                return c;</span>
            }
<span class="nc" id="L1523">            --max;</span>
        }
        // max characters reached; stop
<span class="fc" id="L1526">        return read_char();</span>
    }
    protected IonType load_number(StringBuilder sb) throws IOException
    {
<span class="fc" id="L1530">        boolean has_sign = false;</span>
        int     t, c;

        // this reads int, float, decimal and timestamp strings
        // anything staring with a +, a - or a digit
        //case '0': case '1': case '2': case '3': case '4':
        //case '5': case '6': case '7': case '8': case '9':
        //case '-': case '+':

        //start_pos = _stream.getPosition();
<span class="fc" id="L1540">        c = read_char();</span>
<span class="pc bpc" id="L1541" title="1 of 4 branches missed.">        has_sign = ((c == '-') || (c == '+'));</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">        if (has_sign) {</span>
            // if there is a sign character, we just consume it
            // here and get whatever is next in line
<span class="fc" id="L1545">            sb.append((char)c);</span>
<span class="fc" id="L1546">            c = read_char();</span>
        }

        // first leading digit - to look for hex and
        // to make sure that there is at least 1 digit (or
        // this isn't really a number
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">        if (!IonTokenConstsX.isDigit(c)) {</span>
            // if it's not a digit, this isn't a number
            // the only non-digit it could have been was a
            // sign character, and we'll have read past that
            // by now
            // TODO this will be a confusing error message,
            // but I can't figure out when it will be reached.
<span class="nc" id="L1559">            bad_token(c);</span>
        }

        // the first digit is a special case
<span class="fc bfc" id="L1563" title="All 2 branches covered.">        boolean starts_with_zero = (c == '0');</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">        if (starts_with_zero) {</span>
            // if it's a leading 0 check for a hex value
<span class="fc" id="L1566">            int c2 = read_char();</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">            if (Radix.HEX.isPrefix(c2)) {</span>
<span class="fc" id="L1568">                sb.append((char)c);</span>
<span class="fc" id="L1569">                c = loadRadixValue(sb, has_sign, c2, Radix.HEX);</span>
<span class="fc" id="L1570">                return load_finish_number(sb, c, IonTokenConstsX.TOKEN_HEX);</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">            } else if (Radix.BINARY.isPrefix(c2)) {</span>
<span class="fc" id="L1572">                sb.append((char) c);</span>
<span class="fc" id="L1573">                c = loadRadixValue(sb, has_sign, c2, Radix.BINARY);</span>
<span class="fc" id="L1574">                return load_finish_number(sb, c, IonTokenConstsX.TOKEN_BINARY);</span>
            }
            // not a next value, back up and try again
<span class="fc" id="L1577">            unread_char(c2);</span>
        }

        // remaining (after the first, c is the first) leading digits
<span class="fc" id="L1581">        c = load_digits(sb, c);</span>

<span class="fc bfc" id="L1583" title="All 4 branches covered.">        if (c == '-' || c == 'T') {</span>
            // this better be a timestamp and it starts with a 4 digit
            // year followed by a dash and no leading sign
<span class="pc bpc" id="L1586" title="1 of 2 branches missed.">            if (has_sign) {</span>
<span class="nc" id="L1587">                error(&quot;Numeric value followed by invalid character: &quot;</span>
                      + sb + (char)c);
            }
<span class="fc" id="L1590">            int len = sb.length();</span>
<span class="fc bfc" id="L1591" title="All 2 branches covered.">            if (len != 4) {</span>
<span class="nc" id="L1592">                error(&quot;Numeric value followed by invalid character: &quot;</span>
                      + sb + (char)c);
            }
<span class="fc" id="L1595">            IonType tt = load_timestamp(sb, c);</span>
<span class="fc" id="L1596">            return tt;</span>
        }

<span class="fc bfc" id="L1599" title="All 2 branches covered.">        if (starts_with_zero) {</span>
            // Ion doesn't allow leading zeros, so make sure our buffer only
            // has one character.
<span class="fc" id="L1602">            int len = sb.length();</span>
<span class="fc bfc" id="L1603" title="All 2 branches covered.">            if (has_sign) {</span>
<span class="fc" id="L1604">                len--; // we don't count the sign</span>
            }
<span class="fc bfc" id="L1606" title="All 2 branches covered.">            if (len != 1) {</span>
<span class="nc" id="L1607">                error(&quot;Invalid leading zero in number: &quot; + sb);</span>
            }
        }

<span class="fc bfc" id="L1611" title="All 2 branches covered.">        if (c == '.') {</span>
            // so if it's a float of some sort
            // mark it as at least a DECIMAL
            // and read the &quot;fraction&quot; digits
<span class="fc" id="L1615">            sb.append((char)c);</span>
<span class="fc" id="L1616">            c = read_char();</span>
<span class="fc" id="L1617">            c = load_digits(sb, c);</span>
<span class="fc" id="L1618">            t = IonTokenConstsX.TOKEN_DECIMAL;</span>
        }
        else {
<span class="fc" id="L1621">            t = IonTokenConstsX.TOKEN_INT;</span>
        }

        // see if we have an exponential as in 2d+3
<span class="fc bfc" id="L1625" title="All 4 branches covered.">        if (c == 'e' || c == 'E') {</span>
<span class="fc" id="L1626">            t = IonTokenConstsX.TOKEN_FLOAT;</span>
<span class="fc" id="L1627">            sb.append((char)c);</span>
<span class="fc" id="L1628">            c = load_exponent(sb);  // the unused lookahead char</span>
        }
<span class="fc bfc" id="L1630" title="All 4 branches covered.">        else if (c == 'd' || c == 'D') {</span>
<span class="fc" id="L1631">            t = IonTokenConstsX.TOKEN_DECIMAL;</span>
<span class="fc" id="L1632">            sb.append((char)c);</span>
<span class="fc" id="L1633">            c = load_exponent(sb);</span>
        }
<span class="fc" id="L1635">        return load_finish_number(sb, c, t);</span>
    }

    private final IonType load_finish_number(CharSequence numericText, int c,
                                             int token)
    throws IOException
    {
        // all forms of numeric need to stop someplace rational
<span class="fc bfc" id="L1643" title="All 2 branches covered.">        if (! is_value_terminating_character(c)) {</span>
<span class="nc" id="L1644">            error(&quot;Numeric value followed by invalid character: &quot;</span>
                  + numericText + (char)c);
        }

        // we read off the end of the number, so put back
        // what we don't want, but what ever we have is an int
<span class="fc" id="L1650">        unread_char(c);</span>
<span class="fc" id="L1651">        IonType it = IonTokenConstsX.ion_type_of_scalar(token);</span>
<span class="fc" id="L1652">        return it;</span>
    }
    // this returns the lookahead character it didn't use so the caller
    // can unread it
    private final int load_exponent(StringBuilder sb) throws IOException
    {
<span class="fc" id="L1658">        int c = read_char();</span>
<span class="fc bfc" id="L1659" title="All 4 branches covered.">        if (c == '-' || c == '+') {</span>
<span class="fc" id="L1660">            sb.append((char)c);</span>
<span class="fc" id="L1661">            c = read_char();</span>
        }
<span class="fc" id="L1663">        c = load_digits(sb, c);</span>

<span class="fc bfc" id="L1665" title="All 2 branches covered.">        if (c == '.') {</span>
<span class="fc" id="L1666">            sb.append((char)c);</span>
<span class="fc" id="L1667">            c = read_char();</span>
<span class="fc" id="L1668">            c = load_digits(sb, c);</span>
        }
<span class="fc" id="L1670">        return c;</span>
    }

    /**
     * Accumulates digits into the buffer, starting with the given character.
     *
     * @return the first non-digit character on the input. Could be the given
     *  character if its not a digit.
     *
     * @see IonTokenConstsX#isDigit(int)
     */
    private final int load_digits(StringBuilder sb, int c) throws IOException
    {
<span class="fc bfc" id="L1683" title="All 2 branches covered.">        if (!IonTokenConstsX.isDigit(c))</span>
        {
<span class="fc" id="L1685">            return c;</span>
        }
<span class="fc" id="L1687">        sb.append((char) c);</span>

<span class="fc" id="L1689">        return readNumeric(sb, Radix.DECIMAL, NumericState.DIGIT);</span>
    }

    private final void load_fixed_digits(StringBuilder sb, int len)
        throws IOException
    {
        int c;

<span class="pc bpc" id="L1697" title="3 of 5 branches missed.">        switch (len) {</span>
        default:
<span class="nc bnc" id="L1699" title="All 2 branches missed.">            while (len &gt; 4) {</span>
<span class="nc" id="L1700">                c = read_char();</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                if (!IonTokenConstsX.isDigit(c)) bad_token(c);</span>
<span class="nc" id="L1702">                sb.append((char)c);</span>
<span class="nc" id="L1703">                len--;</span>
            }
            // fall through
        case 4:
<span class="nc" id="L1707">            c = read_char();</span>
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</span>
<span class="nc" id="L1709">            sb.append((char)c);</span>
            // fall through
        case 3:
<span class="nc" id="L1712">            c = read_char();</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</span>
<span class="nc" id="L1714">            sb.append((char)c);</span>
            // fall through
        case 2:
<span class="fc" id="L1717">            c = read_char();</span>
<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</span>
<span class="fc" id="L1719">            sb.append((char)c);</span>
            // fall through
        case 1:
<span class="fc" id="L1722">            c = read_char();</span>
<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">            if (!IonTokenConstsX.isDigit(c)) bad_token(c);</span>
<span class="fc" id="L1724">            sb.append((char)c);</span>
            break;
        }

<span class="fc" id="L1728">        return;</span>
    }
    private final IonType load_timestamp(StringBuilder sb, int c)
        throws IOException
    {
        // we read the year in our caller, we should only be
        // here is we read 4 digits and then a dash or a 'T'
<span class="pc bpc" id="L1735" title="2 of 6 branches missed.">        assert (c == '-' || c == 'T');</span>

<span class="fc" id="L1737">        sb.append((char)c);</span>

        // if it's 'T' we done: yyyyT
<span class="fc bfc" id="L1740" title="All 2 branches covered.">        if (c == 'T') {</span>
<span class="fc" id="L1741">            c = read_char(); // because we'll unread it before we return</span>
<span class="fc" id="L1742">            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</span>
        }

        // read month
<span class="fc" id="L1746">        load_fixed_digits(sb, 2);</span>

<span class="fc" id="L1748">        c = read_char();</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">        if (c == 'T') {</span>
<span class="fc" id="L1750">            sb.append((char)c);</span>
<span class="fc" id="L1751">            c = read_char(); // because we'll unread it before we return</span>
<span class="fc" id="L1752">            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</span>
        }
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">        if (c != '-') bad_token(c);</span>

        // read day
<span class="fc" id="L1757">        sb.append((char)c);</span>
<span class="fc" id="L1758">        load_fixed_digits(sb, 2);</span>

        // look for the 'T', otherwise we're done (and happy about it)
<span class="fc" id="L1761">        c = read_char();</span>
<span class="fc bfc" id="L1762" title="All 2 branches covered.">        if (c != 'T') {</span>
<span class="fc" id="L1763">            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</span>
        }

        // so either we're done or we must at least hours and minutes
        // hour
<span class="fc" id="L1768">        sb.append((char)c);</span>
<span class="fc" id="L1769">        c = read_char();</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">        if (!IonTokenConstsX.isDigit(c)) {</span>
<span class="fc" id="L1771">            return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</span>
        }
<span class="fc" id="L1773">        sb.append((char)c);</span>
<span class="fc" id="L1774">        load_fixed_digits(sb,1); // we already read the first digit</span>
<span class="fc" id="L1775">        c = read_char();</span>
<span class="pc bpc" id="L1776" title="1 of 2 branches missed.">        if (c != ':') bad_token(c);</span>

        // minutes
<span class="fc" id="L1779">        sb.append((char)c);</span>
<span class="fc" id="L1780">        load_fixed_digits(sb, 2);</span>
<span class="fc" id="L1781">        c = read_char();</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">        if (c == ':') {</span>
            // seconds are optional
            // and first we'll have the whole seconds
<span class="fc" id="L1785">            sb.append((char)c);</span>
<span class="fc" id="L1786">            load_fixed_digits(sb, 2);</span>
<span class="fc" id="L1787">            c = read_char();</span>
<span class="fc bfc" id="L1788" title="All 2 branches covered.">            if (c == '.') {</span>
<span class="fc" id="L1789">                sb.append((char)c);</span>
<span class="fc" id="L1790">                c = read_char();</span>
                // Per spec and W3C Note http://www.w3.org/TR/NOTE-datetime
                // We require at least one digit after the decimal point.
<span class="fc bfc" id="L1793" title="All 2 branches covered.">                if (!IonTokenConstsX.isDigit(c)) {</span>
<span class="nc" id="L1794">                    expected_but_found(&quot;at least one digit after timestamp's decimal point&quot;, c);</span>
                }
<span class="fc" id="L1796">                c = load_digits(sb,c);</span>
            }
        }

        // since we have a time, we have to have a timezone of some sort
        // the timezone offset starts with a '+' '-' 'Z' or 'z'
<span class="fc bfc" id="L1802" title="All 4 branches covered.">        if (c == 'z' || c == 'Z') {</span>
<span class="fc" id="L1803">            sb.append((char)c);</span>
            // read ahead since we'll check for a valid ending in a bit
<span class="fc" id="L1805">            c = read_char();</span>
        }
<span class="pc bpc" id="L1807" title="1 of 4 branches missed.">        else if (c == '+' || c == '-') {</span>
            // then ... hours of time offset
<span class="fc" id="L1809">            sb.append((char)c);</span>
<span class="fc" id="L1810">            load_fixed_digits(sb, 2);</span>
<span class="fc" id="L1811">            c = read_char();</span>
<span class="fc bfc" id="L1812" title="All 2 branches covered.">            if (c != ':') {</span>
                // those hours need their minutes if it wasn't a 'z'
                // (above) then it has to be a +/- hours { : minutes }
<span class="nc" id="L1815">                bad_token(c);</span>
            }
            // and finally the *not* optional minutes of time offset
<span class="fc" id="L1818">            sb.append((char)c);</span>
<span class="fc" id="L1819">            load_fixed_digits(sb, 2);</span>
<span class="fc" id="L1820">            c = read_char();</span>
        }
        else {
            // some sort of offset is required with a time value
            // if it wasn't a 'z' (above) then it has to be a +/- hours { : minutes }
<span class="nc" id="L1825">            bad_token(c);</span>
        }
<span class="fc" id="L1827">        return load_finish_number(sb, c, IonTokenConstsX.TOKEN_TIMESTAMP);</span>
    }

    private final int loadRadixValue(StringBuilder sb, boolean has_sign, int c2, Radix radix)
        throws IOException
    {
<span class="fc" id="L1833">        radix.assertPrefix(c2);</span>
<span class="fc" id="L1834">        sb.append((char) c2);</span>

<span class="fc" id="L1836">        return readNumeric(sb, radix);</span>
    }

    private final int skip_over_symbol_identifier(SavePoint sp) throws IOException
    {
<span class="fc" id="L1841">        int c = read_char();</span>

<span class="fc bfc" id="L1843" title="All 2 branches covered.">        while(IonTokenConstsX.isValidSymbolCharacter(c)) {</span>
<span class="fc" id="L1844">            c = read_char();</span>
        }

<span class="pc bpc" id="L1847" title="1 of 2 branches missed.">        if (sp != null) {</span>
<span class="fc" id="L1848">            sp.markEnd(0);</span>
         }
<span class="fc" id="L1850">        return c;</span>
    }

    protected void load_symbol_identifier(StringBuilder sb) throws IOException
    {
<span class="fc" id="L1855">        int c = read_char();</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">        while(IonTokenConstsX.isValidSymbolCharacter(c)) {</span>
<span class="fc" id="L1857">            sb.append((char)c);</span>
<span class="fc" id="L1858">            c = read_char();</span>
        }
<span class="fc" id="L1860">        unread_char(c);</span>
<span class="fc" id="L1861">    }</span>

    private int skip_over_symbol_operator(SavePoint sp) throws IOException
    {
<span class="fc" id="L1865">        int c = read_char();</span>

        // lookahead for +inf and -inf
<span class="pc bpc" id="L1868" title="1 of 2 branches missed.">        if (peek_inf_helper(c)) // this will consume the inf if it succeeds</span>
        {
            // do nothing, peek_inf did all the work for us
            // (such as it is)
<span class="nc" id="L1872">            c = read_char();</span>
        }
        else {
<span class="pc bpc" id="L1875" title="2 of 4 branches missed.">            assert(IonTokenConstsX.isValidExtendedSymbolCharacter(c));</span>

            // if it's not +/- inf then we'll just read the characters normally
<span class="fc bfc" id="L1878" title="All 2 branches covered.">            while (IonTokenConstsX.isValidExtendedSymbolCharacter(c)) {</span>
<span class="fc" id="L1879">                c = read_char();</span>
            }
        }
<span class="pc bpc" id="L1882" title="1 of 2 branches missed.">        if (sp != null) {</span>
<span class="nc" id="L1883">            sp.markEnd(0);</span>
        }
<span class="fc" id="L1885">        return c;</span>
    }
    protected void load_symbol_operator(StringBuilder sb) throws IOException
    {
<span class="fc" id="L1889">        int c = read_char();</span>

        // lookahead for +inf and -inf
        // this will consume the inf if it succeeds
<span class="pc bpc" id="L1893" title="1 of 6 branches missed.">        if ((c == '+' || c == '-') &amp;&amp; peek_inf_helper(c)) {</span>
<span class="nc" id="L1894">            sb.append((char)c);</span>
<span class="nc" id="L1895">            sb.append(&quot;inf&quot;);</span>
        }
        else {
<span class="pc bpc" id="L1898" title="2 of 4 branches missed.">            assert(IonTokenConstsX.isValidExtendedSymbolCharacter(c));</span>

            // if it's not +/- inf then we'll just read the characters normally
<span class="fc bfc" id="L1901" title="All 2 branches covered.">            while (IonTokenConstsX.isValidExtendedSymbolCharacter(c)) {</span>
<span class="fc" id="L1902">                sb.append((char)c);</span>
<span class="fc" id="L1903">                c = read_char();</span>
            }
<span class="fc" id="L1905">            unread_char(c);</span>
        }

<span class="fc" id="L1908">        return;</span>
    }
    private final int skip_single_quoted_string(SavePoint sp) throws IOException
    {
        int c;

        // the position should always be correct here
        // since there's no reason to lookahead into a
        // quoted symbol

        for (;;) {
<span class="fc" id="L1919">            c = read_string_char(ProhibitedCharacters.NONE);</span>
<span class="pc bpc" id="L1920" title="1 of 4 branches missed.">            switch (c) {</span>
<span class="nc" id="L1921">            case -1: unexpected_eof();</span>
            case '\'':
<span class="fc bfc" id="L1923" title="All 2 branches covered.">                if (sp != null) {</span>
<span class="fc" id="L1924">                   sp.markEnd(-1);</span>
                }
<span class="fc" id="L1926">                return read_char(); // Return the next character beyond the token</span>
            case '\\':
<span class="fc" id="L1928">                c = read_char();</span>
<span class="fc" id="L1929">                break;</span>
            }
        }
    }

    protected int load_single_quoted_string(StringBuilder sb, boolean is_clob)
        throws IOException
    {
        int c;

        for (;;) {
<span class="fc" id="L1940">            c = read_string_char(ProhibitedCharacters.NONE);</span>
<span class="pc bpc" id="L1941" title="1 of 5 branches missed.">            switch (c) {</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<span class="fc" id="L1945">                continue;</span>
            case -1:
            case '\'':
<span class="fc" id="L1948">                return c;</span>
            // new line normalization and counting is handled in read_char
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<span class="nc" id="L1953">                bad_token(c);</span>
            case '\\':
                // TODO why not read_char_escaped() ?
                //  That's how load_double_quoted_string works.
<span class="fc" id="L1957">                c = read_char();</span>
<span class="fc" id="L1958">                c = read_escaped_char_content_helper(c, is_clob);</span>
<span class="fc" id="L1959">                break;</span>
            default:
<span class="pc bpc" id="L1961" title="1 of 4 branches missed.">                if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</span>
<span class="fc" id="L1962">                    c = read_large_char_sequence(c);</span>
                }
            }

<span class="pc bpc" id="L1966" title="1 of 2 branches missed.">            if (!is_clob) {</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">                if (IonUTF8.needsSurrogateEncoding(c)) {</span>
<span class="fc" id="L1968">                    sb.append(IonUTF8.highSurrogate(c));</span>
<span class="fc" id="L1969">                    c = IonUTF8.lowSurrogate(c);</span>
                }
            }
<span class="nc bnc" id="L1972" title="All 2 branches missed.">            else if (IonTokenConstsX.is8bitValue(c)) {</span>
<span class="nc" id="L1973">                bad_token(c);</span>
            }
<span class="fc" id="L1975">            sb.append((char)c);</span>
        }
    }

    private void skip_double_quoted_string(SavePoint sp) throws IOException
    {
<span class="fc" id="L1981">        skip_double_quoted_string_helper();</span>
<span class="fc bfc" id="L1982" title="All 2 branches covered.">        if (sp != null) {</span>
<span class="fc" id="L1983">            sp.markEnd(-1);</span>
        }
<span class="fc" id="L1985">    }</span>

    private final void skip_double_quoted_string_helper() throws IOException
    {
        int c;
        for (;;) {
<span class="fc" id="L1991">            c = read_string_char(ProhibitedCharacters.NONE);</span>
<span class="pc bpc" id="L1992" title="1 of 5 branches missed.">            switch (c) {</span>
            case -1:
<span class="nc" id="L1994">                unexpected_eof(); // throws</span>
            // new line normalization and counting is handled in read_char
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<span class="nc" id="L1999">                bad_token(c); // throws</span>
            case '&quot;':
<span class="fc" id="L2001">                return;</span>
            case '\\':
<span class="fc" id="L2003">                c = read_char();</span>
<span class="fc" id="L2004">                break;</span>
            }
        }
    }

    protected int load_double_quoted_string(StringBuilder sb, boolean is_clob)
        throws IOException
    {
        int c;

        for (;;) {
<span class="fc" id="L2015">            c = read_string_char(ProhibitedCharacters.SHORT_CHAR);</span>
<span class="pc bpc" id="L2016" title="1 of 5 branches missed.">            switch (c) {</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
<span class="fc" id="L2020">                continue;</span>
            case -1:
            case '&quot;':
<span class="fc" id="L2023">                return c;</span>
            // new line normalization and counting is handled in read_char
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<span class="nc" id="L2028">                bad_token(c);</span>
            case '\\':
<span class="fc" id="L2030">                c = read_char_escaped(c, is_clob);</span>
<span class="fc" id="L2031">                break;</span>
            default:
<span class="pc bpc" id="L2033" title="1 of 4 branches missed.">                if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</span>
<span class="fc" id="L2034">                    c = read_large_char_sequence(c);</span>
                }
                break;
            }

<span class="pc bpc" id="L2039" title="1 of 2 branches missed.">            if (!is_clob) {</span>
<span class="fc bfc" id="L2040" title="All 2 branches covered.">                if (IonUTF8.needsSurrogateEncoding(c)) {</span>
<span class="fc" id="L2041">                    sb.append(IonUTF8.highSurrogate(c));</span>
<span class="fc" id="L2042">                    c = IonUTF8.lowSurrogate(c);</span>
                }
            }
<span class="fc" id="L2045">            sb.append((char)c);</span>
        }
    }

    protected int read_double_quoted_char(boolean is_clob) throws IOException
    {
<span class="fc" id="L2051">        int c = read_char();</span>
<span class="pc bpc" id="L2052" title="1 of 4 branches missed.">        if(is_clob &amp;&amp; c &gt; 127) {</span>
<span class="fc" id="L2053">            throw new IonReaderTextTokenException(&quot;non ASCII character in clob: &quot; + c);</span>
        }

<span class="pc bpc" id="L2056" title="1 of 4 branches missed.">        switch (c) {</span>
        case '&quot;':
<span class="nc" id="L2058">            unread_char(c);</span>
<span class="nc" id="L2059">            c = CharacterSequence.CHAR_SEQ_STRING_TERMINATOR;</span>
<span class="nc" id="L2060">            break;</span>
        case -1:
<span class="fc" id="L2062">            break;</span>
        case '\\':
<span class="fc" id="L2064">            c = read_char_escaped(c, is_clob);</span>
<span class="fc" id="L2065">            break;</span>
        default:
<span class="pc bpc" id="L2067" title="3 of 4 branches missed.">            if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</span>
<span class="nc" id="L2068">                c = read_large_char_sequence(c);</span>
            }
            break;
        }

<span class="fc" id="L2073">        return c;</span>
    }

    /**
     * Skip to the end of a triple quoted string sequence, ignoring any
     * comments encountered between triple quoted string elements.
     * @param sp
     * @throws IOException
     */
    private void skip_triple_quoted_string(SavePoint sp) throws IOException
    {
<span class="fc" id="L2084">        skip_triple_quoted_string(sp, CommentStrategy.IGNORE);</span>
<span class="fc" id="L2085">    }</span>

    /**
     * Skip to the end of a triple quoted string sequence within a clob,
     * erroring on any comments encountered between triple quoted string
     * elements.
     * @param sp
     * @throws IOException
     */
    private void skip_triple_quoted_clob_string(SavePoint sp) throws IOException
    {
<span class="fc" id="L2096">        skip_triple_quoted_string(sp, CommentStrategy.ERROR);</span>
<span class="fc" id="L2097">    }</span>

    private void skip_triple_quoted_string(SavePoint sp, CommentStrategy commentStrategy) throws IOException
    {
        // starts AFTER the 3 quotes have been consumed
        int c;
        for (;;) {
<span class="fc" id="L2104">            c = read_char();</span>
<span class="pc bpc" id="L2105" title="1 of 4 branches missed.">            switch (c) {</span>
            case -1:
<span class="nc" id="L2107">                unexpected_eof();</span>
            case '\'':
<span class="fc" id="L2109">                c = read_char();</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">                if (c == '\'') { // 2nd quote</span>
<span class="fc" id="L2111">                    c = read_char(); // possibly the 3rd</span>
<span class="fc bfc" id="L2112" title="All 2 branches covered.">                    if (sp != null) {</span>
<span class="fc" id="L2113">                        sp.markEnd(-3);</span>
                    }
<span class="fc bfc" id="L2115" title="All 2 branches covered.">                    if (c == '\'') { // it is the 3rd quote - end of this segment</span>
<span class="fc" id="L2116">                        c = skip_over_whitespace(commentStrategy);</span>
<span class="pc bpc" id="L2117" title="1 of 4 branches missed.">                        if (c == '\'' &amp;&amp; is_2_single_quotes_helper()) {</span>
                            // there's another segment so read the next segment as well
<span class="fc" id="L2119">                            break;</span>
                        }
                        // end of last segment
<span class="fc" id="L2122">                        unread_char(c);</span>
<span class="fc" id="L2123">                        return;</span>
                    }
                }
                break;
            case '\\':
<span class="fc" id="L2128">                c = read_char();</span>
<span class="fc" id="L2129">               break;</span>
            }
        }
    }

    protected int load_triple_quoted_string(StringBuilder sb, boolean is_clob)
        throws IOException
    {
        int c;

        for (;;) {
<span class="fc" id="L2140">            c = read_triple_quoted_char(is_clob);</span>
<span class="fc bfc" id="L2141" title="All 6 branches covered.">            switch(c) {</span>
            case CharacterSequence.CHAR_SEQ_STRING_TERMINATOR:
            case CharacterSequence.CHAR_SEQ_EOF: // was EOF
<span class="fc" id="L2144">                return c;</span>
            // new line normalization and counting is handled in read_char
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<span class="fc" id="L2147">                c = '\n';</span>
<span class="fc" id="L2148">                break;</span>
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
                // TODO: uncomment if we don't want to normalize end of line: c = '\r';
<span class="fc" id="L2151">                c = '\n';</span>
<span class="fc" id="L2152">                break;</span>
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
                // TODO: uncomment if we don't want to normalize end of line: sb.append('\r');
<span class="fc" id="L2155">                c = '\n';</span>
<span class="fc" id="L2156">                break;</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
            case CharacterSequence.CHAR_SEQ_STRING_NON_TERMINATOR:
<span class="fc" id="L2161">                continue;</span>
            default:
                break;
            }
            // if this isn't a clob we need to decode UTF8 and
            // handle surrogate encoding (otherwise we don't care)
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">            if (!is_clob) {</span>
<span class="fc bfc" id="L2168" title="All 2 branches covered.">                if (IonUTF8.needsSurrogateEncoding(c)) {</span>
<span class="fc" id="L2169">                    sb.append(IonUTF8.highSurrogate(c));</span>
<span class="fc" id="L2170">                    c = IonUTF8.lowSurrogate(c);</span>
                }
            }
<span class="fc" id="L2173">            sb.append((char)c);</span>
        }
    }

    protected int read_triple_quoted_char(boolean is_clob) throws IOException
    {
<span class="fc" id="L2179">        int c = read_string_char(ProhibitedCharacters.LONG_CHAR);</span>
<span class="fc bfc" id="L2180" title="All 4 branches covered.">        if(is_clob &amp;&amp; c &gt; 127) {</span>
<span class="fc" id="L2181">            throw new IonReaderTextTokenException(&quot;non ASCII character in clob: &quot; + c);</span>
        }

<span class="fc bfc" id="L2184" title="All 5 branches covered.">        switch (c) {</span>
        case '\'':
<span class="fc bfc" id="L2186" title="All 2 branches covered.">            if (is_2_single_quotes_helper()) {</span>
                // so at this point we are at the end of the closing
                // triple quote - so we need to look ahead to see if
                // there's just whitespace and a new opening triple quote
<span class="fc" id="L2190">                c = skip_over_whitespace();</span>
<span class="pc bpc" id="L2191" title="1 of 4 branches missed.">                if (c == '\'' &amp;&amp; is_2_single_quotes_helper()) {</span>
                    // there's another segment so read the next segment as well
                    // since we're now just before char 1 of the next segment
                    // loop again, but don't append this char
<span class="fc" id="L2195">                    return CharacterSequence.CHAR_SEQ_STRING_NON_TERMINATOR;</span>
                }
                // end of last segment - we're done (although we read a bit too far)
<span class="fc" id="L2198">                unread_char(c);</span>
<span class="fc" id="L2199">                c = CharacterSequence.CHAR_SEQ_STRING_TERMINATOR;</span>
            }
            break;
        case '\\':
<span class="fc" id="L2203">            c = read_char_escaped(c, is_clob);</span>
<span class="fc" id="L2204">            break;</span>
        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
        case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
        case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<span class="fc" id="L2211">            break;</span>
        case -1:
<span class="fc" id="L2213">            break;</span>
        default:
<span class="fc bfc" id="L2215" title="All 4 branches covered.">            if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</span>
<span class="fc" id="L2216">                c = read_large_char_sequence(c);</span>
            }
            break;
        }

<span class="fc" id="L2221">        return c;</span>
    }

    /** Skips over the closing }} too. */
    protected void skip_over_lob(int lobToken, SavePoint sp) throws IOException {
<span class="pc bpc" id="L2226" title="1 of 4 branches missed.">        switch(lobToken) {</span>
        case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="fc" id="L2228">            skip_double_quoted_string(sp);</span>
<span class="fc" id="L2229">            skip_clob_close_punctuation();</span>
<span class="fc" id="L2230">            break;</span>
        case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="fc" id="L2232">            skip_triple_quoted_clob_string(sp);</span>
<span class="fc" id="L2233">            skip_clob_close_punctuation();</span>
<span class="fc" id="L2234">            break;</span>
        case IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE:
<span class="fc" id="L2236">            skip_over_blob(sp);</span>
<span class="fc" id="L2237">            break;</span>
        default:
<span class="nc" id="L2239">            error(&quot;unexpected token &quot;+IonTokenConstsX.getTokenName(lobToken)+</span>
                  &quot; encountered for lob content&quot;);
        }
<span class="fc" id="L2242">    }</span>

    protected void load_clob(int lobToken, StringBuilder sb) throws IOException
    {
<span class="nc bnc" id="L2246" title="All 4 branches missed.">        switch(lobToken) {</span>
        case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="nc" id="L2248">            load_double_quoted_string(sb, true);</span>
<span class="nc" id="L2249">            break;</span>
        case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="nc" id="L2251">            load_triple_quoted_string(sb, true);</span>
<span class="nc" id="L2252">            break;</span>
        case IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE:
<span class="nc" id="L2254">            load_blob(sb);</span>
<span class="nc" id="L2255">            break;</span>
        default:
<span class="nc" id="L2257">            error(&quot;unexpected token &quot;+IonTokenConstsX.getTokenName(lobToken)+</span>
                  &quot; encountered for lob content&quot;);
        }
<span class="nc" id="L2260">    }</span>

    private final int read_char_escaped(int c, boolean is_clob)
        throws IOException
    {
        for (;;) {
<span class="pc bpc" id="L2266" title="2 of 3 branches missed.">            switch (c) {</span>
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:
            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:
                // loop again, we don't want empty escape chars
<span class="nc" id="L2271">                c = read_string_char(ProhibitedCharacters.NONE);</span>
<span class="nc" id="L2272">                continue;</span>
            case '\\':
<span class="fc" id="L2274">                c = read_char();</span>
<span class="fc bfc" id="L2275" title="All 2 branches covered.">                if (c &lt; 0) {</span>
<span class="nc" id="L2276">                    unexpected_eof();</span>
                }
<span class="fc" id="L2278">                c = read_escaped_char_content_helper(c, is_clob);</span>
<span class="pc bpc" id="L2279" title="3 of 6 branches missed.">                if (c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1</span>
                 || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2
                 || c == CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3
                ) {
                    // loop again, we don't want empty escape chars
<span class="nc" id="L2284">                    c = read_string_char(ProhibitedCharacters.NONE);</span>
<span class="nc" id="L2285">                    continue;</span>
                }
<span class="pc bpc" id="L2287" title="1 of 2 branches missed.">                if (c == IonTokenConstsX.ESCAPE_NOT_DEFINED) bad_escape_sequence();</span>
                break;
            default:
<span class="nc bnc" id="L2290" title="All 4 branches missed.">                if (!is_clob &amp;&amp; !IonTokenConstsX.is7bitValue(c)) {</span>
<span class="nc" id="L2291">                    c = read_large_char_sequence(c);</span>
                }
                break;
            }
            break; // at this point we have a post-escaped character to return to the caller
        }

<span class="pc bpc" id="L2298" title="1 of 2 branches missed.">        if (c == CharacterSequence.CHAR_SEQ_EOF) return c;</span>
<span class="pc bpc" id="L2299" title="1 of 4 branches missed.">        if (is_clob &amp;&amp; !IonTokenConstsX.is8bitValue(c)) {</span>
<span class="nc" id="L2300">            error(&quot;invalid character [&quot;+ printCodePointAsString(c)+&quot;] in CLOB&quot;);</span>
        }
<span class="fc" id="L2302">        return c;</span>
    }

    private final int read_large_char_sequence(int c) throws IOException
    {
<span class="fc bfc" id="L2307" title="All 2 branches covered.">        if (_stream._is_byte_data) {</span>
<span class="fc" id="L2308">            return read_ut8_sequence(c);</span>
        }
<span class="fc bfc" id="L2310" title="All 2 branches covered.">        if (PrivateIonConstants.isHighSurrogate(c)) {</span>
<span class="fc" id="L2311">            int c2 = read_char();</span>
<span class="fc bfc" id="L2312" title="All 2 branches covered.">            if (PrivateIonConstants.isLowSurrogate(c2)) {</span>
<span class="fc" id="L2313">                c = PrivateIonConstants.makeUnicodeScalar(c, c2);</span>
            }
            else {
                // we don't always pair up surrogates here
                // our caller does that
<span class="fc" id="L2318">                unread_char(c2);</span>
            }
        }
<span class="fc" id="L2321">        return c;</span>
    }
    private final int read_ut8_sequence(int c) throws IOException
    {
        // this should have the high order bit set
<span class="pc bpc" id="L2326" title="2 of 4 branches missed.">        assert(!IonTokenConstsX.is7bitValue(c));</span>
<span class="fc" id="L2327">        int len = IonUTF8.getUTF8LengthFromFirstByte(c);</span>
        int b2, b3, b4;
<span class="pc bpc" id="L2329" title="2 of 5 branches missed.">        switch (len) {</span>
        case 1:
<span class="nc" id="L2331">            break;</span>
        case 2:
<span class="fc" id="L2333">            b2 = read_char();</span>
<span class="fc" id="L2334">            c = IonUTF8.twoByteScalar(c, b2);</span>
<span class="fc" id="L2335">            break;</span>
        case 3:
<span class="fc" id="L2337">            b2 = read_char();</span>
<span class="fc" id="L2338">            b3 = read_char();</span>
<span class="fc" id="L2339">            c = IonUTF8.threeByteScalar(c, b2, b3);</span>
<span class="fc" id="L2340">            break;</span>
        case 4:
<span class="fc" id="L2342">            b2 = read_char();</span>
<span class="fc" id="L2343">            b3 = read_char();</span>
<span class="fc" id="L2344">            b4 = read_char();</span>
<span class="fc" id="L2345">            c = IonUTF8.fourByteScalar(c, b2, b3, b4);</span>
<span class="fc" id="L2346">            break;</span>
        default:
<span class="nc" id="L2348">            error(&quot;invalid UTF8 starting byte&quot;);</span>
        }
<span class="fc" id="L2350">        return c;</span>
    }

    private void skip_over_blob(SavePoint sp) throws IOException
    {
<span class="fc" id="L2355">        int c = skip_over_blob_whitespace();</span>
        for (;;) {
<span class="fc bfc" id="L2357" title="All 2 branches covered.">            if (c == UnifiedInputStreamX.EOF) break;</span>
<span class="fc bfc" id="L2358" title="All 2 branches covered.">            if (c == '}') break;</span>
<span class="fc" id="L2359">            c = skip_over_blob_whitespace();</span>
        }
<span class="fc bfc" id="L2361" title="All 2 branches covered.">        if (sp != null) {</span>
            // we don't care about these last 2 closing curly braces
            // but we may have seen one of them already
<span class="fc bfc" id="L2364" title="All 2 branches covered.">            int offset = (c == '}') ? -1 : 0;</span>
<span class="fc" id="L2365">            sp.markEnd(offset);</span>
        }
        // did we hit EOF or the first '}' ?
<span class="pc bpc" id="L2368" title="1 of 2 branches missed.">        if (c != '}') unexpected_eof();</span>
<span class="fc" id="L2369">        c = read_char();</span>
<span class="fc bfc" id="L2370" title="All 2 branches covered.">        if (c &lt; 0) {</span>
<span class="nc" id="L2371">            unexpected_eof();</span>
        }
<span class="fc bfc" id="L2373" title="All 2 branches covered.">        if (c != '}') {</span>
<span class="fc" id="L2374">            String message = &quot;improperly closed BLOB, &quot;</span>
<span class="fc" id="L2375">                           + IonTextUtils.printCodePointAsString(c)</span>
                           + &quot; encountered when '}' was expected&quot;;
<span class="nc" id="L2377">            error(message);</span>
        }
<span class="fc bfc" id="L2379" title="All 2 branches covered.">        if (sp != null) {</span>
<span class="fc" id="L2380">            sp.markEnd();</span>
        }
<span class="fc" id="L2382">        return;</span>
    }
    protected void load_blob(StringBuilder sb) throws IOException {
        int c;

        for (;;) {
<span class="nc" id="L2388">            c = read_base64_byte();</span>
<span class="nc bnc" id="L2389" title="All 2 branches missed.">            if (c == UnifiedInputStreamX.EOF) {</span>
<span class="nc" id="L2390">                break;</span>
            }
<span class="nc" id="L2392">            sb.append(c);</span>
        }
        // did we hit EOF or the first '}' ?
<span class="nc bnc" id="L2395" title="All 2 branches missed.">        if (_stream.isEOF()) unexpected_eof();</span>

<span class="nc" id="L2397">        c = read_char();</span>
<span class="nc bnc" id="L2398" title="All 2 branches missed.">        if (c &lt; 0) {</span>
<span class="nc" id="L2399">            unexpected_eof();</span>
        }
<span class="nc bnc" id="L2401" title="All 2 branches missed.">        if (c != '}') {</span>
<span class="nc" id="L2402">            String message = &quot;improperly closed BLOB, &quot;</span>
<span class="nc" id="L2403">                           + IonTextUtils.printCodePointAsString(c)</span>
                           + &quot; encountered when '}' was expected&quot;;
<span class="nc" id="L2405">            error(message);</span>
        }
<span class="nc" id="L2407">        return;</span>
    }

    private final int read_escaped_char_content_helper(int c1, boolean is_clob)
        throws IOException
    {
<span class="pc bpc" id="L2413" title="1 of 2 branches missed.">        if (c1 &lt; 0) {</span>
<span class="nc bnc" id="L2414" title="All 4 branches missed.">            switch (c1) {</span>
            // new line normalization and counting is handled in read_char
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:
<span class="nc" id="L2417">                return CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1;</span>
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:
<span class="nc" id="L2419">                return CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2;</span>
            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:
<span class="nc" id="L2421">                return CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3;</span>
            default:
<span class="nc" id="L2423">                bad_escape_sequence(c1);</span>
            }
        }
<span class="fc bfc" id="L2426" title="All 2 branches covered.">        if (!IonTokenConstsX.isValidEscapeStart(c1)) {</span>
<span class="nc" id="L2427">            bad_escape_sequence(c1);</span>
        }
<span class="fc" id="L2429">        int c2 = IonTokenConstsX.escapeReplacementCharacter(c1);</span>
<span class="pc bpc" id="L2430" title="1 of 5 branches missed.">        switch (c2) {</span>
        case IonTokenConstsX.ESCAPE_NOT_DEFINED:
<span class="nc bnc" id="L2432" title="All 2 branches missed.">            assert false</span>
                : &quot;invalid escape start characters (line &quot; + ((char)c1)
                + &quot; should have been removed by isValid&quot;;
            break;
        case IonTokenConstsX.ESCAPE_LITTLE_U:
<span class="fc bfc" id="L2437" title="All 2 branches covered.">            if (is_clob) {</span>
<span class="nc" id="L2438">                bad_escape_sequence(c2);</span>
            }
<span class="fc" id="L2440">            c2 = read_hex_escape_sequence_value(4);</span>
<span class="fc" id="L2441">            break;</span>
        case IonTokenConstsX.ESCAPE_BIG_U:
<span class="fc bfc" id="L2443" title="All 2 branches covered.">            if (is_clob) {</span>
<span class="nc" id="L2444">                bad_escape_sequence(c2);</span>
            }
<span class="fc" id="L2446">            c2 = read_hex_escape_sequence_value(8);</span>
<span class="fc" id="L2447">            break;</span>
        case IonTokenConstsX.ESCAPE_HEX:
<span class="fc" id="L2449">            c2 = read_hex_escape_sequence_value(2);</span>
            break;
        }
<span class="fc" id="L2452">        return c2;</span>
    }
    private final int read_hex_escape_sequence_value(int len) throws IOException
    {
<span class="fc" id="L2456">        int hexchar = 0;</span>
<span class="fc bfc" id="L2457" title="All 2 branches covered.">        while (len &gt; 0) {</span>
<span class="fc" id="L2458">            len--;</span>
<span class="fc" id="L2459">            int c = read_char();</span>
<span class="pc bpc" id="L2460" title="1 of 2 branches missed.">            if (c &lt; 0) {</span>
<span class="nc" id="L2461">                unexpected_eof();</span>
            }
<span class="fc" id="L2463">            int d = IonTokenConstsX.hexDigitValue(c);</span>
<span class="pc bpc" id="L2464" title="1 of 2 branches missed.">            if (d &lt; 0) return -1;</span>
<span class="fc" id="L2465">            hexchar = (hexchar &lt;&lt; 4) + d;</span>
<span class="fc" id="L2466">        }</span>
<span class="pc bpc" id="L2467" title="1 of 2 branches missed.">        if (len &gt; 0) {</span>
<span class="nc" id="L2468">            String message = &quot;invalid hex digit [&quot;</span>
<span class="nc" id="L2469">                + IonTextUtils.printCodePointAsString(hexchar)</span>
                + &quot;] in escape sequence&quot;;
<span class="nc" id="L2471">            error(message);</span>
        }
<span class="fc" id="L2473">        return hexchar;</span>
    }

    public final int read_base64_byte() throws IOException
    {
        int b;
<span class="fc bfc" id="L2479" title="All 2 branches covered.">        if (_base64_prefetch_count &lt; 1) {</span>
<span class="fc" id="L2480">            b = read_base64_byte_helper();</span>
        }
        else {
<span class="fc" id="L2483">            b = (_base64_prefetch_stack &amp; 0xff);</span>
<span class="fc" id="L2484">            _base64_prefetch_stack &gt;&gt;= 8;</span>
<span class="fc" id="L2485">            _base64_prefetch_count--;</span>
        }
<span class="fc" id="L2487">        return b;</span>
    }
    private final int read_base64_byte_helper() throws IOException
    {
        // if there's any data left to read (the normal case)
        // we'll read 4 characters off the input source and
        // generate 1-3 bytes to return to the user.  That
        // will be 1 byte returned immediately and 0-2 bytes
        // put on the _binhex_stack to return later

<span class="fc" id="L2497">        int c = skip_over_blob_whitespace();</span>
<span class="pc bpc" id="L2498" title="1 of 4 branches missed.">        if (c == UnifiedInputStreamX.EOF || c == '}') {</span>
            // we'll figure how which is which by check the stream for eof
<span class="fc" id="L2500">            return UnifiedInputStreamX.EOF;</span>
        }

<span class="fc" id="L2503">        int c1 = read_base64_getchar_helper(c);</span>
<span class="fc" id="L2504">        int c2 = read_base64_getchar_helper();</span>
<span class="fc" id="L2505">        int c3 = read_base64_getchar_helper();</span>
<span class="fc" id="L2506">        int c4 = read_base64_getchar_helper();</span>

<span class="fc" id="L2508">        int b1, len = decode_base64_length(c1, c2, c3, c4);</span>

<span class="fc" id="L2510">        _base64_prefetch_stack = 0;</span>
<span class="fc" id="L2511">        _base64_prefetch_count = len - 1;</span>
<span class="pc bpc" id="L2512" title="1 of 4 branches missed.">        switch (len) {</span>
        default:
<span class="nc" id="L2514">            String message =</span>
<span class="nc" id="L2515">                &quot;invalid binhex sequence encountered at offset&quot;+input_position();</span>
<span class="nc" id="L2516">            throw new IonReaderTextTokenException(message);</span>
        case 3:
<span class="fc" id="L2518">            int b3  = decode_base64_byte3(c1, c2, c3, c4);</span>
<span class="fc" id="L2519">            _base64_prefetch_stack = (b3 &lt;&lt; 8) &amp; 0xff00;</span>
            // fall through
        case 2:
<span class="fc" id="L2522">            int b2  = decode_base64_byte2(c1, c2, c3, c4);</span>
<span class="fc" id="L2523">            _base64_prefetch_stack |= (b2 &amp; 0xff);</span>
            // fall through
        case 1:
<span class="fc" id="L2526">            b1 = decode_base64_byte1(c1, c2, c3, c4);</span>
            // fall through
        }
<span class="fc" id="L2529">        return b1;</span>
    }
    private final int read_base64_getchar_helper(int c) throws IOException {
<span class="pc bpc" id="L2532" title="3 of 6 branches missed.">        assert( ! (c == UnifiedInputStreamX.EOF || c == '}') );</span>

<span class="pc bpc" id="L2534" title="2 of 4 branches missed.">        if (c == UnifiedInputStreamX.EOF || c == '}') {</span>
<span class="nc" id="L2535">            return UnifiedInputStreamX.EOF;</span>
        }
<span class="fc bfc" id="L2537" title="All 2 branches covered.">        if (c == BASE64_TERMINATOR_CHAR) {</span>
<span class="nc" id="L2538">            error(&quot;invalid base64 image - excess terminator characters ['=']&quot;);</span>
        }
<span class="fc" id="L2540">        return read_base64_getchar_helper2(c);</span>
    }
    private final int read_base64_getchar_helper() throws IOException {
<span class="fc" id="L2543">        int c = skip_over_blob_whitespace();</span>
<span class="pc bpc" id="L2544" title="1 of 4 branches missed.">        if (c == UnifiedInputStreamX.EOF || c == '}') {</span>
<span class="nc" id="L2545">            error(&quot;invalid base64 image - too short&quot;);</span>
        }
<span class="fc" id="L2547">        return read_base64_getchar_helper2(c);</span>
    }
    private final int read_base64_getchar_helper2(int c) throws IOException {
<span class="pc bpc" id="L2550" title="3 of 6 branches missed.">        assert( ! (c == UnifiedInputStreamX.EOF || c == '}') );</span>

<span class="fc bfc" id="L2552" title="All 2 branches covered.">        if (c == BASE64_TERMINATOR_CHAR) {</span>
            // we're using a new EOF here since the '=' is in range
            // of 0-63 (6 bits) and we don't want to confuse it with
            // the normal EOF
<span class="fc" id="L2556">            return BASE64_EOF;</span>
        }
<span class="fc" id="L2558">        int b = BASE64_CHAR_TO_BIN[c &amp; 0xff];</span>
<span class="pc bpc" id="L2559" title="1 of 4 branches missed.">        if (b == UnifiedInputStreamX.EOF || !IonTokenConstsX.is8bitValue(c)) {</span>
<span class="fc" id="L2560">            String message = &quot;invalid character &quot;</span>
<span class="fc" id="L2561">                           + Character.toString((char)c)</span>
                           + &quot; encountered in base64 value at &quot;
<span class="fc" id="L2563">                           + input_position();</span>
<span class="fc" id="L2564">            throw new IonReaderTextTokenException(message);</span>
        }
<span class="fc" id="L2566">        return b;</span>
    }
    private final static int decode_base64_length(int c1, int c2, int c3, int c4) {
<span class="fc" id="L2569">        int len = 3;</span>
<span class="fc bfc" id="L2570" title="All 2 branches covered.">        if (c4 != BASE64_EOF)      len = 3;</span>
<span class="fc bfc" id="L2571" title="All 2 branches covered.">        else if (c3 != BASE64_EOF) len = 2;</span>
<span class="fc" id="L2572">        else                       len = 1;</span>
<span class="fc" id="L2573">        return len;</span>
    }
    private final static int decode_base64_byte1(int c1, int c2, int c3, int c4) {
        //extracted from Base64Encoder.java:
        // convert =  c1 &lt;&lt; 18;    [6:1] + 18 =&gt; [24:19]
        // convert |= (c2 &lt;&lt; 12);  [6:1] + 12 =&gt; [18:13]
        // b1 = (char)((convert &amp; 0x00FF0000) &gt;&gt; 16);  [32:1] &amp; 0x00FF0000 =&gt; [24:17] - 16 =&gt; [8:1]
        // byte1 uses the 6 bits in char1 + 2 highest bits (out of 6) from char2
        if (_debug) assert(decode_base64_length(c1, c2, c3, c4) &gt;= 1);
<span class="fc" id="L2582">        int b1 = (((c1 &lt;&lt; 2) &amp; 0xfc) | ((c2 &gt;&gt; 4) &amp; 0x03));</span>
<span class="fc" id="L2583">        return b1;</span>
    }
    private final static int decode_base64_byte2(int c1, int c2, int c3, int c4) {
        //convert |= (c2 &lt;&lt; 12);  [6:1]+12 =&gt; [18:13]
        //convert |= (c3 &lt;&lt; 6);   [6:1]+6  =&gt; [12:7]
        //b2 = (char)((convert &amp; 0x0000FF00) &gt;&gt; 8); [32:1] &amp; 0x0000FF00 =&gt; [16:9] - 8 =&gt; [8:1]
        // [18:13] - 8 -&gt; [10:5] or [6:5] from c2
        // [12:7] - 8 -&gt; [4:-1] or [6:3] - 2 from c3
        //byte2 uses 4 low bits from c2 and 4 high bits from c3
        if (_debug) assert(decode_base64_length(c1, c2, c3, c4) &gt;= 2);
<span class="fc" id="L2593">        int b2 = (((c2 &lt;&lt; 4) &amp; 0xf0) | ((c3 &gt;&gt; 2) &amp; 0x0f)) &amp; 0xff;</span>
<span class="fc" id="L2594">        return b2;</span>
    }
    private final static int decode_base64_byte3(int c1, int c2, int c3, int c4) {
        // convert |= (c3 &lt;&lt; 6); [6:1]+6  =&gt; [12:7]
        // convert |= (c4 &lt;&lt; 0); [6:1]+9  =&gt; [6:1]
        // b3 = (char)((convert &amp; 0x000000FF) &gt;&gt; 0);
        // b3 uses low 2 bits from c3 and all 6 bits of c4
        if (_debug) assert(decode_base64_length(c1, c2, c3, c4) &gt;= 3);
<span class="fc" id="L2602">        int b3 = (((c3 &amp; 0x03) &lt;&lt; 6) | (c4 &amp; 0x3f)) &amp; 0xff;</span>
<span class="fc" id="L2603">        return b3;</span>
    }

    protected void save_point_start(SavePoint sp) throws IOException
    {
<span class="pc bpc" id="L2608" title="3 of 6 branches missed.">        assert(sp != null &amp;&amp; sp.isClear());</span>
<span class="fc" id="L2609">        long line_number = _line_count;</span>
<span class="fc" id="L2610">        long line_start = _line_starting_position;</span>
<span class="fc" id="L2611">        sp.start(line_number, line_start);</span>
<span class="fc" id="L2612">    }</span>
    protected void save_point_activate(SavePoint sp) throws IOException
    {
<span class="pc bpc" id="L2615" title="3 of 6 branches missed.">        assert(sp != null &amp;&amp; sp.isDefined());</span>
<span class="fc" id="L2616">        long line_number = _line_count;</span>
<span class="fc" id="L2617">        long line_start  = _line_starting_position;</span>
        // this will set the &quot;restore&quot; (aka prev) line and start offset so
        // that when we pop the save point we'll get the correct line &amp; char
<span class="fc" id="L2620">        _stream._save_points.savePointPushActive(sp, line_number, line_start);</span>
<span class="fc" id="L2621">        _line_count = sp.getStartLineNumber();</span>
<span class="fc" id="L2622">        _line_starting_position = sp.getStartLineStart();</span>
<span class="fc" id="L2623">    }</span>
    protected void save_point_deactivate(SavePoint sp) throws IOException
    {
<span class="pc bpc" id="L2626" title="3 of 6 branches missed.">        assert(sp != null &amp;&amp; sp.isActive());</span>

<span class="fc" id="L2628">        _stream._save_points.savePointPopActive(sp);</span>
<span class="fc" id="L2629">        _line_count = sp.getPrevLineNumber();</span>
<span class="fc" id="L2630">        _line_starting_position = sp.getPrevLineStart();</span>
<span class="fc" id="L2631">    }</span>

    protected final void error(String message)
    {
<span class="fc" id="L2635">        String message2 = message + input_position();</span>
<span class="fc" id="L2636">        throw new IonReaderTextTokenException(message2);</span>
    }
    protected final void unexpected_eof()
    {
<span class="fc" id="L2640">        String message = &quot;unexpected EOF encountered &quot;+input_position();</span>
<span class="fc" id="L2641">        throw new UnexpectedEofException(message);</span>
    }
    protected final void bad_escape_sequence()
    {
<span class="nc" id="L2645">        String message = &quot;bad escape character encountered &quot;+input_position();</span>
<span class="nc" id="L2646">        throw new IonReaderTextTokenException(message);</span>
    }
    protected final void bad_escape_sequence(int c)
    {
<span class="fc" id="L2650">        String message =</span>
<span class="fc" id="L2651">            &quot;bad escape character '&quot;+printCodePointAsString(c)+</span>
<span class="fc" id="L2652">            &quot;' encountered &quot;+input_position();</span>
<span class="fc" id="L2653">        throw new IonReaderTextTokenException(message);</span>
    }
    protected final void bad_token_start(int c)
    {
<span class="fc" id="L2657">        String message =</span>
<span class="fc" id="L2658">            &quot;bad character [&quot;+c+&quot;, &quot;+printCodePointAsString(c)+</span>
            &quot;] encountered where a token was supposed to start &quot;+
<span class="fc" id="L2660">            input_position();</span>
<span class="fc" id="L2661">        throw new IonReaderTextTokenException(message);</span>
    }
    protected final void bad_token(int c)
    {
<span class="fc" id="L2665">        String charStr = IonTextUtils.printCodePointAsString(c);</span>
<span class="fc" id="L2666">        String message =</span>
<span class="fc" id="L2667">            &quot;a bad character &quot; + charStr + &quot; was encountered &quot;+input_position();</span>
<span class="fc" id="L2668">        throw new IonReaderTextTokenException(message);</span>
    }

    protected final void expected_but_found(String expected, int c)
    {
<span class="fc" id="L2673">        String charStr = IonTextUtils.printCodePointAsString(c);</span>
<span class="fc" id="L2674">        String message =</span>
<span class="fc" id="L2675">            &quot;Expected &quot; + expected + &quot; but found &quot; + charStr + input_position();</span>
<span class="fc" id="L2676">        throw new IonReaderTextTokenException(message);</span>
    }

    static public class IonReaderTextTokenException extends IonException {
        private static final long serialVersionUID = 1L;
        IonReaderTextTokenException(String msg) {
<span class="fc" id="L2682">            super(msg);</span>
<span class="fc" id="L2683">        }</span>
    }

<span class="fc" id="L2686">    private enum ProhibitedCharacters {</span>
<span class="fc" id="L2687">        SHORT_CHAR</span>
        {
            boolean includes(int c)
            {
<span class="fc bfc" id="L2691" title="All 4 branches covered.">                return isControlCharacter(c) &amp;&amp; !isWhitespace(c);</span>
            }
        },

<span class="fc" id="L2695">        LONG_CHAR</span>
        {
            boolean includes(int c)
            {
<span class="fc bfc" id="L2699" title="All 6 branches covered.">                return isControlCharacter(c) &amp;&amp; !isWhitespace(c) &amp;&amp; !isNewline(c);</span>
            }
        },

<span class="fc" id="L2703">        NONE</span>
        {
            boolean includes(int c)
            {
<span class="fc" id="L2707">                return false;</span>
            }
        };

        abstract boolean includes(int c);

        private static boolean isControlCharacter(int c)
        {
<span class="fc bfc" id="L2715" title="All 4 branches covered.">            return c &lt;= 0x1F &amp;&amp; 0x00 &lt;= c;</span>
        }

        private static boolean isNewline(int c)
        {
<span class="fc bfc" id="L2720" title="All 4 branches covered.">            return c == 0x0A || c == 0x0D;</span>
        }

        private static boolean isWhitespace(int c)
        {
<span class="pc bpc" id="L2725" title="1 of 8 branches missed.">            return c == 0x09 // tab</span>
                || c == 0x0B // vertical tab
                || c == 0x0C // form feed
                || c == 0x20 // space
            ;
        }
    }

<span class="pc bpc" id="L2733" title="1 of 2 branches missed.">    private enum Radix</span>
    {
<span class="fc" id="L2735">        BINARY</span>
        {
            boolean isPrefix(int c)
            {
<span class="fc bfc" id="L2739" title="All 4 branches covered.">                return c == 'b' || c == 'B';</span>
            }

            boolean isValidDigit(int c)
            {
<span class="fc" id="L2744">                return IonTokenConstsX.isBinaryDigit(c);</span>
            }

            @Override
            char normalizeDigit(char c)
            {
<span class="fc" id="L2750">                return c; // no normalization required</span>
            }
        },

<span class="fc" id="L2754">        DECIMAL</span>
        {
            boolean isPrefix(int c)
            {
<span class="nc" id="L2758">                return false;</span>
            }

            boolean isValidDigit(int c)
            {
<span class="fc" id="L2763">                return IonTokenConstsX.isDigit(c);</span>
            }

            @Override
            char normalizeDigit(char c)
            {
<span class="fc" id="L2769">                return c; // no normalization required</span>
            }
        },

<span class="fc" id="L2773">        HEX</span>
        {
            boolean isPrefix(int c)
            {
<span class="fc bfc" id="L2777" title="All 4 branches covered.">                return c == 'x' || c == 'X';</span>
            }

            boolean isValidDigit(int c)
            {
<span class="fc" id="L2782">                return IonTokenConstsX.isHexDigit(c);</span>
            }

            @Override
            char normalizeDigit(char c)
            {
<span class="fc" id="L2788">                return Character.toLowerCase(c);</span>
            }
        };

        abstract boolean isPrefix(int c);
        abstract boolean isValidDigit(int c);
        abstract char normalizeDigit(char c);

        void assertPrefix(int c)
        {
<span class="pc bpc" id="L2798" title="2 of 4 branches missed.">            assert isPrefix(c);</span>
<span class="fc" id="L2799">        }</span>
    }

    private int readNumeric(Appendable buffer, Radix radix) throws IOException
    {
<span class="fc" id="L2804">        return readNumeric(buffer, radix, NumericState.START);</span>
    }

    private int readNumeric(Appendable buffer, Radix radix, NumericState startingState) throws IOException
    {
<span class="fc" id="L2809">        NumericState state = startingState;</span>

        for (;;)
        {
<span class="fc" id="L2813">            int c = read_char();</span>
<span class="pc bpc" id="L2814" title="1 of 4 branches missed.">            switch (state)</span>
            {
                case START:
<span class="fc bfc" id="L2817" title="All 2 branches covered.">                    if (radix.isValidDigit(c))</span>
                    {
<span class="fc" id="L2819">                        buffer.append(radix.normalizeDigit((char) c));</span>
<span class="fc" id="L2820">                        state = NumericState.DIGIT;</span>
                    }
                    else
                    {
<span class="fc" id="L2824">                        return c;</span>
                    }
                    break;
                case DIGIT:
<span class="fc bfc" id="L2828" title="All 2 branches covered.">                    if (radix.isValidDigit(c))</span>
                    {
<span class="fc" id="L2830">                        buffer.append(radix.normalizeDigit((char) c));</span>
<span class="fc" id="L2831">                        state = NumericState.DIGIT;</span>
                    }
<span class="fc bfc" id="L2833" title="All 2 branches covered.">                    else if (c == '_')</span>
                    {
<span class="fc" id="L2835">                        state = NumericState.UNDERSCORE;</span>
                    }
                    else
                    {
<span class="fc" id="L2839">                        return c;</span>
                    }
                    break;
                case UNDERSCORE:
<span class="fc bfc" id="L2843" title="All 2 branches covered.">                    if (radix.isValidDigit(c))</span>
                    {
<span class="fc" id="L2845">                        buffer.append(radix.normalizeDigit((char) c));</span>
<span class="fc" id="L2846">                        state = NumericState.DIGIT;</span>
                    }
                    else
                    {
<span class="fc" id="L2850">                        unread_char(c);</span>
<span class="fc" id="L2851">                        return '_';</span>
                    }
                    break;
            }
<span class="fc" id="L2855">        }</span>
    }

<span class="fc" id="L2858">    private enum NumericState</span>
    {
<span class="fc" id="L2860">        START,</span>
<span class="fc" id="L2861">        UNDERSCORE,</span>
<span class="fc" id="L2862">        DIGIT,</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>