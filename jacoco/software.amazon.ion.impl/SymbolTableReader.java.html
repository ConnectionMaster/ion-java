<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SymbolTableReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">SymbolTableReader.java</span></div><h1>SymbolTableReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;


import static software.amazon.ion.SystemSymbols.IMPORTS;
import static software.amazon.ion.SystemSymbols.IMPORTS_SID;
import static software.amazon.ion.SystemSymbols.ION_SHARED_SYMBOL_TABLE;
import static software.amazon.ion.SystemSymbols.ION_SHARED_SYMBOL_TABLE_SID;
import static software.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE;
import static software.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE_SID;
import static software.amazon.ion.SystemSymbols.MAX_ID;
import static software.amazon.ion.SystemSymbols.MAX_ID_SID;
import static software.amazon.ion.SystemSymbols.NAME;
import static software.amazon.ion.SystemSymbols.NAME_SID;
import static software.amazon.ion.SystemSymbols.SYMBOLS;
import static software.amazon.ion.SystemSymbols.SYMBOLS_SID;
import static software.amazon.ion.SystemSymbols.VERSION;
import static software.amazon.ion.SystemSymbols.VERSION_SID;
import static software.amazon.ion.impl.PrivateUtils.newSymbolToken;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import software.amazon.ion.Decimal;
import software.amazon.ion.IntegerSize;
import software.amazon.ion.IonException;
import software.amazon.ion.IonReader;
import software.amazon.ion.IonType;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.Timestamp;

/**
 *   This is a reader that traverses a {@link SymbolTable}
 *   and returns the contents as if the table was serialized
 *   in Ion in a standard fashion (in fact this serialization
 *   defines the &quot;standard fashion&quot;).
 *
 *   This does not support open content in symbol tables and
 *   should.  Support for open content will require additional
 *   data be kept in the {@link SymbolTable}, probably as an
 *   IonStruct or an IonReader or binary buffer.
 *
 *   The reader uses the _state member to track its progress
 *   through the members of the outer struct, the import
 *   list and the symbol list.  It used _idx to track its
 *   progress thought the elements of the import list and
 *   the elements of the symbol list.
 *
 *

    These are the states in a local symbol table:

        &lt;S_BOF&gt;
        &lt;S_STRUCT&gt;
        $ion_symbol_table:: {
          &lt;S_IN_STRUCT&gt;
          &lt;S_MAX_ID&gt;
            max_id:3,
          &lt;S_SYMBOL_LIST&gt;
            symbols:[
          &lt;S_IN_SYMBOLS&gt;
          &lt;S_SYMBOL&gt;
              &quot;symbol1&quot;,
          &lt;S_SYMBOL&gt;
              &quot;symbol2&quot;,
          &lt;S_SYMBOL&gt;
              &quot;symbol3&quot;
          &lt;S_SYMBOL_LIST_CLOSE&gt;
            ]
          &lt;S_STRUCT_CLOSE&gt;
        }
        &lt;S_EOF&gt;

    States for a shared symbol Table:

        &lt;S_BOF&gt;
        &lt;S_STRUCT&gt;
            $ion_shared_symbol_table::{
          &lt;S_IN_STRUCT&gt;
          &lt;S_NAME&gt;
              name:&quot;mySharedTable&quot;,
          &lt;S_VERSION&gt;
              version:1,
          &lt;S_MAX_ID&gt;
              max_id:3,
          &lt;S_IMPORT_LIST&gt;
              imports:[
            &lt;S_IN_IMPORTS&gt;
            &lt;S_IMPORT_STRUCT&gt;
                {
              &lt;S_IN_IMPORT_STRUCT&gt;
              &lt;S_IMPORT_NAME&gt;
                  name:&quot;otherTable&quot;,
              &lt;S_IMPORT_VERSION&gt;
                  version:2,
              &lt;S_IMPORT_MAX_ID&gt;
                  max_id:192
              &lt;S_IMPORT_STRUCT_CLOSE&gt;
                },
            &lt;S_IMPORT_STRUCT&gt;
                {
              &lt;S_IN_IMPORT_STRUCT&gt;
              &lt;S_IMPORT_NAME&gt;
                  name:&quot;yetAnotherTable&quot;,
              &lt;S_IMPORT_VERSION&gt;
                  version:4,
              &lt;S_IMPORT_MAX_ID&gt;
                  max_id:34
              &lt;S_IMPORT_STRUCT_CLOSE&gt;
                },
            &lt;S_IMPORT_LIST_CLOSE&gt;
              ],
          &lt;S_AFTER_IMPORT_LIST&gt;  new
          &lt;S_SYMBOL_LIST&gt;
              symbols:[
            &lt;S_IN_SYMBOLS&gt;
            &lt;S_SYMBOL&gt;
                &quot;symbol1&quot;,
            &lt;S_SYMBOL&gt;
                &quot;symbol2&quot;,
            &lt;S_SYMBOL&gt;
                &quot;symbol3&quot;
            &lt;S_SYMBOL_LIST_CLOSE&gt;
              ]
          &lt;S_STRUCT_CLOSE&gt;
            }
        &lt;S_EOF&gt;


        Version 1.0 system symbol table:

        &lt;S_BOF&gt;
        &lt;S_STRUCT&gt;
            $ion_symbol_table::{
        &lt;S_IN_STRUCT&gt;
        &lt;S_VERSION&gt;
              version:1,
        &lt;S_MAX_ID&gt;
              max_id:9,
        &lt;S_SYMBOL_LIST&gt;
              symbols:[
        &lt;S_IN_SYMBOLS&gt;
        &lt;S_SYMBOL&gt;
            &quot;$ion&quot;,
        &lt;S_SYMBOL&gt;
            &quot;$ion_1_0&quot;,
        &lt;S_SYMBOL&gt;
            &quot;$ion_symbol_table&quot;,
        &lt;S_SYMBOL&gt;
            &quot;name&quot;,
        &lt;S_SYMBOL&gt;
            &quot;version&quot;,
        &lt;S_SYMBOL&gt;
            &quot;imports&quot;,
        &lt;S_SYMBOL&gt;
            &quot;symbols&quot;,
        &lt;S_SYMBOL&gt;
            &quot;max_id&quot;,
        &lt;S_SYMBOL&gt;
            &quot;$ion_shared_symbol_table&quot;
        &lt;S_SYMBOL_LIST_CLOSE&gt;
              ]
        &lt;S_STRUCT_CLOSE&gt;
            }
        &lt;S_EOF&gt;

 */

/*  --------------------------------------------------------------------------------

Notes regarding the various states that may be encountered.
The reader depth is in parenthesis after the name

state                      next()                  stepIn()                stepOut()                     container
------------------------   ---------------------   ---------------------   -------------------------     ---------
S_BOF(0)                 = S_STRUCT              | &lt;error&gt;                | &lt;error&gt;                    |           |

S_STRUCT(0)              = S_EOF                 | S_IN_STRUCT            | &lt;error&gt;                    | true      |

S_IN_STRUCT(1)           = S_NAME (load)         | &lt;error&gt;                | S_EOF                      |           |
            [if no name] : S_VERSION (load)      | &lt;error&gt;                | S_EOF                      |           |
             [if no ver] : S_MAX_ID (load)       | &lt;error&gt;                | S_EOF                      |           |

S_NAME(1)                = S_VERSION (load)      | &lt;error&gt;                | S_EOF                      |           |
             [if no ver] : S_MAX_ID (load)       | &lt;error&gt;                | S_EOF                      |           |

S_VERSION(1)             = S_MAX_ID (load)       | &lt;error&gt;                | S_EOF                      |           |

S_MAX_ID(1)              = S_IMPORT_LIST (load)  | &lt;error&gt;                | S_EOF                      |           |
         [if no imports] : S_SYMBOL_LIST         | &lt;error&gt;                | S_EOF                      |           |
          [if no locals] : S_EOF                 | &lt;error&gt;                | S_EOF                      |           |

S_IMPORT_LIST(1)         = S_SYMBOL_LIST (load)  | S_IN_IMPORTS           | S_EOF                      | true      |
          [if no locals] : S_EOF                 | &lt;error&gt;                | S_EOF                      |           |

S_IN_IMPORTS(2)          = S_IMPORT_STRUCT       | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
    [if no more imports] : S_EOF                 | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
          [if no locals] : -------               | -------                | S_STRUCT_CLOSE             |           |

S_IMPORT_STRUCT(2)       = S_IMPORT_STRUCT       | S_IN_IMPORT_STRUCT     | S_AFTER_IMPORT_LIST (load) | true      |
    [if no more imports] : S_IMPORT_STRUCT_CLOSE | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
          [if no locals] : -------               | -------                | S_STRUCT_CLOSE             |           |

S_IN_IMPORT_STRUCT(3)    = S_IMPORT_NAME (load)  | &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_NAME(3)         = S_IMPORT_VERSION(load)| &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_VERSION(3)      = S_IMPORT_MAX_ID (load)| &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_MAX_ID(3)       = S_IMPORT_STRUCT_CLOSE | &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_STRUCT_CLOSE(3) = S_IMPORT_STRUCT_CLOSE | &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_STRUCT_CLOSE             |           |

S_IMPORT_LIST_CLOSE(2)   = S_IMPORT_LIST_CLOSE   | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
          [if no locals] : S_IMPORT_LIST_CLOSE   | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_AFTER_IMPORT_LIST(1)   = S_SYMBOL_LIST         | &lt;error&gt;                | S_EOF                      |           |

S_SYMBOL_LIST(1)         = S_STRUCT_CLOSE        | S_IN_SYMBOLS           | S_EOF                      | true      |
          [if no locals] : -------               | S_SYMBOL_LIST_CLOSE    | S_EOF                      |           |

S_IN_SYMBOLS(2)          = S_SYMBOL (load)       | &lt;error&gt;                | S_STRUCT_CLOSE             |           |
     [if no more locals] : S_SYMBOL_LIST_CLOSE   | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_SYMBOL(2)              = S_SYMBOL (load)       | &lt;error&gt;                | S_STRUCT_CLOSE             |           |
     [if no more locals] : S_SYMBOL_LIST_CLOSE   | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_SYMBOL_LIST_CLOSE(2)   = S_EOF                 | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_STRUCT_CLOSE(1)        = S_EOF                 | &lt;error&gt;                | S_EOF                      |           |
S_EOF(0)                 = S_EOF                 | &lt;error&gt;                | S_EOF                      |           |


Same list sorted by depth (i.e. by the various sequences that
the reader progresses through to a local or global eof)

state
------------------------
S_BOF(0)                   system
S_STRUCT(0)                required
S_EOF(0)                   system


S_IN_STRUCT(1)             system
S_NAME(1)                  optional   if name not null (or if isLocalSymbolTable == false)
S_VERSION(1)               optional   if version &gt; 0  (or if isLocalSymbolTable == false)
S_MAX_ID(1)                optional   if max_id &gt; 0
S_IMPORT_LIST(1)           optional   if import count &gt; 0
S_AFTER_IMPORT_LIST(1)     optional   if import count &gt; 0 &amp;&amp; local count &gt; 0 (this state exists only after stepOut of the import list)
S_SYMBOL_LIST(1)           optional:  if local count &gt; 0
S_STRUCT_CLOSE(1)          system


S_IN_IMPORTS(2)            system
S_IMPORT_STRUCT(2)         variable   if _imports.hasNext() (import symbol table iterator)
S_IMPORT_LIST_CLOSE(2)     system


S_IN_IMPORT_STRUCT(3)      system
S_IMPORT_NAME(3)           required
S_IMPORT_VERSION(3)        required
S_IMPORT_MAX_ID(3)         required
S_IMPORT_STRUCT_CLOSE(3)   system


S_IN_SYMBOLS(2)            system
S_SYMBOL(2)                variable  if _symbols.hasNext() (local symbol iterator)
S_SYMBOL_LIST_CLOSE(2)     system

*/


<span class="pc bpc" id="L295" title="1 of 2 branches missed.">final class SymbolTableReader</span>
    implements IonReader
{

    /**
     * these are the states of the reader.
     * Each state tells the reader it is
     * just before (or on as you might want
     * to think about it) one of the possible
     * values in the serialized image.
     */
    static final int S_BOF                  =  0;
    static final int S_STRUCT               =  1;
    static final int S_IN_STRUCT            =  2;
    static final int S_NAME                 =  3;
    static final int S_VERSION              =  4;
    static final int S_MAX_ID               =  5;
    static final int S_IMPORT_LIST          =  6;
    static final int S_IN_IMPORTS           =  7;
    static final int S_IMPORT_STRUCT        =  8;
    static final int S_IN_IMPORT_STRUCT     =  9;
    static final int S_IMPORT_NAME          = 10;
    static final int S_IMPORT_VERSION       = 11;
    static final int S_IMPORT_MAX_ID        = 12;
    static final int S_IMPORT_STRUCT_CLOSE  = 13;
    static final int S_IMPORT_LIST_CLOSE    = 14;
    static final int S_AFTER_IMPORT_LIST    = 15;
    static final int S_SYMBOL_LIST          = 16;
    static final int S_IN_SYMBOLS           = 17;
    static final int S_SYMBOL               = 18;
    static final int S_SYMBOL_LIST_CLOSE    = 19;
    static final int S_STRUCT_CLOSE         = 20;
    static final int S_EOF                  = 21;

    private final static String get_state_name(int state)
    {
<span class="nc bnc" id="L331" title="All 23 branches missed.">        switch (state) {</span>
<span class="nc" id="L332">        case S_BOF:                     return &quot;S_BOF&quot;;</span>
<span class="nc" id="L333">        case S_STRUCT:                  return &quot;S_STRUCT&quot;;</span>
<span class="nc" id="L334">        case S_IN_STRUCT:               return &quot;S_IN_STRUCT&quot;;</span>
<span class="nc" id="L335">        case S_NAME:                    return &quot;S_NAME&quot;;</span>
<span class="nc" id="L336">        case S_VERSION:                 return &quot;S_VERSION&quot;;</span>
<span class="nc" id="L337">        case S_MAX_ID:                  return &quot;S_MAX_ID&quot;;</span>
<span class="nc" id="L338">        case S_IMPORT_LIST:             return &quot;S_IMPORT_LIST&quot;;</span>
<span class="nc" id="L339">        case S_IN_IMPORTS:              return &quot;S_IN_IMPORTS&quot;;</span>
<span class="nc" id="L340">        case S_IMPORT_STRUCT:           return &quot;S_IMPORT_STRUCT&quot;;</span>
<span class="nc" id="L341">        case S_IN_IMPORT_STRUCT:        return &quot;S_IN_IMPORT_STRUCT&quot;;</span>
<span class="nc" id="L342">        case S_IMPORT_NAME:             return &quot;S_IMPORT_NAME&quot;;</span>
<span class="nc" id="L343">        case S_IMPORT_VERSION:          return &quot;S_IMPORT_VERSION&quot;;</span>
<span class="nc" id="L344">        case S_IMPORT_MAX_ID:           return &quot;S_IMPORT_MAX_ID&quot;;</span>
<span class="nc" id="L345">        case S_IMPORT_STRUCT_CLOSE:     return &quot;S_IMPORT_STRUCT_CLOSE&quot;;</span>
<span class="nc" id="L346">        case S_IMPORT_LIST_CLOSE:       return &quot;S_IMPORT_LIST_CLOSE&quot;;</span>
<span class="nc" id="L347">        case S_AFTER_IMPORT_LIST:       return &quot;S_AFTER_IMPORT_LIST&quot;;</span>
<span class="nc" id="L348">        case S_SYMBOL_LIST:             return &quot;S_SYMBOL_LIST&quot;;</span>
<span class="nc" id="L349">        case S_IN_SYMBOLS:              return &quot;S_IN_SYMBOLS&quot;;</span>
<span class="nc" id="L350">        case S_SYMBOL:                  return &quot;S_SYMBOL&quot;;</span>
<span class="nc" id="L351">        case S_SYMBOL_LIST_CLOSE:       return &quot;S_SYMBOL_LIST_CLOSE&quot;;</span>
<span class="nc" id="L352">        case S_STRUCT_CLOSE:            return &quot;S_STRUCT_CLOSE&quot;;</span>
<span class="nc" id="L353">        case S_EOF:                     return &quot;S_EOF&quot;;</span>
<span class="nc" id="L354">        default:                        return &quot;&lt;Unrecognized state: &quot;+state+&quot;&gt;&quot;;</span>
        }
    }

    static final IonType stateType(int state)
    {
<span class="pc bpc" id="L360" title="11 of 23 branches missed.">        switch (state)</span>
        {
<span class="fc" id="L362">        case S_BOF:                  return null;</span>
<span class="fc" id="L363">        case S_STRUCT:               return IonType.STRUCT;</span>
<span class="nc" id="L364">        case S_IN_STRUCT:            return null;</span>
<span class="fc" id="L365">        case S_NAME:                 return IonType.STRING;</span>
<span class="fc" id="L366">        case S_VERSION:              return IonType.INT;</span>
<span class="nc" id="L367">        case S_MAX_ID:               return IonType.INT;</span>
<span class="fc" id="L368">        case S_IMPORT_LIST:          return IonType.LIST;</span>
<span class="nc" id="L369">        case S_IN_IMPORTS:           return null;</span>
<span class="fc" id="L370">        case S_IMPORT_STRUCT:        return IonType.STRUCT;</span>
<span class="nc" id="L371">        case S_IN_IMPORT_STRUCT:     return null;</span>
<span class="fc" id="L372">        case S_IMPORT_NAME:          return IonType.STRING;</span>
<span class="fc" id="L373">        case S_IMPORT_VERSION:       return IonType.INT;</span>
<span class="fc" id="L374">        case S_IMPORT_MAX_ID:        return IonType.INT;</span>
<span class="nc" id="L375">        case S_IMPORT_STRUCT_CLOSE:  return null;</span>
<span class="nc" id="L376">        case S_IMPORT_LIST_CLOSE:    return null;</span>
<span class="nc" id="L377">        case S_AFTER_IMPORT_LIST:    return null;</span>
<span class="fc" id="L378">        case S_SYMBOL_LIST:          return IonType.LIST;</span>
<span class="nc" id="L379">        case S_IN_SYMBOLS:           return null;</span>
<span class="fc" id="L380">        case S_SYMBOL:               return IonType.STRING;</span>
<span class="nc" id="L381">        case S_SYMBOL_LIST_CLOSE:    return null;</span>
<span class="nc" id="L382">        case S_STRUCT_CLOSE:         return null;</span>
<span class="fc" id="L383">        case S_EOF:                  return null;</span>
        default:
<span class="nc" id="L385">            throwUnrecognizedState(state);</span>
<span class="nc" id="L386">            return null;</span>
        }
    }

    static final int stateDepth(int state)
    {
<span class="pc bpc" id="L392" title="22 of 23 branches missed.">        switch (state)</span>
        {
<span class="fc" id="L394">        case S_BOF:                  return 0;</span>
<span class="nc" id="L395">        case S_STRUCT:               return 0;</span>
<span class="nc" id="L396">        case S_IN_STRUCT:            return 1;</span>
<span class="nc" id="L397">        case S_NAME:                 return 1;</span>
<span class="nc" id="L398">        case S_VERSION:              return 1;</span>
<span class="nc" id="L399">        case S_MAX_ID:               return 1;</span>
<span class="nc" id="L400">        case S_IMPORT_LIST:          return 1;</span>
<span class="nc" id="L401">        case S_IN_IMPORTS:           return 2;</span>
<span class="nc" id="L402">        case S_IMPORT_STRUCT:        return 2;</span>
<span class="nc" id="L403">        case S_IN_IMPORT_STRUCT:     return 3;</span>
<span class="nc" id="L404">        case S_IMPORT_NAME:          return 3;</span>
<span class="nc" id="L405">        case S_IMPORT_VERSION:       return 3;</span>
<span class="nc" id="L406">        case S_IMPORT_MAX_ID:        return 3;</span>
<span class="nc" id="L407">        case S_IMPORT_STRUCT_CLOSE:  return 3;</span>
<span class="nc" id="L408">        case S_IMPORT_LIST_CLOSE:    return 2;</span>
<span class="nc" id="L409">        case S_AFTER_IMPORT_LIST:    return 1;</span>
<span class="nc" id="L410">        case S_SYMBOL_LIST:          return 1;</span>
<span class="nc" id="L411">        case S_IN_SYMBOLS:           return 2;</span>
<span class="nc" id="L412">        case S_SYMBOL:               return 2;</span>
<span class="nc" id="L413">        case S_SYMBOL_LIST_CLOSE:    return 2;</span>
<span class="nc" id="L414">        case S_STRUCT_CLOSE:         return 1;</span>
<span class="nc" id="L415">        case S_EOF:                  return 0;</span>
        default:
<span class="nc" id="L417">            throwUnrecognizedState(state);</span>
<span class="nc" id="L418">            return -1;</span>
        }
    }


    /**
     * these define the bit masked flags used
     * to inform iteration over the optional
     * values that may be present
     */
    private static final int HAS_NAME           = 0x01;
    private static final int HAS_VERSION        = 0x02;
    private static final int HAS_MAX_ID         = 0x04;
    private static final int HAS_IMPORT_LIST    = 0x08;
    private static final int HAS_SYMBOL_LIST    = 0x10;


    /**
     * The symbol table we are reading.
     *
     * We MUST NOT call methods whose value may change! Otherwise there's a
     * thread-safety problem.
     */
    private final SymbolTable _symbol_table;

    private final int _maxId;

    /**
     * _state tracks the progress through the various
     * members, including the substructures in the
     * import list and symbol list.  The previous state
     * is needed when we run into an end of container.
     */
<span class="fc" id="L451">    int _current_state  = S_BOF;</span>

    /**
     * state variables that hold the values referenced
     * by the current reader position.  These are filled
     * in by nextStateDepthFirst() and used by the value
     * getting methods.
     *
     * The iterators are opened when the user steps into
     * one of the two lists (imports and symbols).
     *
     */
    int                          _flags;                  // has name, has ... optional top level values
    String                       _string_value;
    long                         _int_value;
    private SymbolTable[]        _imported_tables;
    private Iterator&lt;SymbolTable&gt; _import_iterator;
    private SymbolTable          _current_import;
    Iterator&lt;String&gt;             _local_symbols;

    public SymbolTableReader(SymbolTable symbol_table)
<span class="fc" id="L472">    {</span>
<span class="fc" id="L473">        _symbol_table = symbol_table;</span>

<span class="fc" id="L475">        synchronized (symbol_table)</span>
        {
<span class="fc" id="L477">            _maxId = symbol_table.getMaxId();</span>
<span class="fc" id="L478">            _local_symbols = symbol_table.iterateDeclaredSymbolNames();</span>
<span class="fc" id="L479">        }</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">        if (symbol_table.isLocalTable() == false) {</span>
<span class="fc" id="L482">            set_flag(HAS_NAME, true);</span>
<span class="fc" id="L483">            set_flag(HAS_VERSION, true);</span>
        }
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        if (_maxId &gt; 0) {</span>
            // FIXME: is this ever true?            set_flag(HAS_MAX_ID, true);
        }
<span class="fc" id="L488">        _imported_tables = _symbol_table.getImportedTables();</span>
<span class="fc bfc" id="L489" title="All 4 branches covered.">        if (_imported_tables != null &amp;&amp; _imported_tables.length != 0) {</span>
<span class="fc" id="L490">            set_flag(HAS_IMPORT_LIST, true);</span>
        }
<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (_symbol_table.getImportedMaxId() &lt; _maxId) {</span>
<span class="fc" id="L493">            set_flag(HAS_SYMBOL_LIST, true);</span>
        }
<span class="fc" id="L495">    }</span>


    /**
     * @return This implementation always returns null.
     */
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
<span class="nc" id="L503">        return null;</span>
    }

    //========================================================================


    private final void set_flag(int flag_bit, boolean flag_state)
    {
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (flag_state) {</span>
<span class="fc" id="L512">            _flags |= flag_bit;</span>
        }
        else {
<span class="nc" id="L515">            _flags &amp;= ~flag_bit;</span>
        }
<span class="fc" id="L517">    }</span>

    private final boolean test_flag(int flag_bit)
    {
<span class="fc bfc" id="L521" title="All 2 branches covered.">        boolean flag_state = (_flags &amp; flag_bit) != 0;</span>
<span class="fc" id="L522">        return flag_state;</span>
    }

    final boolean hasName() {
<span class="fc" id="L526">        boolean flag_state = test_flag(HAS_NAME);</span>
<span class="fc" id="L527">        return flag_state;</span>
    }

    final boolean hasVersion() {
<span class="fc" id="L531">        boolean flag_state = test_flag(HAS_VERSION);</span>
<span class="fc" id="L532">        return flag_state;</span>
    }

    final boolean hasMaxId() {
<span class="fc" id="L536">        boolean flag_state = test_flag(HAS_MAX_ID);</span>
<span class="fc" id="L537">        return flag_state;</span>
    }

    final boolean hasImports() {
<span class="fc" id="L541">        boolean flag_state = test_flag(HAS_IMPORT_LIST);</span>
<span class="fc" id="L542">        return flag_state;</span>
    }

    final boolean hasLocalSymbols() {
<span class="fc" id="L546">        boolean flag_state = test_flag(HAS_SYMBOL_LIST);</span>
<span class="fc" id="L547">        return flag_state;</span>
    }

    private final boolean has_next()
    {
        // this just tells us whether or not we have more
        // value coming at our current scanning depth
<span class="pc bpc" id="L554" title="4 of 17 branches missed.">        switch (_current_state)</span>
        {
        case S_BOF:
            // outer struct always follows
<span class="fc" id="L558">            return true;</span>

        case S_STRUCT:
            // only top level value
<span class="nc" id="L562">            return false;</span>

        case S_IN_STRUCT:
<span class="fc bfc" id="L565" title="All 2 branches covered.">            if (stateFirstInStruct() != S_STRUCT_CLOSE) {</span>
<span class="fc" id="L566">                return true;</span>
            }
<span class="fc" id="L568">            return false;</span>

        case S_NAME:
            // if we have name we have version
<span class="fc" id="L572">            return true;</span>

        case S_VERSION:
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">            if (hasMaxId()) {</span>
<span class="nc" id="L576">                return true;</span>
            }
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            if (stateFollowingMaxId() != S_STRUCT_CLOSE) {</span>
<span class="fc" id="L579">                return true;</span>
            }
<span class="nc" id="L581">            return false;</span>

        case S_MAX_ID:
            // maybe something follows, but not always
<span class="nc bnc" id="L585" title="All 2 branches missed.">            if (stateFollowingMaxId() != S_STRUCT_CLOSE) {</span>
<span class="nc" id="L586">                return true;</span>
            }
<span class="nc" id="L588">            return false;</span>

        case S_IMPORT_LIST:
            // locals are the only thing that might follow imports
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (hasLocalSymbols())  return true;</span>
<span class="nc" id="L593">            return false;</span>

        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
            // we have more if there is
<span class="fc" id="L598">            boolean more_imports = _import_iterator.hasNext();</span>
<span class="fc" id="L599">            return more_imports;</span>

        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_NAME:
            // we always have a name and version
<span class="fc" id="L604">            return true;</span>

        case S_IMPORT_VERSION:
            // we always have a max_id on imports
<span class="fc" id="L608">            return true;</span>

        case S_IMPORT_MAX_ID:
        case S_IMPORT_STRUCT_CLOSE:
<span class="fc" id="L612">            return false;</span>

        case S_IMPORT_LIST_CLOSE:
<span class="fc" id="L615">            return false;</span>

        case S_AFTER_IMPORT_LIST:
            // locals are the only thing that might follow imports
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            if (hasLocalSymbols())  return true;</span>
<span class="nc" id="L620">            return false;</span>

        case S_SYMBOL_LIST:
            // the symbol list is the last member, so it has no &quot;next sibling&quot;
            // but ... just in case we put something after the local symbol list
<span class="pc bpc" id="L625" title="2 of 4 branches missed.">            assert(stateFollowingLocalSymbols() == S_STRUCT_CLOSE);</span>
<span class="fc" id="L626">            return false;</span>

        case S_IN_SYMBOLS:
        case S_SYMBOL:
<span class="fc bfc" id="L630" title="All 2 branches covered.">            if (_local_symbols.hasNext()) return true;</span>
<span class="fc" id="L631">            return false;</span>

        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
            // these are all at the end of their respective containers
<span class="fc" id="L637">            return false;</span>

        default:
<span class="nc" id="L640">            throwUnrecognizedState(_current_state);</span>
<span class="nc" id="L641">            return false;</span>
        }
    }

    private final static void throwUnrecognizedState(int state)
    {
<span class="nc" id="L647">        String message = &quot;Internal error: &quot;</span>
            + &quot;UnifiedSymbolTableReader&quot;
            + &quot; is in an unrecognized state: &quot;
<span class="nc" id="L650">            + get_state_name(state);</span>
<span class="nc" id="L651">        throw new IonException(message);</span>
    }


    // helpers to resolve the existence of a number
    // &quot;follow&quot; states where the answer depends on the
    // details of the symbol table we're reading.

    private final int stateFirstInStruct()
    {
        int new_state;

<span class="fc bfc" id="L663" title="All 2 branches covered.">        if (hasName()) {</span>
<span class="fc" id="L664">            new_state = S_NAME;</span>
        }
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">        else if (hasMaxId()) {</span>
<span class="nc" id="L667">            new_state = S_MAX_ID;</span>
        }
<span class="fc bfc" id="L669" title="All 2 branches covered.">        else if (hasImports()) {</span>
<span class="fc" id="L670">            new_state = S_IMPORT_LIST;</span>
        }
<span class="fc bfc" id="L672" title="All 2 branches covered.">        else if (hasLocalSymbols()) {</span>
<span class="fc" id="L673">            new_state = S_SYMBOL_LIST;</span>
        }
        else {
<span class="fc" id="L676">            new_state = S_STRUCT_CLOSE;</span>
        }
<span class="fc" id="L678">        return new_state;</span>
    }

    private final int stateFollowingMaxId()
    {
        int new_state;

<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if (hasImports()) {</span>
<span class="nc" id="L686">            new_state = S_IMPORT_LIST;</span>
        }
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        else if (hasLocalSymbols()) {</span>
<span class="fc" id="L689">            new_state = S_SYMBOL_LIST;</span>
        }
        else {
<span class="nc" id="L692">            new_state = S_STRUCT_CLOSE;</span>
        }
<span class="fc" id="L694">        return new_state;</span>
    }

    private final int nextImport()
    {
<span class="pc bpc" id="L699" title="2 of 4 branches missed.">        assert(_import_iterator != null);</span>

        int new_state;
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">        if (_import_iterator.hasNext()) {</span>
<span class="fc" id="L703">            _current_import = _import_iterator.next();</span>
<span class="fc" id="L704">            new_state = S_IMPORT_STRUCT;</span>
        }
        else {
            // the import list is empty, so we jump to
            // the close list and null out our current
<span class="nc" id="L709">            _current_import = null;</span>
<span class="nc" id="L710">            new_state = S_IMPORT_LIST_CLOSE;</span>
        }
<span class="fc" id="L712">        return new_state;</span>
    }

<span class="fc" id="L715">    private static enum Op {NEXT, STEPOUT}</span>
    private final int stateFollowingImportList(Op op)
    {
<span class="fc" id="L718">        int new_state = -1;</span>

<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (hasLocalSymbols()) {</span>
<span class="pc bpc" id="L721" title="2 of 3 branches missed.">            switch (op) {</span>
            case NEXT:
<span class="nc" id="L723">                new_state = S_SYMBOL_LIST;</span>
<span class="nc" id="L724">                break;</span>
            case STEPOUT:
<span class="fc" id="L726">                new_state = S_AFTER_IMPORT_LIST;</span>
<span class="fc" id="L727">                break;</span>
            }
        }
        else {
<span class="fc" id="L731">            new_state = S_STRUCT_CLOSE;</span>
        }
<span class="fc" id="L733">        return new_state;</span>
    }

    private final int stateFollowingLocalSymbols()
    {
<span class="fc" id="L738">        return S_STRUCT_CLOSE;</span>
    }

    /**
     * this computes the actual move to the next state
     *
     * It does take into account the existence or absence
     * of various properties, such as the symbol table
     * name which is only present in some symbol tables.
     *
     * This also fills in a variety of current state
     * variables that are used to return correct values
     * by the &quot;get&quot; methods.
     *
     */
    public IonType next()
    {
<span class="fc bfc" id="L755" title="All 2 branches covered.">        if (has_next() == false) {</span>
<span class="fc" id="L756">            return null;</span>
        }
        int new_state;

<span class="pc bpc" id="L760" title="11 of 22 branches missed.">        switch (_current_state)</span>
        {
        case S_BOF:
<span class="fc" id="L763">            new_state = S_STRUCT;</span>
<span class="fc" id="L764">            break;</span>

        case S_STRUCT:
<span class="nc" id="L767">            new_state = S_EOF;</span>
<span class="nc" id="L768">            break;</span>

        case S_IN_STRUCT:
<span class="fc" id="L771">            new_state = stateFirstInStruct();</span>
<span class="fc" id="L772">            loadStateData(new_state);</span>
<span class="fc" id="L773">            break;</span>

        case S_NAME:
<span class="pc bpc" id="L776" title="2 of 4 branches missed.">            assert(hasVersion());</span>
<span class="fc" id="L777">            new_state = S_VERSION;</span>
<span class="fc" id="L778">            loadStateData(new_state);</span>
<span class="fc" id="L779">            break;</span>

        case S_VERSION:
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">            if (hasMaxId()) {</span>
<span class="nc" id="L783">                new_state = S_MAX_ID;</span>
<span class="nc" id="L784">                loadStateData(new_state);</span>
            }
            else {
<span class="fc" id="L787">                new_state = stateFollowingMaxId();</span>
            }
<span class="fc" id="L789">            break;</span>

        case S_MAX_ID:
<span class="nc" id="L792">            new_state = stateFollowingMaxId();</span>
<span class="nc" id="L793">            break;</span>

        case S_IMPORT_LIST:
<span class="nc" id="L796">            new_state = this.stateFollowingImportList(Op.NEXT);</span>
<span class="nc" id="L797">            break;</span>

        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
            // we only need to get the import list once, which we
            // do as we step into the import list, so it should
            // be waiting for us here.
<span class="pc bpc" id="L804" title="2 of 4 branches missed.">            assert(_import_iterator != null);</span>
<span class="fc" id="L805">            new_state = nextImport();</span>
<span class="fc" id="L806">            break;</span>

        case S_IN_IMPORT_STRUCT:
            // shared tables have to have a name
<span class="fc" id="L810">            new_state = S_IMPORT_NAME;</span>
<span class="fc" id="L811">            loadStateData(new_state);</span>
<span class="fc" id="L812">            break;</span>

        case S_IMPORT_NAME:
            // shared tables have to have a version
<span class="fc" id="L816">            new_state = S_IMPORT_VERSION;</span>
<span class="fc" id="L817">            loadStateData(new_state);</span>
<span class="fc" id="L818">            break;</span>

        case S_IMPORT_VERSION:
            // and they also always have a max id - so we set up
            // for it
<span class="fc" id="L823">            new_state = S_IMPORT_MAX_ID;</span>
<span class="fc" id="L824">            loadStateData(new_state);</span>
<span class="fc" id="L825">            break;</span>

        case S_IMPORT_MAX_ID:
<span class="nc" id="L828">            new_state = S_IMPORT_STRUCT_CLOSE;</span>
<span class="nc" id="L829">            break;</span>

        case S_IMPORT_STRUCT_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L833">            new_state = S_IMPORT_STRUCT_CLOSE;</span>
<span class="nc" id="L834">            break;</span>

        case S_IMPORT_LIST_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L838">            new_state = S_IMPORT_LIST_CLOSE;</span>
<span class="nc" id="L839">            break;</span>

        case S_AFTER_IMPORT_LIST:
<span class="pc bpc" id="L842" title="2 of 4 branches missed.">            assert(_symbol_table.getImportedMaxId() &lt; _maxId);</span>
<span class="fc" id="L843">            new_state = S_SYMBOL_LIST;</span>
<span class="fc" id="L844">            break;</span>

        case S_SYMBOL_LIST:
<span class="nc bnc" id="L847" title="All 4 branches missed.">            assert(_symbol_table.getImportedMaxId() &lt; _maxId);</span>
<span class="nc" id="L848">            new_state = stateFollowingLocalSymbols();</span>
<span class="nc" id="L849">            break;</span>

        case S_IN_SYMBOLS:
            // we have some symbols - so we'll set up to read them,
            // which we *have* to do once and *need* to do only once.
<span class="pc bpc" id="L854" title="2 of 4 branches missed.">            assert(_local_symbols != null);</span>
            // since we only get into the symbol list if
            // there are some symbols - our next state
            // is at the first symbol
<span class="pc bpc" id="L858" title="2 of 4 branches missed.">            assert(_local_symbols.hasNext() == true);</span>
            // so we just fall through to and let the S_SYMBOL
            // state do it's thing (which it will do every time
            // we move to the next symbol)
        case S_SYMBOL:
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">            if (_local_symbols.hasNext())</span>
            {
<span class="fc" id="L865">                _string_value = _local_symbols.next();</span>
                // null means this symbol isn't defined
<span class="fc" id="L867">                new_state = S_SYMBOL;</span>
            }
            else {
<span class="nc" id="L870">                new_state = S_SYMBOL_LIST_CLOSE;</span>
            }
<span class="nc" id="L872">            break;</span>

        case S_SYMBOL_LIST_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L876">            new_state = S_SYMBOL_LIST_CLOSE;</span>
<span class="nc" id="L877">            break;</span>

        case S_STRUCT_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L881">            new_state = S_STRUCT_CLOSE;</span>
<span class="nc" id="L882">            break;</span>

        case S_EOF:
<span class="nc" id="L885">            new_state = S_EOF;</span>
<span class="nc" id="L886">            break;</span>

        default:
<span class="nc" id="L889">            throwUnrecognizedState(_current_state);</span>
<span class="nc" id="L890">            new_state = -1;</span>
            break;
        }

<span class="fc" id="L894">        _current_state = new_state;</span>
<span class="fc" id="L895">        return stateType(_current_state);</span>
    }


    private final void loadStateData(int new_state)
    {
<span class="pc bpc" id="L901" title="2 of 8 branches missed.">        switch(new_state) {</span>
        case S_NAME:
<span class="pc bpc" id="L903" title="2 of 4 branches missed.">            assert(hasName());</span>
<span class="fc" id="L904">            String name = _symbol_table.getName();</span>
<span class="fc" id="L905">            _string_value = name;</span>
<span class="pc bpc" id="L906" title="2 of 4 branches missed.">            assert(_string_value != null);</span>
            break;

        case S_VERSION:
<span class="fc" id="L910">            int value = _symbol_table.getVersion();</span>
<span class="fc" id="L911">            _int_value = value;</span>
<span class="pc bpc" id="L912" title="2 of 4 branches missed.">            assert(value != 0);</span>
            break;

        case S_MAX_ID:
<span class="nc" id="L916">            _int_value = _maxId;</span>
<span class="nc" id="L917">            break;</span>

        case S_IMPORT_LIST:
        case S_SYMBOL_LIST:
            // no op to simplify the initial fields logic in next()
<span class="fc" id="L922">            break;</span>

        case S_IMPORT_NAME:
<span class="pc bpc" id="L925" title="2 of 4 branches missed.">            assert(_current_import != null);</span>
<span class="fc" id="L926">            _string_value = _current_import.getName();</span>
<span class="fc" id="L927">            break;</span>

        case S_IMPORT_VERSION:
            // shared tables have to have a version
<span class="fc" id="L931">            _string_value = null;</span>
<span class="fc" id="L932">            _int_value = _current_import.getVersion();</span>
<span class="fc" id="L933">            break;</span>

        case S_IMPORT_MAX_ID:
            // and they also always have a max id - so we set up
            // for it
<span class="fc" id="L938">            _int_value = _current_import.getMaxId();</span>
<span class="fc" id="L939">            break;</span>

        default:
<span class="nc" id="L942">            String message = &quot;UnifiedSymbolTableReader in state &quot;</span>
<span class="nc" id="L943">                           + SymbolTableReader.get_state_name(new_state)</span>
                           + &quot; has no state to load.&quot;;
<span class="nc" id="L945">            throw new IonException(message);</span>
        }
<span class="fc" id="L947">    }</span>

    public void stepIn()
    {
        int new_state;

<span class="pc bpc" id="L953" title="1 of 5 branches missed.">        switch (_current_state) {</span>
        case S_STRUCT:
<span class="fc" id="L955">            new_state = S_IN_STRUCT;</span>
<span class="fc" id="L956">            break;</span>
        case S_IMPORT_LIST:
<span class="fc" id="L958">            _import_iterator = Arrays.asList(_imported_tables).iterator();</span>
<span class="fc" id="L959">            new_state = S_IN_IMPORTS;</span>
<span class="fc" id="L960">            break;</span>
        case S_IMPORT_STRUCT:
<span class="pc bpc" id="L962" title="2 of 4 branches missed.">            assert(_current_import != null);</span>
<span class="fc" id="L963">            new_state = S_IN_IMPORT_STRUCT;</span>
<span class="fc" id="L964">            break;</span>
        case S_SYMBOL_LIST:
<span class="fc" id="L966">            new_state = S_IN_SYMBOLS;</span>
<span class="fc" id="L967">            break;</span>
        default:
<span class="nc" id="L969">            throw new IllegalStateException(&quot;current value is not a container&quot;);</span>
        }

<span class="fc" id="L972">        _current_state = new_state;</span>
<span class="fc" id="L973">        return;</span>
    }

    public void stepOut()
    {
<span class="fc" id="L978">        int new_state = -1;</span>

<span class="pc bpc" id="L980" title="1 of 5 branches missed.">        switch (_current_state) {</span>
            case S_IN_STRUCT:
            case S_NAME:
            case S_VERSION:
            case S_MAX_ID:
            case S_IMPORT_LIST:
            case S_AFTER_IMPORT_LIST:
            case S_SYMBOL_LIST:
            case S_STRUCT_CLOSE:
                // these are all top level so stepOut()
                // ends up at the end of our data
<span class="fc" id="L991">                new_state = S_EOF;</span>
<span class="fc" id="L992">                break;</span>

            case S_IN_IMPORTS:
            case S_IMPORT_STRUCT:
            case S_IMPORT_LIST_CLOSE:
                // if we're outside a struct, and we're in the import
                // list stepOut will be whatever follows the import list
                // close and we're done with these
<span class="fc" id="L1000">                _current_import = null;</span>
<span class="fc" id="L1001">                _import_iterator = null;</span>
<span class="fc" id="L1002">                new_state = stateFollowingImportList(Op.STEPOUT);</span>
<span class="fc" id="L1003">                break;</span>

            case S_IN_IMPORT_STRUCT:
            case S_IMPORT_NAME:
            case S_IMPORT_VERSION:
            case S_IMPORT_MAX_ID:
            case S_IMPORT_STRUCT_CLOSE:
                // if there is a next import the next state
                // will be its struct open
                // otherwise next will be the list close
<span class="fc bfc" id="L1013" title="All 2 branches covered.">                if (_import_iterator.hasNext()) {</span>
<span class="fc" id="L1014">                    new_state = S_IMPORT_STRUCT;</span>
                }
                else {
<span class="fc" id="L1017">                    new_state = S_IMPORT_LIST_CLOSE;</span>
                }
<span class="fc" id="L1019">                break;</span>

            case S_IN_SYMBOLS:
            case S_SYMBOL:
            case S_SYMBOL_LIST_CLOSE:
                // I think this is just S_EOF, but if we ever
                // put anything after the symbol list this
                // will need to be updated.  And we're done
                // with our local symbol references.
<span class="fc" id="L1028">                _string_value = null;</span>
<span class="fc" id="L1029">                _local_symbols = null;</span>
<span class="fc" id="L1030">                new_state = stateFollowingLocalSymbols();</span>
<span class="fc" id="L1031">                break;</span>

            default:
<span class="nc" id="L1034">                throw new IllegalStateException(&quot;current value is not in a container&quot;);</span>
        }

<span class="fc" id="L1037">        _current_state = new_state;</span>
<span class="fc" id="L1038">        return;</span>
    }

    public int getDepth()
    {
<span class="fc" id="L1043">        return stateDepth(_current_state);</span>
    }

    public SymbolTable getSymbolTable()
    {
        // TODO: this should return a system symbol table
        //       but, for now, we don't really know which
        //       one to return;
        //
        // UnifiedSymbolTable.makeSystemSymbolTable(_sys, _version);
        //
        // although, with this reader in place we should be
        // able to cons one up without a system
<span class="nc" id="L1056">        return null;</span>
    }

    public IonType getType()
    {
<span class="fc" id="L1061">        return stateType(_current_state);</span>
    }


    public String[] getTypeAnnotations()
    {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if (_current_state == S_STRUCT) {</span>
            // Must return a new array each time to prevent user from changing it
<span class="nc bnc" id="L1069" title="All 4 branches missed.">            if (_symbol_table.isLocalTable() || _symbol_table.isSystemTable())</span>
            {
<span class="nc" id="L1071">                return new String[] { ION_SYMBOL_TABLE };</span>
            }
<span class="nc" id="L1073">            return new String[] { ION_SHARED_SYMBOL_TABLE };</span>
        }
<span class="nc" id="L1075">        return PrivateUtils.EMPTY_STRING_ARRAY;</span>
    }

<span class="fc" id="L1078">    private static final SymbolToken ION_SYMBOL_TABLE_SYM =</span>
<span class="fc" id="L1079">        newSymbolToken(ION_SYMBOL_TABLE, ION_SYMBOL_TABLE_SID);</span>

<span class="fc" id="L1081">    private static final SymbolToken ION_SHARED_SYMBOL_TABLE_SYM =</span>
<span class="fc" id="L1082">        newSymbolToken(ION_SHARED_SYMBOL_TABLE, ION_SHARED_SYMBOL_TABLE_SID);</span>

    public SymbolToken[] getTypeAnnotationSymbols()
    {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (_current_state == S_STRUCT) {</span>
            SymbolToken sym;
<span class="pc bpc" id="L1088" title="1 of 4 branches missed.">            if (_symbol_table.isLocalTable() || _symbol_table.isSystemTable())</span>
            {
<span class="fc" id="L1090">                sym = ION_SYMBOL_TABLE_SYM;</span>
            }
            else
            {
<span class="fc" id="L1094">                sym = ION_SHARED_SYMBOL_TABLE_SYM;</span>
            }

            // Must return a new array each time to prevent user from changing it
<span class="fc" id="L1098">            return new SymbolToken[] { sym };</span>
        }
<span class="fc" id="L1100">        return SymbolToken.EMPTY_ARRAY;</span>
    }


    public Iterator&lt;String&gt; iterateTypeAnnotations()
    {
<span class="nc" id="L1106">        String[] annotations = getTypeAnnotations();</span>
<span class="nc" id="L1107">        return PrivateUtils.stringIterator(annotations);</span>
    }

    public String getFieldName()
    {
<span class="pc bpc" id="L1112" title="5 of 7 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_STRUCT:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_STRUCT_CLOSE:
        case S_IMPORT_LIST_CLOSE:
        case S_AFTER_IMPORT_LIST:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
<span class="nc" id="L1127">            return null;</span>

        case S_NAME:
        case S_IMPORT_NAME:
<span class="nc" id="L1131">            return NAME;</span>

        case S_VERSION:
        case S_IMPORT_VERSION:
<span class="nc" id="L1135">            return VERSION;</span>

        case S_MAX_ID:
        case S_IMPORT_MAX_ID:
<span class="nc" id="L1139">            return MAX_ID;</span>

        case S_IMPORT_LIST:
<span class="fc" id="L1142">            return IMPORTS;</span>

        case S_SYMBOL_LIST:
<span class="fc" id="L1145">            return SYMBOLS;</span>

        default:
<span class="nc" id="L1148">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public SymbolToken getFieldNameSymbol()
    {
<span class="pc bpc" id="L1154" title="1 of 7 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_STRUCT:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_STRUCT_CLOSE:
        case S_IMPORT_LIST_CLOSE:
        case S_AFTER_IMPORT_LIST:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
<span class="fc" id="L1169">            return null;</span>

        case S_NAME:
        case S_IMPORT_NAME:
<span class="fc" id="L1173">            return new SymbolTokenImpl(NAME, NAME_SID);</span>

        case S_VERSION:
        case S_IMPORT_VERSION:
<span class="fc" id="L1177">            return new SymbolTokenImpl(VERSION, VERSION_SID);</span>

        case S_MAX_ID:
        case S_IMPORT_MAX_ID:
<span class="fc" id="L1181">            return new SymbolTokenImpl(MAX_ID, MAX_ID_SID);</span>

        case S_IMPORT_LIST:
<span class="fc" id="L1184">            return new SymbolTokenImpl(IMPORTS, IMPORTS_SID);</span>

        case S_SYMBOL_LIST:
<span class="fc" id="L1187">            return new SymbolTokenImpl(SYMBOLS, SYMBOLS_SID);</span>

        default:
<span class="nc" id="L1190">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public boolean isNullValue()
    {
<span class="pc bpc" id="L1196" title="1 of 3 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_STRUCT:
        case S_NAME:
        case S_VERSION:
        case S_MAX_ID:
        case S_IMPORT_LIST:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_NAME:
        case S_IMPORT_VERSION:
        case S_IMPORT_MAX_ID:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
            // these values are either present and non-null
            // or entirely absent (in which case they will
            // have been skipped and we won't be in a state
            // to return them).
<span class="fc" id="L1216">            return false;</span>

        case S_IMPORT_STRUCT_CLOSE:
        case S_IMPORT_LIST_CLOSE:
        case S_AFTER_IMPORT_LIST:
        case S_SYMBOL_LIST:
        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
            // here we're not really on a value, so we're not
            // on a value that is a null - so false again.
<span class="fc" id="L1227">            return false;</span>

        default:
<span class="nc" id="L1230">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public boolean isInStruct()
    {
<span class="nc bnc" id="L1236" title="All 5 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
            // these values are either not contained, or
            // contained in a list.  So we aren't in a
            // struct if they're pending.
<span class="nc" id="L1246">            return false;</span>

        case S_IN_STRUCT:
        case S_NAME:
        case S_VERSION:
        case S_MAX_ID:
        case S_IMPORT_LIST:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_NAME:
        case S_IMPORT_VERSION:
        case S_IMPORT_MAX_ID:
        case S_AFTER_IMPORT_LIST:
        case S_SYMBOL_LIST:
            // the values above are all members
            // of a struct, so we must be in a
            // struct to have them pending
<span class="nc" id="L1262">            return true;</span>

        case S_IMPORT_STRUCT_CLOSE:
        case S_STRUCT_CLOSE:
            // if we're closing a struct we're in a struct
<span class="nc" id="L1267">            return true;</span>

        case S_IMPORT_LIST_CLOSE:
        case S_SYMBOL_LIST_CLOSE:
        case S_EOF:
            // if we're closing a list we in a list, not a struct
            // and EOF is not in a struct
<span class="nc" id="L1274">            return false;</span>

        default:
<span class="nc" id="L1277">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public boolean booleanValue()
    {
<span class="nc" id="L1283">        throw new IllegalStateException(&quot;only valid if the value is a boolean&quot;);</span>
    }

    public int intValue()
    {
<span class="fc" id="L1288">        return (int)_int_value;</span>
    }

    public long longValue()
    {
<span class="nc" id="L1293">        return _int_value;</span>
    }

    public BigInteger bigIntegerValue()
    {
<span class="fc" id="L1298">        String value = Long .toString(_int_value);</span>
<span class="fc" id="L1299">        BigInteger bi = new BigInteger(value);     // this is SOOOOO broken &lt;sigh&gt;</span>
<span class="fc" id="L1300">        return bi;</span>
    }

    public double doubleValue()
    {
<span class="nc" id="L1305">        throw new IllegalStateException(&quot;only valid if the value is a double&quot;);</span>
    }

    public BigDecimal bigDecimalValue()
    {
<span class="nc" id="L1310">        throw new IllegalStateException(&quot;only valid if the value is a decimal&quot;);    }</span>

    public Decimal decimalValue()
    {
<span class="nc" id="L1314">        throw new IllegalStateException(&quot;only valid if the value is a decimal&quot;);</span>
    }

    public Date dateValue()
    {
<span class="nc" id="L1319">        throw new IllegalStateException(&quot;only valid if the value is a timestamp&quot;);</span>
    }

    public Timestamp timestampValue()
    {
<span class="nc" id="L1324">        throw new IllegalStateException(&quot;only valid if the value is a timestamp&quot;);</span>
    }

    public String stringValue()
    {
<span class="fc" id="L1329">        return _string_value;</span>
    }

    public SymbolToken symbolValue()
    {
        // TODO handle null
<span class="nc" id="L1335">        throw new UnsupportedOperationException();</span>
    }

    public int getBytes(byte[] buffer, int offset, int len)
    {
<span class="nc" id="L1340">        throw new IllegalStateException(&quot;getBytes() is only valid if the reader is on a lob value, not a &quot;+stateType(_current_state)+&quot; value&quot;);</span>
    }

    public int byteSize()
    {
<span class="nc" id="L1345">        throw new IllegalStateException(&quot;byteSize() is only valid if the reader is on a lob value, not a &quot;+stateType(_current_state)+&quot; value&quot;);</span>
    }

    public byte[] newBytes()
    {
<span class="nc" id="L1350">        throw new IllegalStateException(&quot;newBytes() is only valid if the reader is on a lob value, not a &quot;+stateType(_current_state)+&quot; value&quot;);</span>
    }

    public void close() throws IOException
    {
<span class="nc" id="L1355">        _current_state = S_EOF;</span>
<span class="nc" id="L1356">    }</span>

    public IntegerSize getIntegerSize()
    {
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">        if (stateType(_current_state) != IonType.INT)</span>
        {
<span class="nc" id="L1362">            return null;</span>
        }
<span class="fc" id="L1364">        return IntegerSize.INT; // all of SymbolTable's integers are type int</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>