<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderTreeUserX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderTreeUserX.java</span></div><h1>IonReaderTreeUserX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2010-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static software.amazon.ion.SystemSymbols.ION_1_0_SID;
import static software.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE;

import software.amazon.ion.IonCatalog;
import software.amazon.ion.IonDatagram;
import software.amazon.ion.IonReader;
import software.amazon.ion.IonStruct;
import software.amazon.ion.IonSymbol;
import software.amazon.ion.IonType;
import software.amazon.ion.IonValue;
import software.amazon.ion.SeekableReader;
import software.amazon.ion.Span;
import software.amazon.ion.SpanProvider;
import software.amazon.ion.SymbolTable;

<span class="pc bpc" id="L33" title="1 of 2 branches missed.">final class IonReaderTreeUserX</span>
    extends IonReaderTreeSystem
    implements PrivateReaderWriter
{

    private final PrivateLocalSymbolTableFactory _lstFactory;

    IonCatalog _catalog;
    private SymbolTable _symbols;

    public IonReaderTreeUserX(IonValue value, IonCatalog catalog, PrivateLocalSymbolTableFactory lstFactory)
    {
<span class="fc" id="L45">        super(value); // calls re_init</span>
<span class="fc" id="L46">        _catalog = catalog;</span>
<span class="fc" id="L47">        _lstFactory = lstFactory;</span>
<span class="fc" id="L48">    }</span>

    @Override
    void re_init(IonValue value, boolean hoisted)
    {
<span class="fc" id="L53">        super.re_init(value, hoisted);</span>
<span class="fc" id="L54">        _symbols = _system_symtab;</span>
<span class="fc" id="L55">    }</span>

    //========================================================================

    @Override
    public SymbolTable getSymbolTable()
    {
<span class="fc" id="L62">        return _symbols;</span>
    }

    @Override
    public IonType next()
    {
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (!next_helper_user()) {</span>
<span class="fc" id="L69">            this._curr = null;</span>
<span class="fc" id="L70">            return null;</span>
        }
<span class="fc" id="L72">        this._curr = this._next;</span>
<span class="fc" id="L73">        this._next = null;</span>
<span class="fc" id="L74">        return this._curr.getType();</span>
    }

    private boolean next_helper_user()
    {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (_eof) return false;</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (_next != null) return true;</span>

<span class="fc" id="L82">        clear_system_value_stack();</span>

        // read values from the system
        // reader and if they are system values
        // process them.  Return when we've
        // read all the immediate system values
        IonType next_type;
        for (;;) {
<span class="fc" id="L90">            next_type = next_helper_system();</span>

<span class="fc bfc" id="L92" title="All 4 branches covered.">            if (_top == 0 &amp;&amp; _parent instanceof IonDatagram) {</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                if (IonType.SYMBOL.equals(next_type)) {</span>
<span class="pc bpc" id="L94" title="2 of 4 branches missed.">                    assert(_next instanceof IonSymbol);</span>
<span class="fc" id="L95">                    IonSymbol sym = (IonSymbol)_next;</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">                    if (sym.isNullValue()) {</span>
                        // there are no null values we will consume here
<span class="fc" id="L98">                        break;</span>
                    }
<span class="fc" id="L100">                    int sid = sym.symbolValue().getSid();</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">                    if (sid == UNKNOWN_SYMBOL_ID) {</span>
<span class="fc" id="L102">                        String name = sym.stringValue();</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">                        if (name != null) {</span>
<span class="fc" id="L104">                            sid = _system_symtab.findSymbol(name);</span>
                        }
                    }
<span class="fc bfc" id="L107" title="All 2 branches covered.">                    if (sid == ION_1_0_SID</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">                        &amp;&amp; _next.getTypeAnnotationSymbols().length == 0) {</span>
                        // $ion_1_0 is read as an IVM only if it is not annotated
<span class="fc" id="L110">                        SymbolTable symbols = _system_symtab;</span>
<span class="fc" id="L111">                        _symbols = symbols;</span>
<span class="fc" id="L112">                        push_symbol_table(symbols);</span>
<span class="fc" id="L113">                        _next = null;</span>
<span class="fc" id="L114">                        continue;</span>
                    }
<span class="fc" id="L116">                }</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">                else if (IonType.STRUCT.equals(next_type)</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">                      &amp;&amp; _next.findTypeAnnotation(ION_SYMBOL_TABLE) == 0</span>
                ) {
<span class="pc bpc" id="L120" title="2 of 4 branches missed.">                    assert(_next instanceof IonStruct);</span>
                    // read a local symbol table
<span class="fc" id="L122">                    IonReader reader = new IonReaderTreeUserX(_next, _catalog, _lstFactory);</span>
<span class="fc" id="L123">                    SymbolTable symtab = _lstFactory.newLocalSymtab(_catalog, reader, false);</span>
<span class="fc" id="L124">                    _symbols = symtab;</span>
<span class="fc" id="L125">                    push_symbol_table(symtab);</span>
<span class="fc" id="L126">                    _next = null;</span>
<span class="fc" id="L127">                    continue;</span>
                }
            }
            // if we get here we didn't process a system
            // value, if we had we would have 'continue'd
            // so this is a value the user gets
            break;
        }
<span class="fc bfc" id="L135" title="All 2 branches covered.">        return (next_type != null);</span>
    }
    //
    //  This code handles the skipped symbol table
    //  support - it is cloned in IonReaderTextUserX
    //  and IonReaderBinaryUserX
    //
    //  SO ANY FIXES HERE WILL BE NEEDED IN THOSE
    //  TWO LOCATIONS AS WELL.
    //
<span class="fc" id="L145">    private int _symbol_table_top = 0;</span>
<span class="fc" id="L146">    private SymbolTable[] _symbol_table_stack = new SymbolTable[3]; // 3 is rare, IVM followed by a local sym tab with open content</span>
    private void clear_system_value_stack()
    {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        while (_symbol_table_top &gt; 0) {</span>
<span class="fc" id="L150">            _symbol_table_top--;</span>
<span class="fc" id="L151">            _symbol_table_stack[_symbol_table_top] = null;</span>
        }
<span class="fc" id="L153">    }</span>
    private void push_symbol_table(SymbolTable symbols)
    {
<span class="pc bpc" id="L156" title="2 of 4 branches missed.">        assert(symbols != null);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (_symbol_table_top &gt;= _symbol_table_stack.length) {</span>
<span class="nc" id="L158">            int new_len = _symbol_table_stack.length * 2;</span>
<span class="nc" id="L159">            SymbolTable[] temp = new SymbolTable[new_len];</span>
<span class="nc" id="L160">            System.arraycopy(_symbol_table_stack, 0, temp, 0, _symbol_table_stack.length);</span>
<span class="nc" id="L161">            _symbol_table_stack = temp;</span>
        }
<span class="fc" id="L163">        _symbol_table_stack[_symbol_table_top++] = symbols;</span>
<span class="fc" id="L164">    }</span>
    public SymbolTable pop_passed_symbol_table()
    {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (_symbol_table_top &lt;= 0) {</span>
<span class="fc" id="L168">            return null;</span>
        }
<span class="fc" id="L170">        _symbol_table_top--;</span>
<span class="fc" id="L171">        SymbolTable symbols = _symbol_table_stack[_symbol_table_top];</span>
<span class="fc" id="L172">        _symbol_table_stack[_symbol_table_top] = null;</span>
<span class="fc" id="L173">        return symbols;</span>
    }


    private static final class TreeSpan
        extends DowncastingFaceted
        implements Span
    {
        IonValue _value;
    }

    private final Span currentSpanImpl()
    {
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (this._curr == null) {</span>
<span class="fc" id="L187">            throw new IllegalStateException(&quot;Reader has no current value&quot;);</span>
        }

<span class="fc" id="L190">        TreeSpan span = new TreeSpan();</span>
<span class="fc" id="L191">        span._value = this._curr;</span>

<span class="fc" id="L193">        return span;</span>
    }


    private void hoistImpl(Span span)
    {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (span instanceof TreeSpan) {</span>
<span class="fc" id="L200">            TreeSpan treeSpan = (TreeSpan)span;</span>
<span class="fc" id="L201">            this.re_init(treeSpan._value, /* hoisted */ true);</span>
<span class="fc" id="L202">        }</span>
        else {
            // TODO custom exception
<span class="nc" id="L205">            throw new IllegalArgumentException(&quot;Span not appropriate for this reader&quot;);</span>
        }
<span class="fc" id="L207">    }</span>


    //========================================================================
    // Facet support


    @Override
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
<span class="fc bfc" id="L217" title="All 4 branches covered.">        if ((facetType == SeekableReader.class) ||</span>
            (facetType == SpanProvider.class))
        {
<span class="fc" id="L220">            return facetType.cast(new SeekableReaderFacet());</span>
        }

<span class="fc" id="L223">        return super.asFacet(facetType);</span>
    }


<span class="fc" id="L227">    private class SeekableReaderFacet implements SeekableReader</span>
    {
        public Span currentSpan()
        {
<span class="fc" id="L231">            return currentSpanImpl();</span>
        }

        public void hoist(Span span)
        {
<span class="fc" id="L236">            hoistImpl(span);</span>
<span class="fc" id="L237">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>