<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonDatagramLite.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl.lite</a> &gt; <span class="el_source">IonDatagramLite.java</span></div><h1>IonDatagramLite.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2010-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl.lite;

import static software.amazon.ion.SystemSymbols.ION_1_0;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import software.amazon.ion.ContainedValueException;
import software.amazon.ion.IonCatalog;
import software.amazon.ion.IonDatagram;
import software.amazon.ion.IonException;
import software.amazon.ion.IonSymbol;
import software.amazon.ion.IonSystem;
import software.amazon.ion.IonType;
import software.amazon.ion.IonValue;
import software.amazon.ion.IonWriter;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.SystemSymbols;
import software.amazon.ion.ValueFactory;
import software.amazon.ion.ValueVisitor;
import software.amazon.ion.impl.PrivateCurriedValueFactory;
import software.amazon.ion.impl.PrivateIonDatagram;
import software.amazon.ion.impl.PrivateUtils;

/**
 *  The datagram generally behaves as an IonSexp. A list with space
 *  separated values.
 *
 *  As a user datagram it only shows user values as current members
 *  of the list.
 *
 *  As a system datagram it also includes system values (adding Ion
 *  version marker symbols and local symbol tables to the list).
 *
 *  Most API's operate on the user view.  The exceptions are getBytes
 *  (and related), and the system* API's.  These synthesize a system
 *  view over the user values.
 *
 *  When system values are added they translate into setsymboltableat
 *  operations.  Which sets a pending symbol table at the current
 *  user position (as specified by the add pos).  When the next add
 *  occurs if it is at the specified position the pending symbol
 *  table is applied to the value if the value doesn't already have
 *  a local symbol table defined.
 *
 *  in any event any membership update invalidates the pending symbol
 *  table.
 *
 *  In general on add if there is no pending symbol table the preceding
 *  value local symbol table is applied as the local symbol table to
 *  the new value, if it needs one.
 *
 *  The system iterator inserts system values to create the minimum
 *  additional values to represent a correct Ion sequence by injecting
 *  IVM's when the symbol table transitions to system, and local
 *  symbol tables when they first occur.
 *
 */

<span class="pc bpc" id="L78" title="1 of 2 branches missed.">final class IonDatagramLite</span>
    extends IonSequenceLite
    implements IonDatagram, IonContext, PrivateIonDatagram
{

<span class="fc" id="L83">    private static final int HASH_SIGNATURE =</span>
<span class="fc" id="L84">        IonType.DATAGRAM.toString().hashCode();</span>

    private final IonSystemLite      _system;
    private final IonCatalog         _catalog;
    private       SymbolTable        _pending_symbol_table;
    private       int                _pending_symbol_table_idx;
    private       IonSymbolLite      _ivm;

    // Default buffer size for ReverseBinaryEncoder - SYNC'ed with
    // BlockedBuffer._defaultBlockSizeMin (4 kb)
    private static final int REVERSE_BINARY_ENCODER_INITIAL_SIZE = 4096 * 8;

    IonDatagramLite(IonSystemLite system, IonCatalog catalog) {
<span class="fc" id="L97">        super(ContainerlessContext.wrap(system), false);</span>
<span class="fc" id="L98">        _system = system;</span>
<span class="fc" id="L99">        _catalog = catalog;</span>
<span class="fc" id="L100">        _pending_symbol_table_idx = -1;</span>
<span class="fc" id="L101">    }</span>

    IonDatagramLite(IonDatagramLite existing)
    {
<span class="fc" id="L105">        super(existing, ContainerlessContext.wrap(existing._system));</span>
<span class="fc" id="L106">        this._system  = existing._system;</span>
<span class="fc" id="L107">        this._catalog = existing._catalog;</span>
<span class="fc" id="L108">    }</span>

    @Override
    IonDatagramLite clone(IonContext parentContext)
    {
<span class="nc" id="L113">        String message = &quot;IonDatagram cannot have a parent context (be nested)&quot;;</span>
<span class="nc" id="L114">        throw new UnsupportedOperationException(message);</span>
    }

    @Override
    public IonDatagramLite clone()
    {
<span class="fc" id="L120">        return new IonDatagramLite(this);</span>
    }


    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the context methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    @Override
    public IonValueLite topLevelValue()
    {
<span class="fc" id="L135">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public SymbolToken[] getTypeAnnotationSymbols()
    {
        // An Ion Datagram cannot be annotated - however is sometimes interrogated as a generic
        // IonValue - hence having the explicit fast-path override of a non-null, empty SymbolToken
        // array
<span class="fc" id="L144">        return SymbolToken.EMPTY_ARRAY;</span>
    }

    @Override
    public SymbolToken getFieldNameSymbol()
    {
        // TOP level IonDatagram cannot have a field name (fundamentally it isn't a Struct)
<span class="nc" id="L151">        return null;</span>
    }

    @Override
    public void makeReadOnly()
    {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (_isLocked()) {</span>
<span class="nc" id="L158">            return;</span>
        }

<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (_children != null) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            for (int ii=0; ii&lt;_child_count; ii++) {</span>
<span class="fc" id="L163">                IonValueLite child = _children[ii];</span>
<span class="fc" id="L164">                child.makeReadOnly();</span>
            }
        }
<span class="fc" id="L167">        _isLocked(true);</span>
<span class="fc" id="L168">    }</span>

    @Override
    public SymbolTable getSymbolTable()
    {
<span class="nc" id="L173">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public SymbolTable getAssignedSymbolTable()
    {
<span class="fc" id="L179">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setSymbolTable(SymbolTable symbols)
    {
<span class="nc" id="L185">        throw new UnsupportedOperationException();</span>
    }

    public void appendTrailingSymbolTable(SymbolTable symtab)
    {
<span class="pc bpc" id="L190" title="2 of 6 branches missed.">        assert symtab.isLocalTable() || symtab.isSystemTable();</span>

<span class="fc" id="L192">        _pending_symbol_table = symtab;</span>
<span class="fc" id="L193">        _pending_symbol_table_idx = get_child_count();</span>
<span class="fc" id="L194">    }</span>

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the sequence methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    @Override
    public boolean add(IonValue child)
        throws ContainedValueException, NullPointerException
    {
<span class="fc" id="L208">        int index = _child_count;</span>
<span class="fc" id="L209">        add(index, child);</span>
<span class="fc" id="L210">        return true;</span>
    }

    @Override
    public ValueFactory add()
    {
<span class="fc" id="L216">        return new PrivateCurriedValueFactory(this.getSystem())</span>
<span class="fc" id="L217">        {</span>
            @Override
            protected void handle(IonValue newValue)
            {
<span class="fc" id="L221">                add(newValue);</span>
<span class="fc" id="L222">            }</span>
        };
    }

    @Override
    // Increasing visibility - note this is the base, workhorse, add method
    // for datagram (it does use the add_child through super.add()) for the
    // basic child array update, but it takes care of the datagram special
    // behaviors around local symbol tables for values
    public void add(int index, IonValue element)
        throws ContainedValueException, NullPointerException
    {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (element == null) {</span>
<span class="fc" id="L235">            throw new NullPointerException();</span>
        }
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (!(element instanceof IonValueLite)) {</span>
<span class="nc" id="L238">            throw new IllegalArgumentException(&quot;IonValue implementation can't be mixed&quot;);</span>
        }
        // TODO where do we validate that element isn't a datagram?

<span class="fc" id="L242">        IonValueLite concrete = (IonValueLite)element;</span>

        // super.add will check for the lock
<span class="fc" id="L245">        super.add(index, concrete);</span>
        // handled in super.add(): patch_elements_helper(index + 1);

        // the pending symbol table is only good for 1 use
        // after that the previous super.add will fill
        // in the symbol table if that is appropriate.
<span class="fc" id="L251">        _pending_symbol_table = null;</span>
<span class="fc" id="L252">        _pending_symbol_table_idx = -1;</span>
<span class="fc" id="L253">    }</span>

    @Override
    public ValueFactory add(final int index)
    {
<span class="nc" id="L258">        return new PrivateCurriedValueFactory(getSystem())</span>
<span class="nc" id="L259">        {</span>
            @Override
            protected void handle(IonValue newValue)
            {
<span class="nc" id="L263">                add(index, newValue);</span>
<span class="nc" id="L264">            }</span>
        };
    }

    @Override
    public boolean addAll(Collection&lt;? extends IonValue&gt; c)
    {
<span class="fc" id="L271">        boolean changed = false;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (IonValue v : c)</span>
        {
<span class="pc bpc" id="L274" title="3 of 4 branches missed.">            changed = add(v) || changed;</span>
<span class="fc" id="L275">        }</span>
<span class="fc" id="L276">        return changed;</span>
    }

    @Override
    public boolean addAll(int index, Collection&lt;? extends IonValue&gt; c)
    {
<span class="nc bnc" id="L282" title="All 4 branches missed.">        if (index &lt; 0 || index &gt; size())</span>
        {
<span class="nc" id="L284">            throw new IndexOutOfBoundsException();</span>
        }

        // TODO optimize to avoid n^2 shifting and renumbering of elements.
<span class="nc" id="L288">        boolean changed = false;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (IonValue v : c)</span>
        {
<span class="nc" id="L291">            add(index++, v);</span>
<span class="nc" id="L292">            changed = true;</span>
<span class="nc" id="L293">        }</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (changed) {</span>
<span class="nc" id="L296">            patch_elements_helper(index);</span>
        }

<span class="nc" id="L299">        return changed;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L304">        int prime  = 8191;</span>
<span class="nc" id="L305">        int result = HASH_SIGNATURE;</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (!isNullValue()) {</span>
            // As we are a datagram then the children need to resolve their own symbol tables -
            // so we use the 'top level' #hashCode() which will force each child to resolve it's
            // own symbol table.
<span class="nc bnc" id="L311" title="All 2 branches missed.">            for (IonValue v : this) {</span>
<span class="nc" id="L312">                result = prime * result + v.hashCode();</span>
                // mixing at each step to make the hash code order-dependent
<span class="nc" id="L314">                result ^= (result &lt;&lt; 29) ^ (result &gt;&gt; 3);</span>
<span class="nc" id="L315">            }</span>
        }
<span class="nc" id="L317">        return result;</span>
    }

    @Override
    int hashCode(SymbolTableProvider symbolTableProvider) {
<span class="nc" id="L322">        String message = &quot;IonDatagrams do not need a resolved Symbol table use #hashCode()&quot;;</span>
<span class="nc" id="L323">        throw new UnsupportedOperationException(message);</span>
    }


    @Override
    public &lt;T extends IonValue&gt; T[] extract(Class&lt;T&gt; type)
    {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (isNullValue()) return null;</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L333">        T[] array = (T[]) Array.newInstance(type, size());</span>
<span class="nc" id="L334">        toArray(array);</span>
<span class="nc" id="L335">        clear();</span>
<span class="nc" id="L336">        return array;</span>
    }


    @Override
    public ListIterator&lt;IonValue&gt; listIterator(int index)
    {
<span class="fc" id="L343">        ListIterator&lt;IonValue&gt; iterator = new SequenceContentIterator(index, this.isReadOnly());</span>
<span class="fc" id="L344">        return iterator;</span>
    }

    @Override
    public IonValue set(int index, IonValue element){
<span class="fc" id="L349">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public IonContext getContextForIndex(IonValue element, int index)
    {
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (index == this._pending_symbol_table_idx) {</span>
<span class="fc" id="L356">            SymbolTable symbols = _pending_symbol_table;</span>
<span class="fc" id="L357">            _pending_symbol_table = null;</span>
<span class="fc" id="L358">            _pending_symbol_table_idx = -1;</span>
<span class="fc" id="L359">            return TopLevelContext.wrap(symbols, this);</span>
        }
        // the preceding elements symbol table is our next
<span class="fc bfc" id="L362" title="All 2 branches covered.">        IonValueLite preceding = (index &gt; 0) ? get_child(index - 1) : null;</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">        if (preceding != null &amp;&amp; preceding._context != this) {</span>
<span class="fc" id="L364">            return preceding._context;</span>
        }
        // otherwise element will just default to the system
        // symbol table
<span class="fc" id="L368">        return TopLevelContext.wrap(null, this);</span>
    }


    @Override
    public void accept(ValueVisitor visitor) throws Exception
    {
<span class="nc" id="L375">        visitor.visit(this);</span>
<span class="nc" id="L376">    }</span>

    @Override
    public void addTypeAnnotation(String annotation)
    {
<span class="nc" id="L381">        String message = &quot;Datagrams do not have annotations&quot;;</span>
<span class="nc" id="L382">        throw new UnsupportedOperationException(message);</span>
    }


    @Override
    public IonContainerLite getContainer()
    {
<span class="fc" id="L389">        return null;</span>
    }

    @Override
    public IonSystemLite getSystem()
    {
<span class="fc" id="L395">        return this._system;</span>
    }

    @Override
    public IonType getType()
    {
<span class="fc" id="L401">        return IonType.DATAGRAM;</span>
    }

    /*
     * NOTE: IonDatagramLite overrides the main writeTo mechanism prescribed in:
     * IonValueLite#writeTo which works by eagerly resolving the SymbolTable as the IonDatagram does
     * not have a symbol table (throws UnsupportedOperationException) and so needs to write each
     * child out independently where the child will act as it's own top-level value (inc symbol table)
     */
    @Override
    public final void writeTo(IonWriter writer)
    {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (writer.getSymbolTable().isSystemTable()) {</span>
            // If the writer was configured with a non-default symbol table, writing an IVM here will
            // reset that symbol table. If the datagram contains any symbols with unknown text that
            // refer to slots in shared symbol table imports declared by the discarded table, an
            // error will be raised unnecessarily. To avoid that, only write an IVM when the writer's
            // symbol table is already the system symbol table.
            // TODO evaluate whether an IVM should ever be written here. amzn/ion-java#200
            try {
<span class="fc" id="L421">                writer.writeSymbol(SystemSymbols.ION_1_0);</span>
<span class="nc" id="L422">            } catch (IOException ioe) {</span>
<span class="nc" id="L423">                throw new IonException(ioe);</span>
<span class="fc" id="L424">            }</span>
        }
<span class="fc bfc" id="L426" title="All 2 branches covered.">        for (IonValue iv : this) {</span>
<span class="fc" id="L427">            iv.writeTo(writer);</span>
<span class="fc" id="L428">        }</span>
<span class="fc" id="L429">    }</span>

    @Override
    final void writeBodyTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
        throws IOException
    {
<span class="nc" id="L435">        throw new UnsupportedOperationException(&quot;IonDatagram does not operate with a Symbol Table&quot;);</span>
    }


    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the datagram methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    public int byteSize() throws IonException
    {
        // TODO this is horrible, users will end up encoding multiple times!
<span class="fc" id="L450">        ReverseBinaryEncoder encoder =</span>
            new ReverseBinaryEncoder(REVERSE_BINARY_ENCODER_INITIAL_SIZE);
<span class="fc" id="L452">        encoder.serialize(this);</span>
<span class="fc" id="L453">        return encoder.byteSize();</span>
    }

    public byte[] getBytes() throws IonException
    {
<span class="fc" id="L458">        ReverseBinaryEncoder encoder =</span>
            new ReverseBinaryEncoder(REVERSE_BINARY_ENCODER_INITIAL_SIZE);
<span class="fc" id="L460">        encoder.serialize(this);</span>
<span class="fc" id="L461">        return encoder.toNewByteArray();</span>
    }

    public int getBytes(OutputStream out) throws IOException, IonException
    {
<span class="fc" id="L466">        ReverseBinaryEncoder encoder =</span>
            new ReverseBinaryEncoder(REVERSE_BINARY_ENCODER_INITIAL_SIZE);
<span class="fc" id="L468">        encoder.serialize(this);</span>
<span class="fc" id="L469">        return encoder.writeBytes(out);</span>
    }

    // TODO: optimize this, if there's a real use case
    //       deprecate this is there isn't (which I suspect is actually the case)
    public IonValue systemGet(int index) throws IndexOutOfBoundsException
    {
<span class="fc" id="L476">        ListIterator&lt;IonValue&gt; iterator = systemIterator();</span>
<span class="fc" id="L477">        IonValue value = null;</span>

<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L480">            throw new IndexOutOfBoundsException(&quot;&quot;+index);</span>
        }

        int ii;
<span class="fc bfc" id="L484" title="All 2 branches covered.">        for (ii=0; ii&lt;=index; ii++) {</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            if (!iterator.hasNext()) {</span>
<span class="nc" id="L486">                throw new IndexOutOfBoundsException(&quot;&quot;+index);</span>
            }
<span class="fc" id="L488">            value = iterator.next();</span>
        }
<span class="fc" id="L490">        return value;</span>
    }

    public ListIterator&lt;IonValue&gt; systemIterator()
    {
<span class="fc" id="L495">        return new SystemContentIterator(isReadOnly());</span>
    }

    // TODO: optimize this, if there's a real use case
    //       deprecate this is there isn't (which I suspect is actually the case)
    public int systemSize()
    {
<span class="fc" id="L502">        int count = 0;</span>
<span class="fc" id="L503">        ListIterator&lt;IonValue&gt; iterator = systemIterator();</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
            @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L506">            IonValue value = iterator.next();</span>
<span class="fc" id="L507">            count++;</span>
<span class="fc" id="L508">        }</span>
<span class="fc" id="L509">        return count;</span>
    }

    /*
     * Sets the context of all elements following elementid to context, until it encounters
     * a context different to the original context at elementid.
     */
    void setSymbolTableAtIndex(int elementid, SymbolTable symbols)
    {
<span class="nc bnc" id="L518" title="All 4 branches missed.">        assert(elementid &lt; get_child_count());</span>
<span class="nc" id="L519">        TopLevelContext context = TopLevelContext.wrap(symbols, this);</span>
<span class="nc" id="L520">        TopLevelContext startContext = (TopLevelContext) _children[elementid].getContext();</span>

<span class="nc bnc" id="L522" title="All 4 branches missed.">        while (elementid &lt; get_child_count() &amp;&amp; _children[elementid].getContext() == startContext){</span>
<span class="nc" id="L523">            _children[elementid++].setContext(context);</span>
        }
<span class="nc" id="L525">    }</span>

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the local helper methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    protected synchronized IonSymbolLite get_ivm()
    {
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (_ivm == null) {</span>
<span class="fc" id="L538">            _ivm = getSystem().newSymbol(ION_1_0);</span>
        }
<span class="fc" id="L540">        return _ivm;</span>
    }

    /**
     * Encapsulates an iterator and implements a custom remove method
     *
     *  this is tied to the _child array of the IonSequenceImpl
     *  through the _children and _child_count members which this
     *  iterator directly uses.
     *
     *  This is a specialization for returning a system view of the
     *  current datagram.  It does this by synthesizing system values
     *  (Ion Version Markers &amp; local symbol tables) as symbol tables
     *  change between user values.
     *
     *  It accumulates a count of the system values it encounters
     *  the need to inject them in the iteration stream.
     *
     *  It may need more than 1 system value between user values
     *  if the system is reset or the local symbol table itself
     *  has local symbols (this is rare but in principal could
     *  be an arbitrarily long sequence).
     *
     *  The current position is between the value to be returned
     *  by next and the value that would be returned by previous.
     *  This is calculated in next_index_helper() (or previous_).
     *  It is represented by a &quot;struct&quot; with a position in the
     *  child array, an optional position in the local stack
     *  of system values, and a flag indicating which list should
     *  be used to fetch the actual value.
     *
     *  The local synthetic system values are held in the array
     *  __local_system_value.  These are the values that should
     *  preceed the value at _child[__user_content_pos].
     *
     *  TODO with the updated next and previous logic, particularly
     *  the force_position_sync logic and lastMoveWasPrevious flag
     *  we could implement add and set correctly.
     *
     *  NOTE this closely resembles the iterator defined in IonSequenceLite,
     *  so changes here are likely to be needed in IonSequenceLite as well.
     */
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">    protected final class SystemContentIterator</span>
        implements ListIterator&lt;IonValue&gt;
    {
        private final boolean                __readOnly;
        private       IonValueLite           __current;
        private       SystemIteratorPosition __pos;

        private       SystemIteratorPosition __temp_pos;

        public SystemContentIterator(boolean readOnly)
<span class="fc" id="L592">        {</span>
<span class="pc bpc" id="L593" title="1 of 4 branches missed.">            if (_isLocked() &amp;&amp; !readOnly) {</span>
<span class="nc" id="L594">                throw new IllegalStateException(&quot;you can't open an updatable iterator on a read only value&quot;);</span>
            }
<span class="fc" id="L596">            __readOnly = readOnly;</span>

<span class="fc" id="L598">            __temp_pos = new SystemIteratorPosition(this); // we flip back and forth between two positions to avoid allocating these on every value (or more)</span>
<span class="fc" id="L599">            __pos = new SystemIteratorPosition(this);</span>
<span class="fc" id="L600">            __pos.load_initial_position();</span>
<span class="fc" id="L601">        }</span>

        private IonSystem getSystem()
        {
<span class="nc" id="L605">            return IonDatagramLite.this.getSystem();</span>
        }

        protected IonValueLite set_position(SystemIteratorPosition newPos)
        {
            // swap our active position with our temp position
<span class="fc" id="L611">            __temp_pos = __pos;</span>
<span class="fc" id="L612">            __pos = newPos;</span>

            // load out current value from the position, and return it
<span class="fc" id="L615">            __current = __pos.load_position();</span>
<span class="fc" id="L616">            return __current;</span>
        }

        private void force_position_sync()
        {
<span class="fc" id="L621">            int user_index = __pos.__user_index;</span>
<span class="pc bpc" id="L622" title="1 of 4 branches missed.">            if (user_index &lt; 0 || user_index &gt;= _child_count) {</span>
<span class="fc" id="L623">                return;</span>
            }
<span class="fc" id="L625">            IonValueLite user_value = __pos.__current_user_value;</span>
<span class="pc bpc" id="L626" title="2 of 4 branches missed.">            if (user_value == null || user_value == _children[user_index]) {</span>
<span class="fc" id="L627">                return;</span>
            }
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (__readOnly) {</span>
<span class="nc" id="L630">                throw new IonException(&quot;read only sequence was changed&quot;);</span>
            }
<span class="nc" id="L632">            __pos.force_position_sync_helper();</span>
<span class="nc" id="L633">        }</span>

        public void add(IonValue element)
        {
<span class="nc" id="L637">            throw new UnsupportedOperationException();</span>
        }

        public final boolean hasNext()
        {
<span class="fc" id="L642">            return __pos.has_next();</span>
        }

        public IonValue next()
        {
<span class="fc" id="L647">            SystemIteratorPosition pos = next_index_helper();</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">            if (pos == null) {</span>
<span class="nc" id="L649">                throw new NoSuchElementException();</span>
            }
<span class="fc" id="L651">            IonValueLite current_value = set_position(pos);</span>
<span class="pc bpc" id="L652" title="2 of 4 branches missed.">            assert(current_value == this.__current);</span>
<span class="fc" id="L653">            return current_value;</span>
        }

        public final int nextIndex()
        {
<span class="nc" id="L658">            SystemIteratorPosition pos = next_index_helper();</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (pos == null) {</span>
                // we can do this because we hold the __pos
                // even when we run off the end, it will be
                // positioned at the value that wasn't there
<span class="nc" id="L663">                return __pos.get_external_pos() + 1;</span>
            }
<span class="nc" id="L665">            int idx = pos.get_external_pos();</span>
<span class="nc" id="L666">            return idx;</span>
        }

        private final SystemIteratorPosition next_index_helper()
        {
<span class="fc" id="L671">            SystemIteratorPosition next = null;</span>
<span class="fc" id="L672">            force_position_sync();</span>

<span class="pc bpc" id="L674" title="1 of 2 branches missed.">            if (__pos.has_next() == false) {</span>
<span class="nc" id="L675">                return null;</span>
            }

            // at this point we will have a next so prep out position now
<span class="fc" id="L679">            next = __temp_pos;</span>
<span class="pc bpc" id="L680" title="3 of 6 branches missed.">            assert(next != null &amp;&amp; next != __pos);</span>
<span class="fc" id="L681">            next.copyFrom(__pos);</span>

            // see if there's a system value waiting for use
<span class="fc" id="L684">            next.__local_index++;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (next.__local_index &lt; next.__local_value_count) {</span>
<span class="fc" id="L686">                return next;</span>
            }

            // if there's not system value there must be another user value
            // so we shouldn't get here since has_next() should have failed
<span class="pc bpc" id="L691" title="2 of 4 branches missed.">            assert(next.__user_index &lt;= get_child_count());</span>

            // if we were on a system value then we're just stepping onto the
            // since has_next() already declared we do have a waiting value
<span class="fc" id="L695">            next.__user_index++;</span>
<span class="fc" id="L696">            next.load_updated_position();</span>
            // we step onto the first local value
<span class="fc" id="L698">            next.__local_index = 0;</span>
<span class="fc" id="L699">            return next;</span>
        }

        public final boolean hasPrevious()
        {
<span class="nc" id="L704">            return __pos.has_prev();</span>
        }

        public IonValue previous()
        {
<span class="nc" id="L709">            SystemIteratorPosition pos = previous_index_helper();</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (pos == null) {</span>
<span class="nc" id="L711">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L713">            IonValueLite current_value = set_position(pos);</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">            assert(current_value == this.__current);</span>
<span class="nc" id="L715">            return current_value;</span>
        }

        public final int previousIndex()
        {
<span class="nc" id="L720">            SystemIteratorPosition pos = previous_index_helper();</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">            if (pos == null) {</span>
<span class="nc" id="L722">                return -1;</span>
            }
<span class="nc" id="L724">            int idx = pos.get_external_pos();</span>
<span class="nc" id="L725">            return idx;</span>
        }

        private final SystemIteratorPosition previous_index_helper()
        {
<span class="nc" id="L730">            SystemIteratorPosition prev = null;</span>

<span class="nc" id="L732">            force_position_sync();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (__pos.has_prev() == false) {</span>
<span class="nc" id="L734">                return null;</span>
            }

            // at this point we will have a prev so prep out position now
<span class="nc" id="L738">            prev = __temp_pos;</span>
<span class="nc bnc" id="L739" title="All 6 branches missed.">            assert(prev != null &amp;&amp; prev != __pos);</span>
<span class="nc" id="L740">            prev.copyFrom(__pos);</span>

<span class="nc" id="L742">            prev.__local_index--;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            if (prev.__local_index &gt;= 0) {</span>
<span class="nc" id="L744">                return prev;</span>
            }

            // if there's not system value there must be another user value
            // we would have bailed with has_prev returned false above otherwise
<span class="nc bnc" id="L749" title="All 4 branches missed.">            assert(prev.__user_index &gt; 0);</span>

            // if this is the 2nd prev then we really have to back up
<span class="nc" id="L752">            prev.__index_adjustment -= prev.__local_value_count;</span>
<span class="nc" id="L753">            prev.__user_index--;</span>
<span class="nc" id="L754">            prev.load_updated_position();</span>

            // going backwards we &quot;start&quot; at the end of our local list
<span class="nc" id="L757">            prev.__local_index = prev.__local_value_count - 1;</span>

<span class="nc" id="L759">            return prev;</span>
        }

        /**
         * removes the current member from the containing
         * datagram if it is a user value.
         *
         * If there is no current value it throws NoSuchElementException
         * If the current value is not a user value in the datagram
         * this throws UnsupportedOperationException.
         * And if the iterator is a read only iterator this also
         * throws UnsupportedOperationException.
         */
        public void remove()
        {
<span class="nc bnc" id="L774" title="All 2 branches missed.">            if (__readOnly) {</span>
<span class="nc" id="L775">                throw new UnsupportedOperationException();</span>
            }
<span class="nc" id="L777">            force_position_sync();</span>

<span class="nc bnc" id="L779" title="All 4 branches missed.">            if (__current == null || __pos == null) {</span>
<span class="nc" id="L780">                throw new NoSuchElementException();</span>
            }
<span class="nc bnc" id="L782" title="All 2 branches missed.">            if (__pos.on_system_value()) {</span>
<span class="nc" id="L783">                throw new UnsupportedOperationException();</span>
            }

<span class="nc" id="L786">            int idx = __pos.__user_index;</span>
<span class="nc bnc" id="L787" title="All 4 branches missed.">            assert(idx &gt;= 0);</span>

<span class="nc" id="L789">            IonValueLite concrete = __current;</span>
<span class="nc" id="L790">            int concrete_idx = concrete._elementid();</span>
<span class="nc bnc" id="L791" title="All 4 branches missed.">            assert(concrete_idx == idx);</span>

            // here we remove the member from the container's list of elements
<span class="nc" id="L794">            remove_child(idx);</span>
<span class="nc" id="L795">            patch_elements_helper(concrete_idx);</span>

            // when we remove the current value we remove
            // its associated system values and this
            // may change the index adjustment
<span class="nc" id="L800">            __pos.__index_adjustment -= __pos.__local_value_count;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (__pos.__user_index &lt; get_child_count() - 1)</span>
            {
<span class="nc" id="L803">                __pos.load_updated_position();</span>
<span class="nc" id="L804">                __pos.__local_index = -1;</span>
            }
<span class="nc" id="L806">            __current = null;</span>
<span class="nc" id="L807">        }</span>

        public void set(IonValue element)
        {
<span class="nc" id="L811">            throw new UnsupportedOperationException();</span>
        }
        protected int get_datagram_child_count()
        {
<span class="fc" id="L815">            return get_child_count();</span>
        }
        protected IonValueLite get_datagram_child(int idx)
        {
<span class="fc" id="L819">            return get_child(idx);</span>
        }
        protected IonSystem get_datagram_system()
        {
<span class="fc" id="L823">            return _system;</span>
        }
        protected boolean datagram_contains(IonValueLite value)
        {
<span class="nc" id="L827">            return contains(value);</span>
        }
        protected IonSymbolLite get_datagram_ivm()
        {
<span class="fc" id="L831">            return get_ivm();</span>
        }
    }
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">    static class SystemIteratorPosition</span>
    {
        /**
         * this position points to the user value that
         * we might have just passed calling next
         *
         * that is this position is between the last
         * value returned by next and the next value
         * that will be returned.
         *
         * As we change the user index we load the
         * current user value and synthesize any needed
         * local system values
         *
         * we also push the user value onto the same
         * local stack.  that way out local index can
         * run off either end of the local &quot;list&quot;
         * and only when we go yet another past either
         * end do we need to reload the value to
         * one side of the other, and which side of
         * our local list we ran off of will tell
         * us that.
         */
        protected final SystemContentIterator __iterator;
        protected       int                   __index_adjustment;      // delta between the user_content_pos and the external_pos

        protected       int                   __local_index;           // index of the next value in the system array (__local_system_value), if __on_system_value
<span class="fc" id="L861">        protected       IonValueLite[]        __local_values = new IonValueLite[3]; // more than the value, a symbol table, and a version marker would be MOST unusual</span>
        protected       int                   __local_value_count;

        protected       int                   __user_index;            // index of next value in the user content array (_children)
        protected       IonValueLite          __current_user_value;    // value from the child array at the time the user_index was moved forward == get_child(next_user_index -1)
        protected       SymbolTable           __current_symbols;
        protected       int                   __current_symbols_index;

        SystemIteratorPosition(SystemContentIterator iterator)
<span class="fc" id="L870">        {</span>
<span class="fc" id="L871">            __iterator = iterator;</span>
<span class="fc" id="L872">        }</span>

        void load_initial_position()
        {
<span class="fc" id="L876">            __user_index = 0;</span>
<span class="fc" id="L877">            __local_index = -1; // we're before the first value</span>
<span class="fc" id="L878">            __current_symbols_index = -1;</span>
<span class="fc" id="L879">            load_updated_position();</span>
<span class="fc" id="L880">        }</span>

        protected int get_external_pos()
        {
            int user_index;
<span class="nc" id="L885">            user_index  = __user_index;</span>
<span class="nc" id="L886">            user_index += __index_adjustment;</span>
<span class="nc" id="L887">            user_index -= __local_value_count;</span>
<span class="nc" id="L888">            user_index += __local_index;</span>
<span class="nc" id="L889">            return user_index;</span>
        }

        protected boolean on_system_value()
        {
<span class="nc bnc" id="L894" title="All 2 branches missed.">            return (__current_user_value != __local_values[0]);</span>
        }
        protected boolean has_next()
        {
<span class="fc bfc" id="L898" title="All 2 branches covered.">            if (__local_index + 1 &lt; __local_value_count) {</span>
<span class="fc" id="L899">                return true;</span>
            }
<span class="fc bfc" id="L901" title="All 2 branches covered.">            if (__user_index + 1 &lt; __iterator.get_datagram_child_count()) {</span>
<span class="fc" id="L902">                return true;</span>
            }
<span class="fc" id="L904">            return false;</span>
        }
        protected boolean has_prev()
        {
            // if we're not at the beginning of the datagram list
            // we always have another user value
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (__user_index &gt; 0) {</span>
<span class="nc" id="L911">                return true;</span>
            }
<span class="nc bnc" id="L913" title="All 2 branches missed.">            if (__local_index &gt; 0) {</span>
<span class="nc" id="L914">                return true;</span>
            }
            // we're out of both user and system values
<span class="nc" id="L917">            return false;</span>
        }

        protected void copyFrom(SystemIteratorPosition source)
        {
<span class="fc" id="L922">            this.__index_adjustment         = source.__index_adjustment;</span>
<span class="fc" id="L923">            this.__user_index               = source.__user_index;</span>
<span class="fc" id="L924">            this.__local_index              = source.__local_index;</span>
<span class="fc" id="L925">            this.__current_user_value       = source.__current_user_value;</span>
<span class="fc" id="L926">            this.__current_symbols          = source.__current_symbols;</span>
<span class="fc" id="L927">            this.__current_symbols_index    = source.__current_symbols_index;</span>

            // for the local system values each position needs its own
            // array, but the can share the value references
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">            if (source.__local_value_count &gt; 0) {</span>
<span class="pc bpc" id="L932" title="1 of 4 branches missed.">                if (this.__local_values == null || source.__local_value_count &gt;= this.__local_values.length) {</span>
<span class="fc" id="L933">                    this.__local_values = new IonValueLite[source.__local_values.length];</span>
                }
<span class="fc" id="L935">                System.arraycopy(source.__local_values, 0, this.__local_values, 0, source.__local_value_count);</span>
            }
<span class="fc" id="L937">            this.__local_value_count = source.__local_value_count;</span>
<span class="fc" id="L938">        }</span>

        private void load_updated_position()
        {
<span class="fc" id="L942">            IonValueLite prev_value = __current_user_value;</span>
            // we load our referenced user value (@ __user_index if
            // it exists).
<span class="pc bpc" id="L945" title="2 of 6 branches missed.">            if (__user_index &lt; 0 || (__user_index &gt; 0 &amp;&amp; __user_index &gt;=  __iterator.get_datagram_child_count())) {</span>
<span class="nc" id="L946">                throw new IonException(&quot;attempt to position iterator past end of values&quot;);</span>
            }
<span class="fc bfc" id="L948" title="All 2 branches covered.">            if (__user_index &lt; __iterator.get_datagram_child_count()) {</span>
<span class="fc" id="L949">                __current_user_value = __iterator.get_datagram_child(__user_index);</span>
<span class="pc bpc" id="L950" title="2 of 4 branches missed.">                assert(__current_user_value != null);</span>
            }
            else {
                // when there are no user values and we're at index == 0
<span class="pc bpc" id="L954" title="3 of 6 branches missed.">                assert(__user_index == 0 &amp;&amp; __iterator.get_datagram_child_count() == 0);</span>
<span class="fc" id="L955">                __current_user_value = null;</span>
            }

<span class="fc" id="L958">            int old_count = __local_value_count;</span>
<span class="fc" id="L959">            __local_value_count = 0;</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">            if (__current_user_value != null) {</span>
<span class="fc" id="L961">                push_system_value(__current_user_value);</span>
            }
<span class="fc" id="L963">            load_current_symbol_table(prev_value);</span>

<span class="fc bfc" id="L965" title="All 2 branches covered.">            for (int ii=__local_value_count; ii&lt;old_count; ii++) {</span>
<span class="fc" id="L966">                __local_values[ii] = null;</span>
            }
<span class="fc" id="L968">            __index_adjustment += __local_value_count - 1;</span>

<span class="fc" id="L970">            return;</span>
        }

        void load_current_symbol_table(IonValueLite prev_user_value)
        {
<span class="fc" id="L975">            IonValueLite curr_value  = __current_user_value;</span>
<span class="fc" id="L976">            int          curr_index  = __user_index;</span>

<span class="fc" id="L978">            IonValueLite prev_value  = prev_user_value;</span>
<span class="fc" id="L979">            SymbolTable  prev_symtab = __current_symbols;</span>
<span class="fc" id="L980">            int          prev_index  = __current_symbols_index;</span>

            // set our new position symbol table
<span class="fc" id="L983">            __current_symbols  = null;</span>
<span class="fc" id="L984">            __current_symbols_index = curr_index;</span>
<span class="fc" id="L985">            SymbolTable  curr_symtab = null;</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">           if (curr_value != null) {</span>
<span class="fc" id="L987">                curr_symtab = curr_value.getAssignedSymbolTable();</span>
<span class="fc" id="L988">                __current_symbols = curr_symtab;</span>
            }

            // if we need to we reset the previous values here
            // this happens when the caller is scanning backwards
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">            if (curr_index - 1 != prev_index) {</span>
<span class="nc" id="L994">                prev_index = curr_index - 1;</span>
<span class="nc" id="L995">                prev_symtab = null;</span>
<span class="nc bnc" id="L996" title="All 4 branches missed.">                if (prev_index &gt;= 0 &amp;&amp; prev_index &lt; __iterator.get_datagram_child_count()) {</span>
<span class="nc" id="L997">                    prev_value  = __iterator.get_datagram_child(prev_index);</span>
<span class="nc" id="L998">                    prev_symtab = prev_value.getAssignedSymbolTable();</span>
                }
            }

            // Now if there was a change push the local symbol
            // tables onto our system value stack

            // note that our chain of preceding symbol tables
            // might match our list of previous structs in the
            // user list.  Until there's a difference we don't
            // push the symbol tables (because they've already
            // been processed as real values).
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            if (curr_symtab != prev_symtab) {</span>
<span class="fc" id="L1011">                SymbolTable new_symbol_table = curr_symtab;</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">                while (new_symbol_table != null)</span>
                {
<span class="fc" id="L1014">                    final boolean new_symbol_table_is_system = new_symbol_table.isSystemTable();</span>
                    IonValue rep;
<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">                    if (new_symbol_table_is_system) {</span>
<span class="nc" id="L1017">                        rep = __iterator.get_datagram_ivm();</span>
                    }
                    else {
<span class="fc" id="L1020">                        rep = PrivateUtils.symtabTree(new_symbol_table);</span>
                    }
<span class="pc bpc" id="L1022" title="3 of 6 branches missed.">                    assert(rep != null &amp;&amp; __iterator.get_datagram_system() == rep.getSystem());</span>

<span class="pc bpc" id="L1024" title="4 of 6 branches missed.">                    if (rep == prev_value || (is_ivm(curr_value) &amp;&amp; new_symbol_table_is_system)) {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                        int prev_idx = (prev_value == null) ? -1 : (prev_value._elementid() - 1);</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                        if (prev_idx &gt;= 0) {</span>
<span class="nc" id="L1027">                            prev_value = __iterator.get_datagram_child(prev_idx);</span>
                        }
                        else {
<span class="nc" id="L1030">                            prev_value = null;</span>
                        }
<span class="nc" id="L1032">                    }</span>
                    else {
<span class="fc" id="L1034">                        push_system_value((IonValueLite)rep);</span>
<span class="fc" id="L1035">                        prev_value = null; // end of the matches</span>
                    }
<span class="fc" id="L1037">                    new_symbol_table = rep.getSymbolTable();</span>
<span class="pc bpc" id="L1038" title="2 of 4 branches missed.">                    if (new_symbol_table == null || new_symbol_table.isSystemTable()) {</span>
<span class="fc" id="L1039">                        break;</span>
                    }
<span class="nc" id="L1041">                }</span>
            }
            // and at the front we need to put in the ion version marker
<span class="pc bpc" id="L1044" title="1 of 4 branches missed.">            if (curr_index == 0 &amp;&amp; !is_ivm(curr_value)) {</span>
                // TODO this is wrong, because we may have already pushed
                // a rep above. This is just making up an additional symtab
                // where one was not placed by the user.
<span class="fc" id="L1048">                IonValueLite ivm = __iterator.get_datagram_ivm();</span>
<span class="fc" id="L1049">                push_system_value(ivm);</span>
            }
<span class="fc" id="L1051">        }</span>

        private static final boolean is_ivm(IonValue value)
        {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (value instanceof IonSymbol</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">                &amp;&amp; value.getTypeAnnotationSymbols().length == 0) {</span>
                // $ion_1_0 is read as an IVM only if it is not annotated
<span class="fc" id="L1058">                IonSymbol sym = (IonSymbol)value;</span>
<span class="fc" id="L1059">                SymbolToken tok = sym.symbolValue();</span>
<span class="pc bpc" id="L1060" title="1 of 4 branches missed.">                if (tok != null &amp;&amp; ION_1_0.equals(tok.getText()))</span>
                {
<span class="nc" id="L1062">                    return true;</span>
                }
            }
<span class="fc" id="L1065">            return false;</span>
        }

        private void push_system_value(IonValueLite value)
        {
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">            if (__local_value_count &gt;= __local_values.length) {</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                int new_size = (__local_values == null) ? 2 : (__local_values.length * 2);</span>
<span class="nc bnc" id="L1072" title="All 4 branches missed.">                assert( new_size &gt; __local_value_count); // we should only need to add 1 value at a time</span>
<span class="nc" id="L1073">                IonValueLite[] temp = new IonValueLite[new_size];</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                if (__local_value_count &gt; 0) {</span>
<span class="nc" id="L1075">                    System.arraycopy(__local_values, 0, temp, 0, __local_value_count);</span>
                }
<span class="nc" id="L1077">                __local_values = temp;</span>
            }
<span class="fc" id="L1079">            __local_values[__local_value_count++] = value;</span>
<span class="fc" id="L1080">        }</span>

        protected IonValueLite load_position()
        {
<span class="fc" id="L1084">            IonValueLite current = null;</span>

<span class="pc bpc" id="L1086" title="2 of 4 branches missed.">            assert(__local_index &lt; __local_value_count);</span>

<span class="fc" id="L1088">            current = __local_values[__local_value_count - __local_index - 1];</span>

<span class="fc" id="L1090">            return current;</span>
        }

        private final void force_position_sync_helper()
        {
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            if (!__iterator.datagram_contains(__current_user_value)) {</span>
<span class="nc" id="L1096">                throw new IonException(&quot;current user value removed outside this iterator - position lost&quot;);</span>
            }
<span class="nc" id="L1098">            int old_index = __user_index;</span>
<span class="nc" id="L1099">            int new_index = __current_user_value._elementid();</span>

<span class="nc bnc" id="L1101" title="All 2 branches missed.">            if (old_index != new_index) {</span>
                // if our current value moved we have to recompute
                // the adjustment from scratch since we don't really
                // have any idea why this moved in either direction.
<span class="nc" id="L1105">                int adjustment = 0;</span>
<span class="nc" id="L1106">                SymbolTable curr, prev = null;</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">                for (int ii=0; ii&lt;new_index; ii--) {</span>
<span class="nc" id="L1108">                    curr = __iterator.get_datagram_child(ii).getSymbolTable();</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">                    if (curr != prev) {</span>
<span class="nc" id="L1110">                        IonSystem sys = __iterator.getSystem();</span>
<span class="nc" id="L1111">                        adjustment += count_system_values(sys, prev, curr);</span>
                    }
<span class="nc" id="L1113">                    prev = curr;</span>
                }
<span class="nc" id="L1115">                __index_adjustment = adjustment + __local_value_count;</span>
<span class="nc" id="L1116">                __user_index = new_index;</span>
            }
<span class="nc" id="L1118">        }</span>

        private static int count_system_values(IonSystem sys,
                                               SymbolTable prev,
                                               SymbolTable curr)
        {
<span class="nc" id="L1124">            int count = 0;</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            while (curr.isLocalTable()) {</span>
<span class="nc" id="L1126">                count++;</span>
<span class="nc" id="L1127">                curr = PrivateUtils.symtabTree(curr).getSymbolTable();</span>
            }
            // we should terminate when the symbol tables symbol table is the system symbol table
<span class="nc bnc" id="L1130" title="All 4 branches missed.">            assert(curr != null);</span>
<span class="nc bnc" id="L1131" title="All 4 branches missed.">            if (prev == null || prev.getIonVersionId().equals(curr.getIonVersionId())) {</span>
<span class="nc" id="L1132">                count++;</span>
            }
<span class="nc" id="L1134">            return count;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>