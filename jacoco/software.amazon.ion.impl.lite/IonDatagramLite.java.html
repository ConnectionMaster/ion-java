<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonDatagramLite.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl.lite</a> &gt; <span class="el_source">IonDatagramLite.java</span></div><h1>IonDatagramLite.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2010-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl.lite;

import static software.amazon.ion.SystemSymbols.ION_1_0;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import software.amazon.ion.ContainedValueException;
import software.amazon.ion.IonCatalog;
import software.amazon.ion.IonDatagram;
import software.amazon.ion.IonException;
import software.amazon.ion.IonSymbol;
import software.amazon.ion.IonSystem;
import software.amazon.ion.IonType;
import software.amazon.ion.IonValue;
import software.amazon.ion.IonWriter;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.SystemSymbols;
import software.amazon.ion.ValueFactory;
import software.amazon.ion.ValueVisitor;
import software.amazon.ion.impl.PrivateCurriedValueFactory;
import software.amazon.ion.impl.PrivateIonDatagram;
import software.amazon.ion.impl.PrivateUtils;

/**
 *  The datagram generally behaves as an IonSexp. A list with space
 *  separated values.
 *
 *  As a user datagram it only shows user values as current members
 *  of the list.
 *
 *  As a system datagram it also includes system values (adding Ion
 *  version marker symbols and local symbol tables to the list).
 *
 *  Most API's operate on the user view.  The exceptions are getBytes
 *  (and related), and the system* API's.  These synthesize a system
 *  view over the user values.
 *
 *  When system values are added they translate into setsymboltableat
 *  operations.  Which sets a pending symbol table at the current
 *  user position (as specified by the add pos).  When the next add
 *  occurs if it is at the specified position the pending symbol
 *  table is applied to the value if the value doesn't already have
 *  a local symbol table defined.
 *
 *  in any event any membership update invalidates the pending symbol
 *  table.
 *
 *  In general on add if there is no pending symbol table the preceding
 *  value local symbol table is applied as the local symbol table to
 *  the new value, if it needs one.
 *
 *  The system iterator inserts system values to create the minimum
 *  additional values to represent a correct Ion sequence by injecting
 *  IVM's when the symbol table transitions to system, and local
 *  symbol tables when they first occur.
 *
 */

<span class="pc bpc" id="L78" title="1 of 2 branches missed.">final class IonDatagramLite</span>
    extends IonSequenceLite
    implements IonDatagram, IonContext, PrivateIonDatagram
{

<span class="fc" id="L83">    private static final int HASH_SIGNATURE =</span>
<span class="fc" id="L84">        IonType.DATAGRAM.toString().hashCode();</span>

    private final IonSystemLite      _system;
    private final IonCatalog         _catalog;
    private       SymbolTable        _pending_symbol_table;
    private       int                _pending_symbol_table_idx;
    private       IonSymbolLite      _ivm;

    // Default buffer size for ReverseBinaryEncoder - SYNC'ed with
    // BlockedBuffer._defaultBlockSizeMin (4 kb)
    private static final int REVERSE_BINARY_ENCODER_INITIAL_SIZE = 4096 * 8;

    IonDatagramLite(IonSystemLite system, IonCatalog catalog) {
<span class="fc" id="L97">        super(ContainerlessContext.wrap(system), false);</span>
<span class="fc" id="L98">        _system = system;</span>
<span class="fc" id="L99">        _catalog = catalog;</span>
<span class="fc" id="L100">        _pending_symbol_table_idx = -1;</span>
<span class="fc" id="L101">    }</span>

    IonDatagramLite(IonDatagramLite existing)
    {
<span class="fc" id="L105">        super(existing, ContainerlessContext.wrap(existing._system));</span>
<span class="fc" id="L106">        this._system  = existing._system;</span>
<span class="fc" id="L107">        this._catalog = existing._catalog;</span>
<span class="fc" id="L108">    }</span>

    @Override
    IonDatagramLite clone(IonContext parentContext)
    {
<span class="nc" id="L113">        String message = &quot;IonDatagram cannot have a parent context (be nested)&quot;;</span>
<span class="nc" id="L114">        throw new UnsupportedOperationException(message);</span>
    }

    @Override
    public IonDatagramLite clone()
    {
<span class="fc" id="L120">        return new IonDatagramLite(this);</span>
    }


    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the context methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    @Override
    public IonValueLite topLevelValue()
    {
<span class="fc" id="L135">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public SymbolToken[] getTypeAnnotationSymbols()
    {
        // An Ion Datagram cannot be annotated - however is sometimes interrogated as a generic
        // IonValue - hence having the explicit fast-path override of a non-null, empty SymbolToken
        // array
<span class="fc" id="L144">        return SymbolToken.EMPTY_ARRAY;</span>
    }

    @Override
    public SymbolToken getFieldNameSymbol()
    {
        // TOP level IonDatagram cannot have a field name (fundamentally it isn't a Struct)
<span class="nc" id="L151">        return null;</span>
    }

    @Override
    public void makeReadOnly()
    {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (_isLocked()) {</span>
<span class="nc" id="L158">            return;</span>
        }

<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (_children != null) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            for (int ii=0; ii&lt;_child_count; ii++) {</span>
<span class="fc" id="L163">                IonValueLite child = _children[ii];</span>
<span class="fc" id="L164">                child.makeReadOnly();</span>
            }
        }
<span class="fc" id="L167">        _isLocked(true);</span>
<span class="fc" id="L168">    }</span>

    @Override
    public SymbolTable getSymbolTable()
    {
<span class="nc" id="L173">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public SymbolTable getAssignedSymbolTable()
    {
<span class="fc" id="L179">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setSymbolTable(SymbolTable symbols)
    {
<span class="nc" id="L185">        throw new UnsupportedOperationException();</span>
    }

    public void appendTrailingSymbolTable(SymbolTable symtab)
    {
<span class="pc bpc" id="L190" title="2 of 6 branches missed.">        assert symtab.isLocalTable() || symtab.isSystemTable();</span>

<span class="fc" id="L192">        _pending_symbol_table = symtab;</span>
<span class="fc" id="L193">        _pending_symbol_table_idx = get_child_count();</span>
<span class="fc" id="L194">    }</span>

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the sequence methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    @Override
    public boolean add(IonValue child)
        throws ContainedValueException, NullPointerException
    {
<span class="fc" id="L208">        int index = _child_count;</span>
<span class="fc" id="L209">        add(index, child);</span>
<span class="fc" id="L210">        return true;</span>
    }

    @Override
    public ValueFactory add()
    {
<span class="fc" id="L216">        return new PrivateCurriedValueFactory(this.getSystem())</span>
<span class="fc" id="L217">        {</span>
            @Override
            protected void handle(IonValue newValue)
            {
<span class="fc" id="L221">                add(newValue);</span>
<span class="fc" id="L222">            }</span>
        };
    }

    @Override
    // Increasing visibility - note this is the base, workhorse, add method
    // for datagram (it does use the add_child through super.add()) for the
    // basic child array update, but it takes care of the datagram special
    // behaviors around local symbol tables for values
    public void add(int index, IonValue element)
        throws ContainedValueException, NullPointerException
    {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (element == null) {</span>
<span class="fc" id="L235">            throw new NullPointerException();</span>
        }
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (!(element instanceof IonValueLite)) {</span>
<span class="nc" id="L238">            throw new IllegalArgumentException(&quot;IonValue implementation can't be mixed&quot;);</span>
        }
        // TODO where do we validate that element isn't a datagram?

<span class="fc" id="L242">        IonValueLite concrete = (IonValueLite)element;</span>

        // super.add will check for the lock
<span class="fc" id="L245">        super.add(index, concrete);</span>
        // handled in super.add(): patch_elements_helper(index + 1);

        // the pending symbol table is only good for 1 use
        // after that the previous super.add will fill
        // in the symbol table if that is appropriate.
<span class="fc" id="L251">        _pending_symbol_table = null;</span>
<span class="fc" id="L252">        _pending_symbol_table_idx = -1;</span>
<span class="fc" id="L253">    }</span>

    @Override
    public ValueFactory add(final int index)
    {
<span class="nc" id="L258">        return new PrivateCurriedValueFactory(getSystem())</span>
<span class="nc" id="L259">        {</span>
            @Override
            protected void handle(IonValue newValue)
            {
<span class="nc" id="L263">                add(index, newValue);</span>
<span class="nc" id="L264">            }</span>
        };
    }

    @Override
    public boolean addAll(Collection&lt;? extends IonValue&gt; c)
    {
<span class="fc" id="L271">        boolean changed = false;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (IonValue v : c)</span>
        {
<span class="pc bpc" id="L274" title="3 of 4 branches missed.">            changed = add(v) || changed;</span>
<span class="fc" id="L275">        }</span>
<span class="fc" id="L276">        return changed;</span>
    }

    @Override
    public boolean addAll(int index, Collection&lt;? extends IonValue&gt; c)
    {
<span class="nc bnc" id="L282" title="All 4 branches missed.">        if (index &lt; 0 || index &gt; size())</span>
        {
<span class="nc" id="L284">            throw new IndexOutOfBoundsException();</span>
        }

        // TODO optimize to avoid n^2 shifting and renumbering of elements.
<span class="nc" id="L288">        boolean changed = false;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (IonValue v : c)</span>
        {
<span class="nc" id="L291">            add(index++, v);</span>
<span class="nc" id="L292">            changed = true;</span>
<span class="nc" id="L293">        }</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (changed) {</span>
<span class="nc" id="L296">            patch_elements_helper(index);</span>
        }

<span class="nc" id="L299">        return changed;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L304">        int prime  = 8191;</span>
<span class="nc" id="L305">        int result = HASH_SIGNATURE;</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (!isNullValue()) {</span>
            // As we are a datagram then the children need to resolve their own symbol tables -
            // so we use the 'top level' #hashCode() which will force each child to resolve it's
            // own symbol table.
<span class="nc bnc" id="L311" title="All 2 branches missed.">            for (IonValue v : this) {</span>
<span class="nc" id="L312">                result = prime * result + v.hashCode();</span>
                // mixing at each step to make the hash code order-dependent
<span class="nc" id="L314">                result ^= (result &lt;&lt; 29) ^ (result &gt;&gt; 3);</span>
<span class="nc" id="L315">            }</span>
        }
<span class="nc" id="L317">        return result;</span>
    }

    @Override
    int hashCode(SymbolTableProvider symbolTableProvider) {
<span class="nc" id="L322">        String message = &quot;IonDatagrams do not need a resolved Symbol table use #hashCode()&quot;;</span>
<span class="nc" id="L323">        throw new UnsupportedOperationException(message);</span>
    }


    @Override
    public &lt;T extends IonValue&gt; T[] extract(Class&lt;T&gt; type)
    {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (isNullValue()) return null;</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L333">        T[] array = (T[]) Array.newInstance(type, size());</span>
<span class="nc" id="L334">        toArray(array);</span>
<span class="nc" id="L335">        clear();</span>
<span class="nc" id="L336">        return array;</span>
    }


    @Override
    public ListIterator&lt;IonValue&gt; listIterator(int index)
    {
<span class="fc" id="L343">        ListIterator&lt;IonValue&gt; iterator = new SequenceContentIterator(index, this.isReadOnly());</span>
<span class="fc" id="L344">        return iterator;</span>
    }

    @Override
    public IonValue set(int index, IonValue element){
<span class="fc" id="L349">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public IonContext getContextForIndex(IonValue element, int index)
    {
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (index == this._pending_symbol_table_idx) {</span>
<span class="fc" id="L356">            SymbolTable symbols = _pending_symbol_table;</span>
<span class="fc" id="L357">            _pending_symbol_table = null;</span>
<span class="fc" id="L358">            _pending_symbol_table_idx = -1;</span>
<span class="fc" id="L359">            return TopLevelContext.wrap(symbols, this);</span>
        }
        // the preceding elements symbol table is our next
<span class="fc bfc" id="L362" title="All 2 branches covered.">        IonValueLite preceding = (index &gt; 0) ? get_child(index - 1) : null;</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">        if (preceding != null &amp;&amp; preceding._context != this) {</span>
<span class="fc" id="L364">            return preceding._context;</span>
        }
        // otherwise element will just default to the system
        // symbol table
<span class="fc" id="L368">        return TopLevelContext.wrap(null, this);</span>
    }


    @Override
    public void accept(ValueVisitor visitor) throws Exception
    {
<span class="nc" id="L375">        visitor.visit(this);</span>
<span class="nc" id="L376">    }</span>

    @Override
    public void addTypeAnnotation(String annotation)
    {
<span class="nc" id="L381">        String message = &quot;Datagrams do not have annotations&quot;;</span>
<span class="nc" id="L382">        throw new UnsupportedOperationException(message);</span>
    }


    @Override
    public IonContainerLite getContainer()
    {
<span class="fc" id="L389">        return null;</span>
    }

    @Override
    public IonSystemLite getSystem()
    {
<span class="fc" id="L395">        return this._system;</span>
    }

    @Override
    public IonType getType()
    {
<span class="fc" id="L401">        return IonType.DATAGRAM;</span>
    }

    /*
     * NOTE: IonDatagramLite overrides the main writeTo mechanism prescribed in:
     * IonValueLite#writeTo which works by eagerly resolving the SymbolTable as the IonDatagram does
     * not have a symbol table (throws UnsupportedOperationException) and so needs to write each
     * child out independently where the child will act as it's own top-level value (inc symbol table)
     */
    @Override
    public final void writeTo(IonWriter writer)
    {
        try
        {
<span class="fc" id="L415">            writer.writeSymbol(SystemSymbols.ION_1_0);  // TODO amzn/ion-java#8 ???</span>
<span class="nc" id="L416">        } catch (IOException ioe) {</span>
<span class="nc" id="L417">            throw new IonException(ioe);</span>
<span class="fc" id="L418">        }</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (IonValue iv : this) {</span>
<span class="fc" id="L420">            iv.writeTo(writer);</span>
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">    }</span>

    @Override
    final void writeBodyTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
        throws IOException
    {
<span class="nc" id="L428">        throw new UnsupportedOperationException(&quot;IonDatagram does not operate with a Symbol Table&quot;);</span>
    }


    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the datagram methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    public int byteSize() throws IonException
    {
        // TODO this is horrible, users will end up encoding multiple times!
<span class="fc" id="L443">        ReverseBinaryEncoder encoder =</span>
            new ReverseBinaryEncoder(REVERSE_BINARY_ENCODER_INITIAL_SIZE);
<span class="fc" id="L445">        encoder.serialize(this);</span>
<span class="fc" id="L446">        return encoder.byteSize();</span>
    }

    public byte[] getBytes() throws IonException
    {
<span class="fc" id="L451">        ReverseBinaryEncoder encoder =</span>
            new ReverseBinaryEncoder(REVERSE_BINARY_ENCODER_INITIAL_SIZE);
<span class="fc" id="L453">        encoder.serialize(this);</span>
<span class="fc" id="L454">        return encoder.toNewByteArray();</span>
    }

    public int getBytes(OutputStream out) throws IOException, IonException
    {
<span class="fc" id="L459">        ReverseBinaryEncoder encoder =</span>
            new ReverseBinaryEncoder(REVERSE_BINARY_ENCODER_INITIAL_SIZE);
<span class="fc" id="L461">        encoder.serialize(this);</span>
<span class="fc" id="L462">        return encoder.writeBytes(out);</span>
    }

    // TODO: optimize this, if there's a real use case
    //       deprecate this is there isn't (which I suspect is actually the case)
    public IonValue systemGet(int index) throws IndexOutOfBoundsException
    {
<span class="fc" id="L469">        ListIterator&lt;IonValue&gt; iterator = systemIterator();</span>
<span class="fc" id="L470">        IonValue value = null;</span>

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L473">            throw new IndexOutOfBoundsException(&quot;&quot;+index);</span>
        }

        int ii;
<span class="fc bfc" id="L477" title="All 2 branches covered.">        for (ii=0; ii&lt;=index; ii++) {</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">            if (!iterator.hasNext()) {</span>
<span class="nc" id="L479">                throw new IndexOutOfBoundsException(&quot;&quot;+index);</span>
            }
<span class="fc" id="L481">            value = iterator.next();</span>
        }
<span class="fc" id="L483">        return value;</span>
    }

    public ListIterator&lt;IonValue&gt; systemIterator()
    {
<span class="fc" id="L488">        return new SystemContentIterator(isReadOnly());</span>
    }

    // TODO: optimize this, if there's a real use case
    //       deprecate this is there isn't (which I suspect is actually the case)
    public int systemSize()
    {
<span class="fc" id="L495">        int count = 0;</span>
<span class="fc" id="L496">        ListIterator&lt;IonValue&gt; iterator = systemIterator();</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
            @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L499">            IonValue value = iterator.next();</span>
<span class="fc" id="L500">            count++;</span>
<span class="fc" id="L501">        }</span>
<span class="fc" id="L502">        return count;</span>
    }

    /*
     * Sets the context of all elements following elementid to context, until it encounters
     * a context different to the original context at elementid.
     */
    void setSymbolTableAtIndex(int elementid, SymbolTable symbols)
    {
<span class="nc bnc" id="L511" title="All 4 branches missed.">        assert(elementid &lt; get_child_count());</span>
<span class="nc" id="L512">        TopLevelContext context = TopLevelContext.wrap(symbols, this);</span>
<span class="nc" id="L513">        TopLevelContext startContext = (TopLevelContext) _children[elementid].getContext();</span>

<span class="nc bnc" id="L515" title="All 4 branches missed.">        while (elementid &lt; get_child_count() &amp;&amp; _children[elementid].getContext() == startContext){</span>
<span class="nc" id="L516">            _children[elementid++].setContext(context);</span>
        }
<span class="nc" id="L518">    }</span>

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    //  these are the local helper methods

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    protected synchronized IonSymbolLite get_ivm()
    {
<span class="fc bfc" id="L530" title="All 2 branches covered.">        if (_ivm == null) {</span>
<span class="fc" id="L531">            _ivm = getSystem().newSymbol(ION_1_0);</span>
        }
<span class="fc" id="L533">        return _ivm;</span>
    }

    /**
     * Encapsulates an iterator and implements a custom remove method
     *
     *  this is tied to the _child array of the IonSequenceImpl
     *  through the _children and _child_count members which this
     *  iterator directly uses.
     *
     *  This is a specialization for returning a system view of the
     *  current datagram.  It does this by synthesizing system values
     *  (Ion Version Markers &amp; local symbol tables) as symbol tables
     *  change between user values.
     *
     *  It accumulates a count of the system values it encounters
     *  the need to inject them in the iteration stream.
     *
     *  It may need more than 1 system value between user values
     *  if the system is reset or the local symbol table itself
     *  has local symbols (this is rare but in principal could
     *  be an arbitrarily long sequence).
     *
     *  The current position is between the value to be returned
     *  by next and the value that would be returned by previous.
     *  This is calculated in next_index_helper() (or previous_).
     *  It is represented by a &quot;struct&quot; with a position in the
     *  child array, an optional position in the local stack
     *  of system values, and a flag indicating which list should
     *  be used to fetch the actual value.
     *
     *  The local synthetic system values are held in the array
     *  __local_system_value.  These are the values that should
     *  preceed the value at _child[__user_content_pos].
     *
     *  TODO with the updated next and previous logic, particularly
     *  the force_position_sync logic and lastMoveWasPrevious flag
     *  we could implement add and set correctly.
     *
     *  NOTE this closely resembles the iterator defined in IonSequenceLite,
     *  so changes here are likely to be needed in IonSequenceLite as well.
     */
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">    protected final class SystemContentIterator</span>
        implements ListIterator&lt;IonValue&gt;
    {
        private final boolean                __readOnly;
        private       IonValueLite           __current;
        private       SystemIteratorPosition __pos;

        private       SystemIteratorPosition __temp_pos;

        public SystemContentIterator(boolean readOnly)
<span class="fc" id="L585">        {</span>
<span class="pc bpc" id="L586" title="1 of 4 branches missed.">            if (_isLocked() &amp;&amp; !readOnly) {</span>
<span class="nc" id="L587">                throw new IllegalStateException(&quot;you can't open an updatable iterator on a read only value&quot;);</span>
            }
<span class="fc" id="L589">            __readOnly = readOnly;</span>

<span class="fc" id="L591">            __temp_pos = new SystemIteratorPosition(this); // we flip back and forth between two positions to avoid allocating these on every value (or more)</span>
<span class="fc" id="L592">            __pos = new SystemIteratorPosition(this);</span>
<span class="fc" id="L593">            __pos.load_initial_position();</span>
<span class="fc" id="L594">        }</span>

        private IonSystem getSystem()
        {
<span class="nc" id="L598">            return IonDatagramLite.this.getSystem();</span>
        }

        protected IonValueLite set_position(SystemIteratorPosition newPos)
        {
            // swap our active position with our temp position
<span class="fc" id="L604">            __temp_pos = __pos;</span>
<span class="fc" id="L605">            __pos = newPos;</span>

            // load out current value from the position, and return it
<span class="fc" id="L608">            __current = __pos.load_position();</span>
<span class="fc" id="L609">            return __current;</span>
        }

        private void force_position_sync()
        {
<span class="fc" id="L614">            int user_index = __pos.__user_index;</span>
<span class="pc bpc" id="L615" title="1 of 4 branches missed.">            if (user_index &lt; 0 || user_index &gt;= _child_count) {</span>
<span class="fc" id="L616">                return;</span>
            }
<span class="fc" id="L618">            IonValueLite user_value = __pos.__current_user_value;</span>
<span class="pc bpc" id="L619" title="2 of 4 branches missed.">            if (user_value == null || user_value == _children[user_index]) {</span>
<span class="fc" id="L620">                return;</span>
            }
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (__readOnly) {</span>
<span class="nc" id="L623">                throw new IonException(&quot;read only sequence was changed&quot;);</span>
            }
<span class="nc" id="L625">            __pos.force_position_sync_helper();</span>
<span class="nc" id="L626">        }</span>

        public void add(IonValue element)
        {
<span class="nc" id="L630">            throw new UnsupportedOperationException();</span>
        }

        public final boolean hasNext()
        {
<span class="fc" id="L635">            return __pos.has_next();</span>
        }

        public IonValue next()
        {
<span class="fc" id="L640">            SystemIteratorPosition pos = next_index_helper();</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">            if (pos == null) {</span>
<span class="nc" id="L642">                throw new NoSuchElementException();</span>
            }
<span class="fc" id="L644">            IonValueLite current_value = set_position(pos);</span>
<span class="pc bpc" id="L645" title="2 of 4 branches missed.">            assert(current_value == this.__current);</span>
<span class="fc" id="L646">            return current_value;</span>
        }

        public final int nextIndex()
        {
<span class="nc" id="L651">            SystemIteratorPosition pos = next_index_helper();</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (pos == null) {</span>
                // we can do this because we hold the __pos
                // even when we run off the end, it will be
                // positioned at the value that wasn't there
<span class="nc" id="L656">                return __pos.get_external_pos() + 1;</span>
            }
<span class="nc" id="L658">            int idx = pos.get_external_pos();</span>
<span class="nc" id="L659">            return idx;</span>
        }

        private final SystemIteratorPosition next_index_helper()
        {
<span class="fc" id="L664">            SystemIteratorPosition next = null;</span>
<span class="fc" id="L665">            force_position_sync();</span>

<span class="pc bpc" id="L667" title="1 of 2 branches missed.">            if (__pos.has_next() == false) {</span>
<span class="nc" id="L668">                return null;</span>
            }

            // at this point we will have a next so prep out position now
<span class="fc" id="L672">            next = __temp_pos;</span>
<span class="pc bpc" id="L673" title="3 of 6 branches missed.">            assert(next != null &amp;&amp; next != __pos);</span>
<span class="fc" id="L674">            next.copyFrom(__pos);</span>

            // see if there's a system value waiting for use
<span class="fc" id="L677">            next.__local_index++;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">            if (next.__local_index &lt; next.__local_value_count) {</span>
<span class="fc" id="L679">                return next;</span>
            }

            // if there's not system value there must be another user value
            // so we shouldn't get here since has_next() should have failed
<span class="pc bpc" id="L684" title="2 of 4 branches missed.">            assert(next.__user_index &lt;= get_child_count());</span>

            // if we were on a system value then we're just stepping onto the
            // since has_next() already declared we do have a waiting value
<span class="fc" id="L688">            next.__user_index++;</span>
<span class="fc" id="L689">            next.load_updated_position();</span>
            // we step onto the first local value
<span class="fc" id="L691">            next.__local_index = 0;</span>
<span class="fc" id="L692">            return next;</span>
        }

        public final boolean hasPrevious()
        {
<span class="nc" id="L697">            return __pos.has_prev();</span>
        }

        public IonValue previous()
        {
<span class="nc" id="L702">            SystemIteratorPosition pos = previous_index_helper();</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            if (pos == null) {</span>
<span class="nc" id="L704">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L706">            IonValueLite current_value = set_position(pos);</span>
<span class="nc bnc" id="L707" title="All 4 branches missed.">            assert(current_value == this.__current);</span>
<span class="nc" id="L708">            return current_value;</span>
        }

        public final int previousIndex()
        {
<span class="nc" id="L713">            SystemIteratorPosition pos = previous_index_helper();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (pos == null) {</span>
<span class="nc" id="L715">                return -1;</span>
            }
<span class="nc" id="L717">            int idx = pos.get_external_pos();</span>
<span class="nc" id="L718">            return idx;</span>
        }

        private final SystemIteratorPosition previous_index_helper()
        {
<span class="nc" id="L723">            SystemIteratorPosition prev = null;</span>

<span class="nc" id="L725">            force_position_sync();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (__pos.has_prev() == false) {</span>
<span class="nc" id="L727">                return null;</span>
            }

            // at this point we will have a prev so prep out position now
<span class="nc" id="L731">            prev = __temp_pos;</span>
<span class="nc bnc" id="L732" title="All 6 branches missed.">            assert(prev != null &amp;&amp; prev != __pos);</span>
<span class="nc" id="L733">            prev.copyFrom(__pos);</span>

<span class="nc" id="L735">            prev.__local_index--;</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (prev.__local_index &gt;= 0) {</span>
<span class="nc" id="L737">                return prev;</span>
            }

            // if there's not system value there must be another user value
            // we would have bailed with has_prev returned false above otherwise
<span class="nc bnc" id="L742" title="All 4 branches missed.">            assert(prev.__user_index &gt; 0);</span>

            // if this is the 2nd prev then we really have to back up
<span class="nc" id="L745">            prev.__index_adjustment -= prev.__local_value_count;</span>
<span class="nc" id="L746">            prev.__user_index--;</span>
<span class="nc" id="L747">            prev.load_updated_position();</span>

            // going backwards we &quot;start&quot; at the end of our local list
<span class="nc" id="L750">            prev.__local_index = prev.__local_value_count - 1;</span>

<span class="nc" id="L752">            return prev;</span>
        }

        /**
         * removes the current member from the containing
         * datagram if it is a user value.
         *
         * If there is no current value it throws NoSuchElementException
         * If the current value is not a user value in the datagram
         * this throws UnsupportedOperationException.
         * And if the iterator is a read only iterator this also
         * throws UnsupportedOperationException.
         */
        public void remove()
        {
<span class="nc bnc" id="L767" title="All 2 branches missed.">            if (__readOnly) {</span>
<span class="nc" id="L768">                throw new UnsupportedOperationException();</span>
            }
<span class="nc" id="L770">            force_position_sync();</span>

<span class="nc bnc" id="L772" title="All 4 branches missed.">            if (__current == null || __pos == null) {</span>
<span class="nc" id="L773">                throw new NoSuchElementException();</span>
            }
<span class="nc bnc" id="L775" title="All 2 branches missed.">            if (__pos.on_system_value()) {</span>
<span class="nc" id="L776">                throw new UnsupportedOperationException();</span>
            }

<span class="nc" id="L779">            int idx = __pos.__user_index;</span>
<span class="nc bnc" id="L780" title="All 4 branches missed.">            assert(idx &gt;= 0);</span>

<span class="nc" id="L782">            IonValueLite concrete = __current;</span>
<span class="nc" id="L783">            int concrete_idx = concrete._elementid();</span>
<span class="nc bnc" id="L784" title="All 4 branches missed.">            assert(concrete_idx == idx);</span>

            // here we remove the member from the container's list of elements
<span class="nc" id="L787">            remove_child(idx);</span>
<span class="nc" id="L788">            patch_elements_helper(concrete_idx);</span>

            // when we remove the current value we remove
            // its associated system values and this
            // may change the index adjustment
<span class="nc" id="L793">            __pos.__index_adjustment -= __pos.__local_value_count;</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">            if (__pos.__user_index &lt; get_child_count() - 1)</span>
            {
<span class="nc" id="L796">                __pos.load_updated_position();</span>
<span class="nc" id="L797">                __pos.__local_index = -1;</span>
            }
<span class="nc" id="L799">            __current = null;</span>
<span class="nc" id="L800">        }</span>

        public void set(IonValue element)
        {
<span class="nc" id="L804">            throw new UnsupportedOperationException();</span>
        }
        protected int get_datagram_child_count()
        {
<span class="fc" id="L808">            return get_child_count();</span>
        }
        protected IonValueLite get_datagram_child(int idx)
        {
<span class="fc" id="L812">            return get_child(idx);</span>
        }
        protected IonSystem get_datagram_system()
        {
<span class="fc" id="L816">            return _system;</span>
        }
        protected boolean datagram_contains(IonValueLite value)
        {
<span class="nc" id="L820">            return contains(value);</span>
        }
        protected IonSymbolLite get_datagram_ivm()
        {
<span class="fc" id="L824">            return get_ivm();</span>
        }
    }
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">    static class SystemIteratorPosition</span>
    {
        /**
         * this position points to the user value that
         * we might have just passed calling next
         *
         * that is this position is between the last
         * value returned by next and the next value
         * that will be returned.
         *
         * As we change the user index we load the
         * current user value and synthesize any needed
         * local system values
         *
         * we also push the user value onto the same
         * local stack.  that way out local index can
         * run off either end of the local &quot;list&quot;
         * and only when we go yet another past either
         * end do we need to reload the value to
         * one side of the other, and which side of
         * our local list we ran off of will tell
         * us that.
         */
        protected final SystemContentIterator __iterator;
        protected       int                   __index_adjustment;      // delta between the user_content_pos and the external_pos

        protected       int                   __local_index;           // index of the next value in the system array (__local_system_value), if __on_system_value
<span class="fc" id="L854">        protected       IonValueLite[]        __local_values = new IonValueLite[3]; // more than the value, a symbol table, and a version marker would be MOST unusual</span>
        protected       int                   __local_value_count;

        protected       int                   __user_index;            // index of next value in the user content array (_children)
        protected       IonValueLite          __current_user_value;    // value from the child array at the time the user_index was moved forward == get_child(next_user_index -1)
        protected       SymbolTable           __current_symbols;
        protected       int                   __current_symbols_index;

        SystemIteratorPosition(SystemContentIterator iterator)
<span class="fc" id="L863">        {</span>
<span class="fc" id="L864">            __iterator = iterator;</span>
<span class="fc" id="L865">        }</span>

        void load_initial_position()
        {
<span class="fc" id="L869">            __user_index = 0;</span>
<span class="fc" id="L870">            __local_index = -1; // we're before the first value</span>
<span class="fc" id="L871">            __current_symbols_index = -1;</span>
<span class="fc" id="L872">            load_updated_position();</span>
<span class="fc" id="L873">        }</span>

        protected int get_external_pos()
        {
            int user_index;
<span class="nc" id="L878">            user_index  = __user_index;</span>
<span class="nc" id="L879">            user_index += __index_adjustment;</span>
<span class="nc" id="L880">            user_index -= __local_value_count;</span>
<span class="nc" id="L881">            user_index += __local_index;</span>
<span class="nc" id="L882">            return user_index;</span>
        }

        protected boolean on_system_value()
        {
<span class="nc bnc" id="L887" title="All 2 branches missed.">            return (__current_user_value != __local_values[0]);</span>
        }
        protected boolean has_next()
        {
<span class="fc bfc" id="L891" title="All 2 branches covered.">            if (__local_index + 1 &lt; __local_value_count) {</span>
<span class="fc" id="L892">                return true;</span>
            }
<span class="fc bfc" id="L894" title="All 2 branches covered.">            if (__user_index + 1 &lt; __iterator.get_datagram_child_count()) {</span>
<span class="fc" id="L895">                return true;</span>
            }
<span class="fc" id="L897">            return false;</span>
        }
        protected boolean has_prev()
        {
            // if we're not at the beginning of the datagram list
            // we always have another user value
<span class="nc bnc" id="L903" title="All 2 branches missed.">            if (__user_index &gt; 0) {</span>
<span class="nc" id="L904">                return true;</span>
            }
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (__local_index &gt; 0) {</span>
<span class="nc" id="L907">                return true;</span>
            }
            // we're out of both user and system values
<span class="nc" id="L910">            return false;</span>
        }

        protected void copyFrom(SystemIteratorPosition source)
        {
<span class="fc" id="L915">            this.__index_adjustment         = source.__index_adjustment;</span>
<span class="fc" id="L916">            this.__user_index               = source.__user_index;</span>
<span class="fc" id="L917">            this.__local_index              = source.__local_index;</span>
<span class="fc" id="L918">            this.__current_user_value       = source.__current_user_value;</span>
<span class="fc" id="L919">            this.__current_symbols          = source.__current_symbols;</span>
<span class="fc" id="L920">            this.__current_symbols_index    = source.__current_symbols_index;</span>

            // for the local system values each position needs its own
            // array, but the can share the value references
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">            if (source.__local_value_count &gt; 0) {</span>
<span class="pc bpc" id="L925" title="1 of 4 branches missed.">                if (this.__local_values == null || source.__local_value_count &gt;= this.__local_values.length) {</span>
<span class="fc" id="L926">                    this.__local_values = new IonValueLite[source.__local_values.length];</span>
                }
<span class="fc" id="L928">                System.arraycopy(source.__local_values, 0, this.__local_values, 0, source.__local_value_count);</span>
            }
<span class="fc" id="L930">            this.__local_value_count = source.__local_value_count;</span>
<span class="fc" id="L931">        }</span>

        private void load_updated_position()
        {
<span class="fc" id="L935">            IonValueLite prev_value = __current_user_value;</span>
            // we load our referenced user value (@ __user_index if
            // it exists).
<span class="pc bpc" id="L938" title="2 of 6 branches missed.">            if (__user_index &lt; 0 || (__user_index &gt; 0 &amp;&amp; __user_index &gt;=  __iterator.get_datagram_child_count())) {</span>
<span class="nc" id="L939">                throw new IonException(&quot;attempt to position iterator past end of values&quot;);</span>
            }
<span class="fc bfc" id="L941" title="All 2 branches covered.">            if (__user_index &lt; __iterator.get_datagram_child_count()) {</span>
<span class="fc" id="L942">                __current_user_value = __iterator.get_datagram_child(__user_index);</span>
<span class="pc bpc" id="L943" title="2 of 4 branches missed.">                assert(__current_user_value != null);</span>
            }
            else {
                // when there are no user values and we're at index == 0
<span class="pc bpc" id="L947" title="3 of 6 branches missed.">                assert(__user_index == 0 &amp;&amp; __iterator.get_datagram_child_count() == 0);</span>
<span class="fc" id="L948">                __current_user_value = null;</span>
            }

<span class="fc" id="L951">            int old_count = __local_value_count;</span>
<span class="fc" id="L952">            __local_value_count = 0;</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">            if (__current_user_value != null) {</span>
<span class="fc" id="L954">                push_system_value(__current_user_value);</span>
            }
<span class="fc" id="L956">            load_current_symbol_table(prev_value);</span>

<span class="fc bfc" id="L958" title="All 2 branches covered.">            for (int ii=__local_value_count; ii&lt;old_count; ii++) {</span>
<span class="fc" id="L959">                __local_values[ii] = null;</span>
            }
<span class="fc" id="L961">            __index_adjustment += __local_value_count - 1;</span>

<span class="fc" id="L963">            return;</span>
        }

        void load_current_symbol_table(IonValueLite prev_user_value)
        {
<span class="fc" id="L968">            IonValueLite curr_value  = __current_user_value;</span>
<span class="fc" id="L969">            int          curr_index  = __user_index;</span>

<span class="fc" id="L971">            IonValueLite prev_value  = prev_user_value;</span>
<span class="fc" id="L972">            SymbolTable  prev_symtab = __current_symbols;</span>
<span class="fc" id="L973">            int          prev_index  = __current_symbols_index;</span>

            // set our new position symbol table
<span class="fc" id="L976">            __current_symbols  = null;</span>
<span class="fc" id="L977">            __current_symbols_index = curr_index;</span>
<span class="fc" id="L978">            SymbolTable  curr_symtab = null;</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">           if (curr_value != null) {</span>
<span class="fc" id="L980">                curr_symtab = curr_value.getAssignedSymbolTable();</span>
<span class="fc" id="L981">                __current_symbols = curr_symtab;</span>
            }

            // if we need to we reset the previous values here
            // this happens when the caller is scanning backwards
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">            if (curr_index - 1 != prev_index) {</span>
<span class="nc" id="L987">                prev_index = curr_index - 1;</span>
<span class="nc" id="L988">                prev_symtab = null;</span>
<span class="nc bnc" id="L989" title="All 4 branches missed.">                if (prev_index &gt;= 0 &amp;&amp; prev_index &lt; __iterator.get_datagram_child_count()) {</span>
<span class="nc" id="L990">                    prev_value  = __iterator.get_datagram_child(prev_index);</span>
<span class="nc" id="L991">                    prev_symtab = prev_value.getAssignedSymbolTable();</span>
                }
            }

            // Now if there was a change push the local symbol
            // tables onto our system value stack

            // note that our chain of preceding symbol tables
            // might match our list of previous structs in the
            // user list.  Until there's a difference we don't
            // push the symbol tables (because they've already
            // been processed as real values).
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            if (curr_symtab != prev_symtab) {</span>
<span class="fc" id="L1004">                SymbolTable new_symbol_table = curr_symtab;</span>
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">                while (new_symbol_table != null)</span>
                {
<span class="fc" id="L1007">                    final boolean new_symbol_table_is_system = new_symbol_table.isSystemTable();</span>
                    IonValue rep;
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">                    if (new_symbol_table_is_system) {</span>
<span class="nc" id="L1010">                        rep = __iterator.get_datagram_ivm();</span>
                    }
                    else {
<span class="fc" id="L1013">                        rep = PrivateUtils.symtabTree(new_symbol_table);</span>
                    }
<span class="pc bpc" id="L1015" title="3 of 6 branches missed.">                    assert(rep != null &amp;&amp; __iterator.get_datagram_system() == rep.getSystem());</span>

<span class="pc bpc" id="L1017" title="4 of 6 branches missed.">                    if (rep == prev_value || (is_ivm(curr_value) &amp;&amp; new_symbol_table_is_system)) {</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                        int prev_idx = (prev_value == null) ? -1 : (prev_value._elementid() - 1);</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                        if (prev_idx &gt;= 0) {</span>
<span class="nc" id="L1020">                            prev_value = __iterator.get_datagram_child(prev_idx);</span>
                        }
                        else {
<span class="nc" id="L1023">                            prev_value = null;</span>
                        }
<span class="nc" id="L1025">                    }</span>
                    else {
<span class="fc" id="L1027">                        push_system_value((IonValueLite)rep);</span>
<span class="fc" id="L1028">                        prev_value = null; // end of the matches</span>
                    }
<span class="fc" id="L1030">                    new_symbol_table = rep.getSymbolTable();</span>
<span class="pc bpc" id="L1031" title="2 of 4 branches missed.">                    if (new_symbol_table == null || new_symbol_table.isSystemTable()) {</span>
<span class="fc" id="L1032">                        break;</span>
                    }
<span class="nc" id="L1034">                }</span>
            }
            // and at the front we need to put in the ion version marker
<span class="pc bpc" id="L1037" title="1 of 4 branches missed.">            if (curr_index == 0 &amp;&amp; !is_ivm(curr_value)) {</span>
                // TODO this is wrong, because we may have already pushed
                // a rep above. This is just making up an additional symtab
                // where one was not placed by the user.
<span class="fc" id="L1041">                IonValueLite ivm = __iterator.get_datagram_ivm();</span>
<span class="fc" id="L1042">                push_system_value(ivm);</span>
            }
<span class="fc" id="L1044">        }</span>

        private static final boolean is_ivm(IonValue value)
        {
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            if (value instanceof IonSymbol</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">                &amp;&amp; value.getTypeAnnotationSymbols().length == 0) {</span>
                // $ion_1_0 is read as an IVM only if it is not annotated
<span class="fc" id="L1051">                IonSymbol sym = (IonSymbol)value;</span>
<span class="fc" id="L1052">                SymbolToken tok = sym.symbolValue();</span>
<span class="pc bpc" id="L1053" title="1 of 4 branches missed.">                if (tok != null &amp;&amp; ION_1_0.equals(tok.getText()))</span>
                {
<span class="nc" id="L1055">                    return true;</span>
                }
            }
<span class="fc" id="L1058">            return false;</span>
        }

        private void push_system_value(IonValueLite value)
        {
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">            if (__local_value_count &gt;= __local_values.length) {</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                int new_size = (__local_values == null) ? 2 : (__local_values.length * 2);</span>
<span class="nc bnc" id="L1065" title="All 4 branches missed.">                assert( new_size &gt; __local_value_count); // we should only need to add 1 value at a time</span>
<span class="nc" id="L1066">                IonValueLite[] temp = new IonValueLite[new_size];</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                if (__local_value_count &gt; 0) {</span>
<span class="nc" id="L1068">                    System.arraycopy(__local_values, 0, temp, 0, __local_value_count);</span>
                }
<span class="nc" id="L1070">                __local_values = temp;</span>
            }
<span class="fc" id="L1072">            __local_values[__local_value_count++] = value;</span>
<span class="fc" id="L1073">        }</span>

        protected IonValueLite load_position()
        {
<span class="fc" id="L1077">            IonValueLite current = null;</span>

<span class="pc bpc" id="L1079" title="2 of 4 branches missed.">            assert(__local_index &lt; __local_value_count);</span>

<span class="fc" id="L1081">            current = __local_values[__local_value_count - __local_index - 1];</span>

<span class="fc" id="L1083">            return current;</span>
        }

        private final void force_position_sync_helper()
        {
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            if (!__iterator.datagram_contains(__current_user_value)) {</span>
<span class="nc" id="L1089">                throw new IonException(&quot;current user value removed outside this iterator - position lost&quot;);</span>
            }
<span class="nc" id="L1091">            int old_index = __user_index;</span>
<span class="nc" id="L1092">            int new_index = __current_user_value._elementid();</span>

<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (old_index != new_index) {</span>
                // if our current value moved we have to recompute
                // the adjustment from scratch since we don't really
                // have any idea why this moved in either direction.
<span class="nc" id="L1098">                int adjustment = 0;</span>
<span class="nc" id="L1099">                SymbolTable curr, prev = null;</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                for (int ii=0; ii&lt;new_index; ii--) {</span>
<span class="nc" id="L1101">                    curr = __iterator.get_datagram_child(ii).getSymbolTable();</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                    if (curr != prev) {</span>
<span class="nc" id="L1103">                        IonSystem sys = __iterator.getSystem();</span>
<span class="nc" id="L1104">                        adjustment += count_system_values(sys, prev, curr);</span>
                    }
<span class="nc" id="L1106">                    prev = curr;</span>
                }
<span class="nc" id="L1108">                __index_adjustment = adjustment + __local_value_count;</span>
<span class="nc" id="L1109">                __user_index = new_index;</span>
            }
<span class="nc" id="L1111">        }</span>

        private static int count_system_values(IonSystem sys,
                                               SymbolTable prev,
                                               SymbolTable curr)
        {
<span class="nc" id="L1117">            int count = 0;</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">            while (curr.isLocalTable()) {</span>
<span class="nc" id="L1119">                count++;</span>
<span class="nc" id="L1120">                curr = PrivateUtils.symtabTree(curr).getSymbolTable();</span>
            }
            // we should terminate when the symbol tables symbol table is the system symbol table
<span class="nc bnc" id="L1123" title="All 4 branches missed.">            assert(curr != null);</span>
<span class="nc bnc" id="L1124" title="All 4 branches missed.">            if (prev == null || prev.getIonVersionId().equals(curr.getIonVersionId())) {</span>
<span class="nc" id="L1125">                count++;</span>
            }
<span class="nc" id="L1127">            return count;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>