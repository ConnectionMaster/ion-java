<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonStructLite.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl.lite</a> &gt; <span class="el_source">IonStructLite.java</span></div><h1>IonStructLite.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2010-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl.lite;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import software.amazon.ion.ContainedValueException;
import software.amazon.ion.IonStruct;
import software.amazon.ion.IonType;
import software.amazon.ion.IonValue;
import software.amazon.ion.IonWriter;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.ValueFactory;
import software.amazon.ion.ValueVisitor;
import software.amazon.ion.impl.PrivateCurriedValueFactory;
import software.amazon.ion.util.Equivalence;
import java.util.Set;
import software.amazon.ion.UnknownSymbolException;

<span class="pc bpc" id="L39" title="1 of 2 branches missed.">final class IonStructLite</span>
    extends IonContainerLite
    implements IonStruct
{
<span class="fc" id="L43">    private static final int HASH_SIGNATURE =</span>
<span class="fc" id="L44">        IonType.STRUCT.toString().hashCode();</span>
    // TODO amzn/ion-java#41: add support for _isOrdered

    IonStructLite(ContainerlessContext context, boolean isNull)
    {
<span class="fc" id="L49">        super(context, isNull);</span>
<span class="fc" id="L50">    }</span>

    private IonStructLite(IonStructLite existing, IonContext context)
    {
<span class="fc" id="L54">        super(existing, context, true);</span>
        // field map can be shallow cloned due to it dealing with String and Integer
        // values - both of which are immutable constructs and so safe to retain as references
<span class="fc bfc" id="L57" title="All 2 branches covered.">        this._field_map = null == existing._field_map ? null : new HashMap&lt;String, Integer&gt;(existing._field_map);</span>
<span class="fc" id="L58">        this._field_map_duplicate_count = existing._field_map_duplicate_count;</span>
<span class="fc" id="L59">        this.hasNullFieldName = existing.hasNullFieldName;</span>
<span class="fc" id="L60">    }</span>

    private Map&lt;String, Integer&gt; _field_map;
<span class="fc" id="L63">    private boolean hasNullFieldName = false;</span>

    public int                      _field_map_duplicate_count;

    @Override
    IonStructLite clone(IonContext parentContext)
    {
<span class="fc" id="L70">        return new IonStructLite(this, parentContext);</span>
    }

    @Override
    public IonStructLite clone()
    {
<span class="fc" id="L76">        return clone(ContainerlessContext.wrap(getSystem()));</span>
    }

    @Override
    protected void transitionToLargeSize(int size)
    {
<span class="fc bfc" id="L82" title="All 2 branches covered.">        if (_field_map != null) return;</span>

<span class="fc" id="L84">        build_field_map();</span>
<span class="fc" id="L85">        return;</span>
    }
    protected void build_field_map()
    {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        int size = (_children == null) ? 0 : _children.length;</span>

<span class="fc" id="L91">        _field_map = new HashMap&lt;String, Integer&gt;(size);</span>
<span class="fc" id="L92">        _field_map_duplicate_count = 0;</span>

<span class="fc" id="L94">        int count = get_child_count();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        for (int ii=0; ii&lt;count; ii++) {</span>
<span class="fc" id="L96">            IonValueLite v = get_child(ii);</span>
<span class="fc" id="L97">            SymbolToken fieldNameSymbol = v.getFieldNameSymbol();</span>
<span class="fc" id="L98">            String name = fieldNameSymbol.getText();</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">            if (_field_map.get(name) != null) {</span>
<span class="fc" id="L100">                _field_map_duplicate_count++;</span>
            }
<span class="fc" id="L102">            _field_map.put(name, ii); // this causes the map to have the largest index value stored</span>
        }
<span class="fc" id="L104">        return;</span>
    }
    private void add_field(String fieldName, int newFieldIdx)
    {
<span class="fc" id="L108">        Integer idx = _field_map.get(fieldName);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (idx != null) {</span>
<span class="fc" id="L110">            _field_map_duplicate_count++;</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            if (idx.intValue() &gt; newFieldIdx) {</span>
<span class="nc" id="L112">                newFieldIdx = idx.intValue();</span>
            }
        }
<span class="fc" id="L115">        _field_map.put(fieldName, newFieldIdx);</span>
<span class="fc" id="L116">    }</span>
    private void remove_field(String fieldName, int lowest_idx, int copies)
    {
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (_field_map == null) {</span>
<span class="fc" id="L120">            return;</span>
        }

<span class="fc" id="L123">        Integer field_idx = _field_map.get(fieldName);</span>
<span class="pc bpc" id="L124" title="2 of 4 branches missed.">        assert(field_idx != null);</span>
<span class="fc" id="L125">        _field_map.remove(fieldName);</span>
<span class="fc" id="L126">        _field_map_duplicate_count -= (copies - 1);</span>
<span class="fc" id="L127">    }</span>

    private void remove_field_from_field_map(String fieldName, int idx)
    {
<span class="fc" id="L131">        Integer field_idx = _field_map.get(fieldName);</span>
<span class="pc bpc" id="L132" title="2 of 4 branches missed.">        assert(field_idx != null);</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (field_idx.intValue() != idx) {</span>
            // if the map has a different index, this must
            // be a duplicate, and this copy isn't in the map
<span class="pc bpc" id="L137" title="2 of 4 branches missed.">            assert(_field_map_duplicate_count &gt; 0);</span>
<span class="fc" id="L138">            _field_map_duplicate_count--;</span>
        }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        else if (_field_map_duplicate_count &gt; 0) {</span>
            // if we have any duplicates we have to check
            // every time since we don't track which field
            // is duplicated - so any dup can be expensive
<span class="fc" id="L144">            int ii = find_last_duplicate(fieldName, idx);</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (ii == -1) {</span>
                // this is the last copy of this key
<span class="fc" id="L148">                _field_map.remove(fieldName);</span>
            }
            else {
                // replaces this fields (the one being
                // removed) array idx in the map with
                // the preceding duplicates index
<span class="fc" id="L154">                _field_map.put(fieldName, ii);</span>
<span class="fc" id="L155">                _field_map_duplicate_count--;</span>
            }
<span class="fc" id="L157">        }</span>
        else {
            // since there are not dup's we can just update
            // the map by removing this fieldname
<span class="fc" id="L161">            _field_map.remove(fieldName);</span>
        }
<span class="fc" id="L163">    }</span>

    private void patch_map_elements_helper(int removed_idx)
    {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (_field_map == null) {</span>
<span class="fc" id="L168">            return;</span>
        }

<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (removed_idx &gt;= get_child_count()) {</span>
            // if this was the at the end of the list
            // there's nothing to change
<span class="fc" id="L174">            return;</span>
        }

<span class="fc bfc" id="L177" title="All 2 branches covered.">        for (int ii=removed_idx; ii&lt;get_child_count(); ii++) {</span>
<span class="fc" id="L178">            IonValueLite value = get_child(ii);</span>
<span class="fc" id="L179">            String  field_name = value.getFieldName();</span>
<span class="fc" id="L180">            Integer map_idx = _field_map.get(field_name);</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            if (map_idx.intValue() != ii) {</span>
                // if this is a field that to the right of
                // the removed (in process of removing) value
                // we need to patch the index value
<span class="fc" id="L185">                _field_map.put(field_name, ii);</span>
            }
        }
<span class="fc" id="L188">    }</span>

    @Override
    public void dump(PrintWriter out)
    {
<span class="nc" id="L193">        super.dump(out);</span>

<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (_field_map == null) {</span>
<span class="nc" id="L196">            return;</span>
        }

<span class="nc" id="L199">        out.println(&quot;   dups: &quot;+_field_map_duplicate_count);</span>
<span class="nc" id="L200">        Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = _field_map.entrySet().iterator();</span>
<span class="nc" id="L201">        out.print(&quot;   map: [&quot;);</span>
<span class="nc" id="L202">        boolean first = true;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L204">            Entry&lt;String, Integer&gt; e = it.next();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (!first) {</span>
<span class="nc" id="L206">                out.print(&quot;,&quot;);</span>
            }
<span class="nc" id="L208">            out.print(e.getKey()+&quot;:&quot;+e.getValue());</span>
<span class="nc" id="L209">            first = false;</span>
<span class="nc" id="L210">        }</span>
<span class="nc" id="L211">        out.println(&quot;]&quot;);</span>
<span class="nc" id="L212">    }</span>

    @Override
    public String validate()
    {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (_field_map == null) {</span>
<span class="nc" id="L218">            return null;</span>
        }
<span class="nc" id="L220">        String error = &quot;&quot;;</span>
<span class="nc" id="L221">        Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = _field_map.entrySet().iterator();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L223">            Entry&lt;String, Integer&gt; e = it.next();</span>
<span class="nc" id="L224">            int idx = e.getValue().intValue();</span>
<span class="nc bnc" id="L225" title="All 4 branches missed.">            IonValueLite v = (idx &gt;= 0 &amp;&amp; idx &lt; get_child_count()) ? get_child(idx) : null;</span>
<span class="nc bnc" id="L226" title="All 6 branches missed.">            if (v == null || idx != v._elementid() || (e.getKey().equals(v.getFieldName()) == false)) {</span>
<span class="nc" id="L227">                error += &quot;map entry [&quot;+e+&quot;] doesn't match list value [&quot;+v+&quot;]\n&quot;;</span>
            }
<span class="nc" id="L229">        }</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">        return (error == &quot;&quot;) ? null : error;</span>
    }

    private int find_last_duplicate(String fieldName, int existing_idx)
    {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (int ii=existing_idx; ii&gt;0; ) {</span>
<span class="fc" id="L237">            ii--;</span>
<span class="fc" id="L238">            IonValueLite field = get_child(ii);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (fieldName.equals(field.getFieldName())) {</span>
<span class="fc" id="L240">                return ii;</span>
            }
<span class="fc" id="L242">        }</span>
<span class="pc bpc" id="L243" title="2 of 4 branches missed.">        assert(there_is_only_one(fieldName, existing_idx));</span>
<span class="fc" id="L244">        return -1;</span>
    }
    private boolean there_is_only_one(String fieldName, int existing_idx)
    {
<span class="fc" id="L248">        int count = 0;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (int ii=0; ii&lt;get_child_count(); ii++) {</span>
<span class="fc" id="L250">            IonValueLite v = get_child(ii);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (v.getFieldName().equals(fieldName)) {</span>
<span class="fc" id="L252">                count++;</span>
            }
        }
<span class="pc bpc" id="L255" title="3 of 4 branches missed.">        if (count == 1 || count == 0) {</span>
<span class="fc" id="L256">            return true;</span>
        }
<span class="nc" id="L258">        return false;</span>
    }
//
//    updateFieldName is unnecessary since field names are immutable
//    (except when the value is unattached to any struct)
//
//    protected void updateFieldName(String oldname, String name, IonValue field)
//    {
//        assert(name != null &amp;&amp; name.equals(field.getFieldName()));
//
//        if (oldname == null) return;
//        if (_field_map == null) return;
//
//        Integer idx = _field_map.get(oldname);
//        if (idx == null) return;
//
//        IonValue oldfield = get_child(idx);
//
//        // yes, we want object identity in this test
//        if (oldfield == field) {
//            remove_field(oldname, idx);
//            add_field(name, idx);
//        }
//    }

    /**
     * Implements {@link Object#hashCode()} consistent with equals.
     * This is insensitive to order of fields.
     * &lt;p&gt;
     * This method must follow the contract of {@link Object#equals(Object)},
     * which is located at {@link Equivalence#ionEquals(IonValue, IonValue)}.
     *
     * @return  An int, consistent with the contracts for
     *          {@link Object#hashCode()} and {@link Object#equals(Object)}.
     */
    @Override
    int hashCode(SymbolTableProvider symbolTableProvider)
    {
<span class="fc" id="L296">        final int nameHashSalt  = 16777619; // prime to salt name of each Field</span>
<span class="fc" id="L297">        final int valueHashSalt = 8191;     // prime to salt value of each Field</span>
<span class="fc" id="L298">        final int sidHashSalt   = 127;      // prime to salt sid of fieldname</span>
<span class="fc" id="L299">        final int textHashSalt  = 31;       // prime to salt text of fieldname</span>

<span class="fc" id="L301">        int result = HASH_SIGNATURE;</span>

<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (!isNullValue())  {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            for (IonValue v : this)  {</span>
<span class="fc" id="L305">                IonValueLite vlite = (IonValueLite) v;</span>
                // If fieldname's text is unknown, use its sid instead
<span class="fc" id="L307">                SymbolToken token = vlite.getFieldNameSymbol(symbolTableProvider);</span>
<span class="fc" id="L308">                String text = token.getText();</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">                int nameHashCode = text == null</span>
<span class="fc" id="L311">                    ? token.getSid()  * sidHashSalt</span>
<span class="fc" id="L312">                    : text.hashCode() * textHashSalt;</span>

                // mixing to account for small text and sid deltas
<span class="fc" id="L315">                nameHashCode ^= (nameHashCode &lt;&lt; 17) ^ (nameHashCode &gt;&gt; 15);</span>

<span class="fc" id="L317">                int fieldHashCode = HASH_SIGNATURE;</span>
<span class="fc" id="L318">                fieldHashCode = valueHashSalt * fieldHashCode + vlite.hashCode(symbolTableProvider);</span>
<span class="fc" id="L319">                fieldHashCode = nameHashSalt  * fieldHashCode + nameHashCode;</span>

                // another mix step for each Field of the struct
<span class="fc" id="L322">                fieldHashCode ^= (fieldHashCode &lt;&lt; 19) ^ (fieldHashCode &gt;&gt; 13);</span>

                // Additive hash is used to ensure insensitivity to order of
                // fields, and will not lose data on value hash codes
<span class="fc" id="L326">                result += fieldHashCode;</span>
<span class="fc" id="L327">            }</span>
        }

<span class="fc" id="L330">        return hashTypeAnnotations(result, symbolTableProvider);</span>
    }

    public IonStruct cloneAndRemove(String... fieldNames)
    {
<span class="fc" id="L335">        return doClone(false, fieldNames);</span>
    }

    public IonStruct cloneAndRetain(String... fieldNames)
    {
<span class="fc" id="L340">        return doClone(true, fieldNames);</span>
    }

    private IonStruct doClone(boolean keep, String... fieldNames)
    {
        IonStruct clone;
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (isNullValue())</span>
        {
<span class="fc" id="L348">            clone = getSystem().newNullStruct();</span>
        }
        else
        {
<span class="fc" id="L352">            Set&lt;String&gt; fields =</span>
<span class="fc" id="L353">                new HashSet&lt;String&gt;(Arrays.asList(fieldNames));</span>
<span class="fc bfc" id="L354" title="All 4 branches covered.">            if (keep &amp;&amp; fields.contains(null))</span>
            {
<span class="fc" id="L356">                throw new NullPointerException(&quot;Can't retain an unknown field name&quot;);</span>
            }

<span class="fc" id="L359">            clone = getSystem().newEmptyStruct();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            for (IonValue value : this)</span>
            {
<span class="fc" id="L362">                SymbolToken fieldNameSymbol = value.getFieldNameSymbol();</span>
<span class="fc" id="L363">                String fieldName = fieldNameSymbol.getText();</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                if (fields.contains(fieldName) == keep)</span>
                {
                    // This ensures that we don't copy an unknown field name.
<span class="fc" id="L367">                    fieldName = value.getFieldName();</span>
<span class="fc" id="L368">                    clone.add(fieldName, value.clone());</span>
                }
<span class="fc" id="L370">            }</span>
        }

<span class="fc" id="L373">        clone.setTypeAnnotationSymbols(getTypeAnnotationSymbols());</span>

<span class="fc" id="L375">        return clone;</span>
    }


    @Override
    public IonType getType()
    {
<span class="fc" id="L382">        return IonType.STRUCT;</span>
    }


    public boolean containsKey(Object fieldName)
    {
<span class="fc" id="L388">        String name = (String) fieldName;</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">        return (null != get(name));</span>
    }

    public boolean containsValue(Object value)
    {
<span class="fc" id="L394">        IonValue v = (IonValue) value;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        return (v.getContainer() == this);</span>
    }

    public IonValue get(String fieldName)
    {
<span class="fc" id="L400">        int field_idx = find_field_helper(fieldName);</span>
        IonValue field;

<span class="fc bfc" id="L403" title="All 2 branches covered.">        if (field_idx &lt; 0) {</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            if(hasNullFieldName) throw new UnknownSymbolException(&quot;Unable to determine whether the field exists because the struct contains field names with unknown text.&quot;);</span>
<span class="fc" id="L405">            field = null;</span>
        } else {
<span class="fc" id="L407">            field = get_child(field_idx);</span>
        }

<span class="fc" id="L410">        return field;</span>
    }
    private int find_field_helper(String fieldName)
    {
<span class="fc" id="L414">        validateFieldName(fieldName);</span>

<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (isNullValue()) {</span>
            // nothing to see here, move along
        }
<span class="fc bfc" id="L419" title="All 2 branches covered.">        else if (_field_map != null) {</span>
<span class="fc" id="L420">            Integer idx = _field_map.get(fieldName);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">            if (idx != null) {</span>
<span class="fc" id="L422">                return idx.intValue();</span>
            }
<span class="fc" id="L424">        }</span>
        else {
<span class="fc" id="L426">            int ii, size = get_child_count();</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">            for (ii=0; ii&lt;size; ii++) {</span>
<span class="fc" id="L428">                IonValue field = get_child(ii);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                if (fieldName.equals(field.getFieldName())) {</span>
<span class="fc" id="L430">                    return ii;</span>
                }
            }
        }
<span class="fc" id="L434">        return -1;</span>
    }

    @Override
    public void clear()
    {
<span class="fc" id="L440">        super.clear();</span>
<span class="fc" id="L441">        _field_map = null;</span>
<span class="fc" id="L442">        _field_map_duplicate_count = 0;</span>
<span class="fc" id="L443">    }</span>

    @Override
    public boolean add(IonValue child)
        throws NullPointerException, IllegalArgumentException,
        ContainedValueException
    {
        // TODO validate in struct.setFieldName
<span class="fc" id="L451">        String text = child.getFieldNameSymbol().getText();</span>
<span class="fc" id="L452">        IonValueLite concrete = (IonValueLite) child;</span>
<span class="fc" id="L453">        _add(text, concrete);</span>

<span class="fc" id="L455">        return true;</span>
    }


    public ValueFactory add(final String fieldName)
    {
<span class="fc" id="L461">        return new PrivateCurriedValueFactory(_context.getSystem())</span>
<span class="fc" id="L462">        {</span>
            @Override
            protected void handle(IonValue newValue)
            {
<span class="fc" id="L466">                add(fieldName, newValue);</span>
<span class="fc" id="L467">            }</span>
        };
    }


    /**
     * Validates the child and checks locks.
     *
     * @param fieldName may be null
     * @param child must be validated and have field name or id set
     */
    private void _add(String fieldName, IonValueLite child)
    {
<span class="fc bfc" id="L480" title="All 2 branches covered.">        hasNullFieldName |= fieldName == null;</span>
<span class="fc" id="L481">        int size = get_child_count();</span>

        // add this to the Container child collection
<span class="fc" id="L484">        add(size, child);</span>

        // if we have a hash map we need to update it now
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (_field_map != null) {</span>
<span class="fc" id="L488">            add_field(fieldName, child._elementid());</span>
        }
<span class="fc" id="L490">    }</span>

    public void add(String fieldName, IonValue value)
    {
        // Validate everything before altering the child
<span class="fc" id="L495">        checkForLock();</span>
<span class="fc" id="L496">        validateNewChild(value);</span>
<span class="fc" id="L497">        validateFieldName(fieldName);</span>

<span class="fc" id="L499">        IonValueLite concrete = (IonValueLite) value;</span>

<span class="fc" id="L501">        _add(fieldName, concrete);</span>
<span class="fc" id="L502">        concrete.setFieldName(fieldName);</span>
<span class="fc" id="L503">    }</span>

    public void add(SymbolToken fieldName, IonValue child)
    {
<span class="fc" id="L507">        String text = fieldName.getText();</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (text != null)</span>
        {
            // Ignoring the sid is safe, but perhaps not the most efficient.
<span class="fc" id="L511">            add(text, child);</span>
<span class="fc" id="L512">            return;</span>
        }

<span class="fc bfc" id="L515" title="All 2 branches covered.">        if (fieldName.getSid() &lt; 0)</span>
        {
<span class="fc" id="L517">            throw new IllegalArgumentException(&quot;fieldName has no text or ID&quot;);</span>
        }

        // Validate everything before altering the child
<span class="fc" id="L521">        checkForLock();</span>
<span class="fc" id="L522">        validateNewChild(child);</span>

<span class="fc" id="L524">        IonValueLite concrete = (IonValueLite) child;</span>
<span class="fc" id="L525">        concrete.setFieldNameSymbol(fieldName);</span>
<span class="fc" id="L526">        _add(text, concrete);</span>
<span class="fc" id="L527">    }</span>


    public ValueFactory put(final String fieldName)
    {
<span class="fc" id="L532">        return new PrivateCurriedValueFactory(_context.getSystem())</span>
<span class="fc" id="L533">        {</span>
            @Override
            protected void handle(IonValue newValue)
            {
<span class="fc" id="L537">                put(fieldName, newValue);</span>
<span class="fc" id="L538">            }</span>
        };
    }

    public void putAll(Map&lt;? extends String, ? extends IonValue&gt; m)
    {
        // TODO this is very inefficient
<span class="fc bfc" id="L545" title="All 2 branches covered.">        for (Entry&lt;? extends String, ? extends IonValue&gt; entry : m.entrySet())</span>
        {
<span class="fc" id="L547">            put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L548">        }</span>
<span class="fc" id="L549">    }</span>

    /**
     * put is &quot;make this value the one and only value
     * associated with this fieldName&quot;.  The side effect
     * is that if there were multiple fields with this
     * name when put is complete there will only be the
     * one value in the collection.
     */
    public void put(String fieldName, IonValue value)
    {
<span class="fc" id="L560">        checkForLock();</span>

<span class="fc" id="L562">        validateFieldName(fieldName);</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (value != null) validateNewChild(value);</span>

<span class="fc" id="L565">        int lowestRemovedIndex = get_child_count();</span>
<span class="fc" id="L566">        boolean any_removed = false;</span>

        // first we remove the any existing fields
        // associated with fieldName (which may be none)
<span class="fc bfc" id="L570" title="All 4 branches covered.">        if (_field_map != null &amp;&amp; _field_map_duplicate_count == 0)</span>
        {
            // we have a map and no duplicates so the index
            // (aka map) is all we need to find the only
            // value associated with fieldName, if there is one
<span class="fc" id="L575">            Integer idx = _field_map.get(fieldName);</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">            if (idx != null) {</span>
<span class="fc" id="L577">                lowestRemovedIndex = idx.intValue();</span>
<span class="fc" id="L578">                remove_field_from_field_map(fieldName, lowestRemovedIndex);</span>
<span class="fc" id="L579">                remove_child(lowestRemovedIndex);</span>
<span class="fc" id="L580">                any_removed = true;</span>
            }
<span class="fc" id="L582">        }</span>
        else {
            // either we don't have a map (index) or there
            // are duplicates in both cases we have to
            // scan the child list directly.
            // Walk backwards to minimize array movement
            // as we remove fields as we encounter them.
<span class="fc" id="L589">            int copies_removed = 0;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">            for (int ii = get_child_count(); ii &gt; 0; )</span>
            {
<span class="fc" id="L592">                ii--;</span>
<span class="fc" id="L593">                IonValueLite child = get_child(ii);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                if (fieldName.equals(child.getFieldNameSymbol().getText()))</span>
                {
                    // done by remove_child: child.detachFromContainer();
<span class="fc" id="L597">                    remove_child(ii);</span>
<span class="fc" id="L598">                    lowestRemovedIndex = ii;</span>
<span class="fc" id="L599">                    copies_removed++;</span>
<span class="fc" id="L600">                    any_removed = true;</span>
                }
<span class="fc" id="L602">            }</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">            if (any_removed) {</span>
<span class="fc" id="L604">                remove_field(fieldName, lowestRemovedIndex, copies_removed);</span>
            }
        }
<span class="fc bfc" id="L607" title="All 2 branches covered.">        if (any_removed) {</span>
<span class="fc" id="L608">            patch_map_elements_helper(lowestRemovedIndex);</span>
<span class="fc" id="L609">            patch_elements_helper(lowestRemovedIndex);</span>
        }

        // once we've removed any existing copy we now add,
        // this (delete + add == put) turns out be be the
        // right choice since:
        //   1 - because of possible duplicates we can't
        //       guarantee the idx is stable
        //   2 - we have to maintain the hash and that
        //       really means we end up with the delete
        //       anyway
        // strictly speaking this approach, while simpler,
        // is more expensive when we don't have a has and
        // the value already exists, and it's not at the
        // end of the field list anyway.
<span class="fc bfc" id="L624" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L625">            add(fieldName, value);</span>
        }
<span class="fc" id="L627">    }</span>

    @Override
    public ListIterator&lt;IonValue&gt; listIterator(int index) {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        return new SequenceContentIterator(index, isReadOnly()) {</span>
            @Override
            public void remove() {
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">                if (__readOnly) {</span>
<span class="nc" id="L635">                    throw new UnsupportedOperationException();</span>
                }
<span class="fc" id="L637">                force_position_sync();</span>

<span class="fc" id="L639">                int idx = __pos;</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">                if (!__lastMoveWasPrevious) {</span>
                    // position is 1 ahead of the array index
<span class="fc" id="L642">                    idx--;</span>
                }
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">                if (idx &lt; 0) {</span>
<span class="nc" id="L645">                    throw new ArrayIndexOutOfBoundsException();</span>
                }

<span class="fc" id="L648">                IonValueLite concrete = __current;</span>
<span class="fc" id="L649">                int concrete_idx = concrete._elementid();</span>
<span class="pc bpc" id="L650" title="2 of 4 branches missed.">                assert(concrete_idx == idx);</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">                if (_field_map != null) {</span>
<span class="fc" id="L653">                    remove_field_from_field_map(concrete.getFieldName(), idx);</span>
                }
<span class="fc" id="L655">                super.remove();</span>

<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (_field_map != null) {</span>
<span class="fc" id="L658">                    patch_map_elements_helper(idx);</span>
                }
<span class="fc" id="L660">            }</span>
        };
    }

    public IonValue remove(String fieldName)
    {
<span class="fc" id="L666">        checkForLock();</span>

<span class="fc" id="L668">        IonValue field = get(fieldName);</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">        if (field == null) {</span>
<span class="fc" id="L670">            return null;</span>
        }

<span class="fc" id="L673">        int idx = ((IonValueLite)field)._elementid();</span>

        // update the hash map first we don't want
        // the child list changed until we've done
        // this since the map update expects the
        // index value of the remove field to be
        // correct and unchanged.
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (_field_map != null) {</span>
<span class="fc" id="L681">            remove_field_from_field_map(fieldName, idx);</span>
        }

<span class="fc" id="L684">        super.remove(field);</span>

<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (_field_map != null) {</span>
<span class="fc" id="L687">            patch_map_elements_helper(idx);</span>
        }

<span class="fc" id="L690">        return field;</span>
    }

    @Override
    public boolean remove(IonValue element)
    {
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (element == null) {</span>
<span class="fc" id="L697">            throw new NullPointerException();</span>
        }

<span class="fc" id="L700">        checkForLock();</span>

<span class="fc bfc" id="L702" title="All 2 branches covered.">        if (element.getContainer() != this) {</span>
<span class="fc" id="L703">            return false;</span>
        }

<span class="fc" id="L706">        IonValueLite concrete = (IonValueLite) element;</span>
<span class="fc" id="L707">        int idx = concrete._elementid();</span>

        // update the hash map first we don't want
        // the child list changed until we've done
        // this since the map update expects the
        // index value of the remove field to be
        // correct and unchanged.
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if (_field_map != null) {</span>
<span class="fc" id="L715">            remove_field_from_field_map(concrete.getFieldName(), idx);</span>
        }

<span class="fc" id="L718">        super.remove(concrete);</span>

<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (_field_map != null) {</span>
<span class="fc" id="L721">            patch_map_elements_helper(idx);</span>
        }

<span class="fc" id="L724">        return true;</span>
    }

    public boolean removeAll(String... fieldNames)
    {
<span class="fc" id="L729">        boolean removedAny = false;</span>

<span class="fc" id="L731">        checkForLock();</span>

<span class="fc" id="L733">        int size = get_child_count();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        for (int ii=size; ii&gt;0; ) {</span>
<span class="fc" id="L735">            ii--;</span>
<span class="fc" id="L736">            IonValue field = get_child(ii);</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">            if (isListedField(field, fieldNames)) {</span>
<span class="fc" id="L738">                field.removeFromContainer();</span>
<span class="fc" id="L739">                removedAny = true;</span>
            }
<span class="fc" id="L741">        }</span>

<span class="fc" id="L743">        return removedAny;</span>
    }

    public boolean retainAll(String... fieldNames)
    {
<span class="fc" id="L748">        checkForLock();</span>

<span class="fc" id="L750">        boolean removedAny = false;</span>
<span class="fc" id="L751">        int size = get_child_count();</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">        for (int ii=size; ii&gt;0; ) {</span>
<span class="fc" id="L753">            ii--;</span>
<span class="fc" id="L754">            IonValue field = get_child(ii);</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">            if (! isListedField(field, fieldNames))</span>
            {
<span class="fc" id="L757">                field.removeFromContainer();</span>
<span class="fc" id="L758">                removedAny = true;</span>
            }
<span class="fc" id="L760">        }</span>
<span class="fc" id="L761">        return removedAny;</span>
    }

    /**
     *
     * @param field must not be null.  It is not required to have a field name.
     * @param fields must not be null, and must not contain and nulls.
     * @return true if {@code field.getFieldName()} is in {@code fields}.
     */
    private static boolean isListedField(IonValue field, String[] fields)
    {
<span class="fc" id="L772">        String fieldName = field.getFieldName();</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">        for (String key : fields)</span>
        {
<span class="fc bfc" id="L775" title="All 2 branches covered.">            if (key.equals(fieldName)) return true;</span>
        }
<span class="fc" id="L777">        return false;</span>
    }


    /**
     * Ensures that a given field name is valid. Used as a helper for
     * methods that have that precondition.
     *
     * @throws NullPointerException if the &lt;code&gt;fieldName&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     */
    private static void validateFieldName(String fieldName)
    {
<span class="fc bfc" id="L790" title="All 2 branches covered.">        if (fieldName == null)</span>
        {
<span class="fc" id="L792">            throw new NullPointerException(&quot;fieldName is null&quot;);</span>
        }
<span class="fc" id="L794">    }</span>

    @Override
    final void writeBodyTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
        throws IOException
    {
<span class="fc bfc" id="L800" title="All 2 branches covered.">        if (isNullValue())</span>
        {
<span class="fc" id="L802">            writer.writeNull(IonType.STRUCT);</span>
        }
        else
        {
<span class="fc" id="L806">            writer.stepIn(IonType.STRUCT);</span>
<span class="fc" id="L807">            writeChildren(writer, this, symbolTableProvider);</span>
<span class="fc" id="L808">            writer.stepOut();</span>
        }
<span class="fc" id="L810">    }</span>

    @Override
    public void accept(ValueVisitor visitor) throws Exception
    {
<span class="nc" id="L815">        visitor.visit(this);</span>
<span class="nc" id="L816">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>