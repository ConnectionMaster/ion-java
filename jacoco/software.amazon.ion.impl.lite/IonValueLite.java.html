<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonValueLite.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl.lite</a> &gt; <span class="el_source">IonValueLite.java</span></div><h1>IonValueLite.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2010-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl.lite;

import static software.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static software.amazon.ion.impl.PrivateUtils.EMPTY_STRING_ARRAY;
import static software.amazon.ion.impl.PrivateUtils.newSymbolToken;
import static software.amazon.ion.util.Equivalence.ionEquals;

import java.io.IOException;
import java.io.PrintWriter;
import software.amazon.ion.IonDatagram;
import software.amazon.ion.IonException;
import software.amazon.ion.IonType;
import software.amazon.ion.IonValue;
import software.amazon.ion.IonWriter;
import software.amazon.ion.NullValueException;
import software.amazon.ion.ReadOnlyValueException;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.UnknownSymbolException;
import software.amazon.ion.ValueVisitor;
import software.amazon.ion.impl.PrivateIonValue;
import software.amazon.ion.impl.PrivateIonWriter;
import software.amazon.ion.impl.PrivateUtils;
import software.amazon.ion.system.IonTextWriterBuilder;

/**
 *  Base class of the light weight implementation of
 *  Ion values.
 *
 *  This implementation is not backed by a buffer
 *  and is therefore fully materialized.  If you need
 *  only a few values from a large datagram this
 *  implementation may be more expensive than the
 *  original implementation.
 */
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">abstract class IonValueLite</span>
    implements PrivateIonValue
{
<span class="fc" id="L53">    private static final int TYPE_ANNOTATION_HASH_SIGNATURE =</span>
<span class="fc" id="L54">        &quot;TYPE ANNOTATION&quot;.hashCode();</span>

<span class="fc" id="L56">    private static final IonTextWriterBuilder TO_STRING_TEXT_WRITER_BUILDER =</span>
<span class="fc" id="L57">        IonTextWriterBuilder.standard().withCharsetAscii().immutable();</span>

    /**
     * this hold all the various boolean flags we have
     * in a single int.  Use set_flag(), clear_flag(), is_true()
     * and the associated int flag to check the various flags.
     * This is to avoid the overhead java seems to impose
     * for a boolean value - it should be a bit, but it seems
     * to be an int (4 bytes for 1 bit seems excessive).
     */
    protected static final int IS_LOCKED          = 0x01;
    protected static final int IS_SYSTEM_VALUE    = 0x02;
    protected static final int IS_NULL_VALUE      = 0x04;
    protected static final int IS_BOOL_TRUE       = 0x08;
    protected static final int IS_IVM             = 0x10;
    protected static final int IS_AUTO_CREATED    = 0x20;
    protected static final int IS_SYMBOL_PRESENT  = 0x40;
    private   static final int ELEMENT_MASK       = 0xff;
    protected static final int ELEMENT_SHIFT      = 8; // low 8 bits is flag, upper 24 (or 48 is element id)

    /**
     * Used by subclasses to retrieve metadata set by
     * {@link #_setMetadata(int, int, int)}.
     * @param mask the location of the metadata to retrieve.
     * @param shift the number of bits to right-shift the metadata so that
     *              it starts at bit index 0.
     * @return the metadata from _flags at the given mask.
     */
    protected final int _getMetadata(int mask, int shift) {
<span class="fc" id="L86">        return (_flags &amp; mask) &gt;&gt;&gt; shift;</span>
    }

    /**
     * May be used by subclasses to reuse _flag bits for purposes specific
     * to that subclass. It is important that only flag bits not currently
     * used by that subclass are chosen; otherwise important data may be
     * overwritten. NOTE: only the lower 8 bits may be used, because the
     * upper 24 are reserved for the element ID.
     * @param metadata the metadata to set.
     * @param mask the location at which to set the metadata. Must be within
     *             the lower 8 bits.
     * @param shift the number of bits to left-shift the metadata so that
     *              it starts at the index of the mask's LSB.
     */
    protected final void _setMetadata(int metadata, int mask, int shift) {
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">        assert(mask &lt;= ELEMENT_MASK); // don't overwrite the element ID</span>
<span class="fc" id="L103">        _flags &amp;= ~mask;</span>
<span class="fc" id="L104">        _flags |= ((metadata &lt;&lt; shift) &amp; mask);</span>
<span class="fc" id="L105">    }</span>

    protected final void _elementid(int elementid) {
<span class="fc" id="L108">        _flags &amp;= ELEMENT_MASK;</span>
<span class="fc" id="L109">        _flags |= (elementid &lt;&lt; ELEMENT_SHIFT);</span>
<span class="pc bpc" id="L110" title="2 of 4 branches missed.">        assert(_elementid() == elementid);</span>
<span class="fc" id="L111">    }</span>
    protected final int _elementid() {
<span class="fc" id="L113">        int elementid =  _flags  &gt;&gt;&gt; ELEMENT_SHIFT;</span>
<span class="fc" id="L114">        return elementid;</span>
    }

    private final boolean is_true(int flag_bit) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        return ((_flags &amp; flag_bit) != 0);</span>
    }
    private final void set_flag(int flag_bit) {
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">        assert(flag_bit != 0);</span>
<span class="fc" id="L122">        _flags |= flag_bit;</span>
<span class="fc" id="L123">    }</span>
    private final void clear_flag(int flag_bit) {
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">        assert(flag_bit != 0);</span>
<span class="fc" id="L126">        _flags &amp;= ~flag_bit;</span>
<span class="fc" id="L127">    }</span>

<span class="fc" id="L129">    protected final boolean _isLocked() { return is_true(IS_LOCKED); }</span>
    protected final boolean _isLocked(boolean flag) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (flag) {</span>
<span class="fc" id="L132">            set_flag(IS_LOCKED);</span>
        }
        else {
<span class="nc" id="L135">            clear_flag(IS_LOCKED);</span>
        }
<span class="fc" id="L137">        return flag;</span>
    }
<span class="nc" id="L139">    protected final boolean _isSystemValue() { return is_true(IS_SYSTEM_VALUE); }</span>
    protected final boolean _isSystemValue(boolean flag) {
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (flag) {</span>
<span class="nc" id="L142">            set_flag(IS_SYSTEM_VALUE);</span>
        }
        else {
<span class="nc" id="L145">            clear_flag(IS_SYSTEM_VALUE);</span>
        }
<span class="nc" id="L147">        return flag;</span>
    }
<span class="fc" id="L149">    protected final boolean _isNullValue() { return is_true(IS_NULL_VALUE); }</span>
    protected final boolean _isNullValue(boolean flag) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (flag) {</span>
<span class="fc" id="L152">            set_flag(IS_NULL_VALUE);</span>
        }
        else {
<span class="fc" id="L155">            clear_flag(IS_NULL_VALUE);</span>
        }
<span class="fc" id="L157">        return flag;</span>
    }
<span class="fc" id="L159">    protected final boolean _isBoolTrue() { return is_true(IS_BOOL_TRUE); }</span>
    protected final boolean _isBoolTrue(boolean flag) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (flag) {</span>
<span class="fc" id="L162">            set_flag(IS_BOOL_TRUE);</span>
        }
        else {
<span class="fc" id="L165">            clear_flag(IS_BOOL_TRUE);</span>
        }
<span class="fc" id="L167">        return flag;</span>
    }

<span class="nc" id="L170">    protected final boolean _isIVM() { return is_true(IS_IVM); }</span>
    protected final boolean _isIVM(boolean flag) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (flag) {</span>
<span class="nc" id="L173">            set_flag(IS_IVM);</span>
        }
        else {
<span class="nc" id="L176">            clear_flag(IS_IVM);</span>
        }
<span class="nc" id="L178">        return flag;</span>
    }

<span class="fc" id="L181">    protected final boolean _isAutoCreated() { return is_true(IS_AUTO_CREATED); }</span>
    protected final boolean _isAutoCreated(boolean flag) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (flag) {</span>
<span class="nc" id="L184">            set_flag(IS_AUTO_CREATED);</span>
        }
        else {
<span class="nc" id="L187">            clear_flag(IS_AUTO_CREATED);</span>
        }
<span class="nc" id="L189">        return flag;</span>
    }

<span class="fc" id="L192">    protected final boolean _isSymbolPresent() { return is_true(IS_SYMBOL_PRESENT); }</span>
    protected final boolean _isSymbolPresent(boolean flag) {
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (flag) {</span>
<span class="fc" id="L195">            set_flag(IS_SYMBOL_PRESENT);</span>
        }
        else {
<span class="nc" id="L198">            clear_flag(IS_SYMBOL_PRESENT);</span>
        }
<span class="fc" id="L200">        return flag;</span>
    }

    /**
     * Lazy memoized symtab provider. Should be used when a call path
     * conditionally needs access to a value's symbol table. This provider
     * can be &quot;passed down&quot; through the path, cutting down on
     * potentially expensive IonValue#getSymbolTable calls.
     */
    static class LazySymbolTableProvider
        implements SymbolTableProvider
    {
<span class="fc" id="L212">        SymbolTable symtab = null;</span>
        final IonValueLite value;

        LazySymbolTableProvider(IonValueLite value)
<span class="fc" id="L216">        {</span>
<span class="fc" id="L217">            this.value = value;</span>
<span class="fc" id="L218">        }</span>

        public SymbolTable getSymbolTable()
        {
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (symtab == null)</span>
            {
<span class="fc" id="L224">                symtab = value.getSymbolTable();</span>
            }
<span class="fc" id="L226">            return symtab;</span>
        }

    }

    /*
     * KEEP ALL MEMBER FIELDS HERE!
     *
     * This impl is intended to have a very light memory footprint. So tracking
     * member fields is especially important.
     *
     * SO PLEASE KEEP THE MEMBER DECLARATIONS HERE AND TOGETHER!
     *
     * Thank you.
     *
     * If this instance is not a struct field, then
     *   _fieldId = UNKNOWN_SYMBOL_ID  and  _fieldName = null
     * Otherwise, at least one must be defined.
     */
    private   int              _flags;
<span class="fc" id="L246">    private   int              _fieldId = UNKNOWN_SYMBOL_ID;</span>

    /** Not null. */
    protected IonContext       _context;
    private   String           _fieldName;

    /**
     * The annotation sequence. This array is overallocated and may have
     * nulls at the end denoting unused slots.
     */
    private   SymbolToken[] _annotations;

    // current size 32 bit: 3*4 + 4 +  8 = 24 (32 bytes allocated)
    //              64 bit: 3*8 + 4 + 16 = 52 (56 bytes allocated)

    /**
     * The constructor, which is called from the concrete subclasses'
     * constructors.
     *
     * @param context the context that this value is associated with
     * @param isNull if true, sets the null bit in the flags member field
     */
    IonValueLite(ContainerlessContext context, boolean isNull)
<span class="fc" id="L269">    {</span>
<span class="pc bpc" id="L270" title="2 of 4 branches missed.">        assert context != null;</span>
<span class="fc" id="L271">        _context = context;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (isNull) {</span>
<span class="fc" id="L273">            set_flag(IS_NULL_VALUE);</span>
        }
<span class="fc" id="L275">    }</span>

    /**
     * Copy Constructor *purely* for cloning - NOTE; this means that the clone is not &lt;i&gt;perfect&lt;/i&gt;
     * as if the original entity was &lt;b&gt;read-only&lt;/b&gt; the cloned value will now be &lt;b&gt;mutable&lt;/b&gt;.
     *
     * @param existing the non-null existing IonValueLite entity to clone
     * @param context the non-null parent context to use for the cloned entity.
     */
<span class="fc" id="L284">    IonValueLite(IonValueLite existing, IonContext context) {</span>
        // Symbols are *immutable* therefore a shallow copy is sufficient
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (null == existing._annotations) {</span>
<span class="fc" id="L287">            this._annotations = null;</span>
        } else {
<span class="fc" id="L289">            int size = existing._annotations.length;</span>
<span class="fc" id="L290">            this._annotations = new SymbolToken[size];</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L292">                SymbolToken existingToken = existing._annotations[i];</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                if (existingToken != null) {</span>
<span class="fc" id="L294">                    String text = existingToken.getText();</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                    if (text != null) {</span>
<span class="fc" id="L296">                        this._annotations[i] =</span>
<span class="fc" id="L297">                            PrivateUtils.newSymbolToken(text, UNKNOWN_SYMBOL_ID);</span>
                    } else {
                        // TODO - this is clearly wrong; however was the existing behavior as
                        // existing under #getAnnotationTypeSymbols();
<span class="fc" id="L301">                        this._annotations[i] = existing._annotations[i];</span>
                    }
                }
            }
        }
        // We don't copy the field name, that happens in IonStruct's clone
<span class="fc" id="L307">        this._flags       = existing._flags;</span>
<span class="fc" id="L308">        this._context     = context;</span>

        // as IonValue.clone() mandates that the returned value is mutable, regardless of the
        // existing 'read only' flag - we force the deep-copy back to being mutable
<span class="fc" id="L312">        clear_flag(IS_LOCKED);</span>
<span class="fc" id="L313">    }</span>

    public abstract void accept(ValueVisitor visitor) throws Exception;

    public /* synchronized */ void addTypeAnnotation(String annotation)
    {
<span class="fc" id="L319">        checkForLock();</span>

<span class="pc bpc" id="L321" title="2 of 4 branches missed.">        if (annotation == null || annotation.length() &lt; 1) {</span>
<span class="nc" id="L322">            throw new IllegalArgumentException(&quot;a user type annotation must be a non-empty string&quot;);</span>
        }

        // we don't add duplicate annotations
<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (hasTypeAnnotation(annotation)) return;</span>

<span class="fc" id="L328">        SymbolToken sym = newSymbolToken(annotation, UNKNOWN_SYMBOL_ID);</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">        int old_len = (_annotations == null) ? 0 : _annotations.length;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (old_len &gt; 0) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            for (int ii=0; ii&lt;old_len; ii++) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (_annotations[ii] == null) {</span>
<span class="fc" id="L334">                    _annotations[ii] = sym;</span>
<span class="fc" id="L335">                    return;</span>
                }
            }
        }

<span class="fc bfc" id="L340" title="All 2 branches covered.">        int new_len = (old_len == 0) ? 1 : old_len * 2;</span>
<span class="fc" id="L341">        SymbolToken temp[] = new SymbolToken[new_len];</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (old_len &gt; 0) {</span>
<span class="fc" id="L343">            System.arraycopy(_annotations, 0, temp, 0, old_len);</span>
        }
<span class="fc" id="L345">        _annotations = temp;</span>
<span class="fc" id="L346">        _annotations[old_len] = sym;</span>
<span class="fc" id="L347">    }</span>

    public final /* synchronized */ void clearTypeAnnotations()
    {
<span class="fc" id="L351">        checkForLock();</span>

<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        int old_len = (_annotations == null) ? 0 : _annotations.length;</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (old_len &gt; 0) {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            for (int ii=0; ii&lt;old_len; ii++) {</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                if (_annotations[ii] == null) {</span>
<span class="nc" id="L357">                    break;</span>
                }
<span class="nc" id="L359">                _annotations[ii] = null;</span>
            }
        }
<span class="fc" id="L362">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The user can only call this method on the concrete (not abstract)
     * subclasses of IonValueLite (e.g. IonIntLite). The explicit clone logic
     * is contained in {@link #clone(IonContext)} which should in turn be implemented by
     * using a copy-constructor.
     */
    @Override
    public abstract IonValue clone();

    abstract IonValueLite clone(IonContext parentContext);


    /**
     * Since {@link #equals(Object)} is overridden, each concrete class must provide
     * an implementation of {@link Object#hashCode()}.
     * @return hash code for instance consistent with equals().
     */
    /*
     * internally ALL implementations will be delegated too with the SymbolTable
     * which is to prevent the SymbolTable being continually re-located in complex structures.
     *
     * This is near universally true - however does not apply for IonDatagramLite - hence it
     * explicitly overrides hashCode()
     */
    @Override
    public int hashCode() {
        // Supply a lazy symbol table provider, which will call getSymbolTable()
        // only once it's actually necessary.
        // This works for all child types with the exception of
        // IonDatagramLite which has a different, explicit behavior for hashCode()
        // (hence this method cannot be final).
<span class="fc" id="L397">        return hashCode(new LazySymbolTableProvider(this));</span>
    }

    /*
     * Internal HashCode implementation which utilizes a SymbolTableProvider
     * to resolve the SymbolTable to use in encoding the sub-graph.
     */
    abstract int hashCode(SymbolTableProvider symbolTableProvider);

    public IonContainerLite getContainer()
    {
<span class="fc" id="L408">        return _context.getContextContainer();</span>
    }

    public IonValueLite topLevelValue()
    {
<span class="pc bpc" id="L413" title="2 of 4 branches missed.">        assert ! (this instanceof IonDatagram);</span>

<span class="fc" id="L415">        IonValueLite value = this;</span>
        for (;;) {
<span class="fc" id="L417">            IonContainerLite c = value._context.getContextContainer();</span>
<span class="fc bfc" id="L418" title="All 4 branches covered.">            if (c == null || c instanceof IonDatagram) {</span>
<span class="fc" id="L419">                break;</span>
            }
<span class="fc" id="L421">            value = c;</span>
<span class="fc" id="L422">        }</span>
<span class="fc" id="L423">        return value;</span>
    }


    public final int getElementId()
    {
<span class="fc" id="L429">        return this._elementid();</span>
    }

    public SymbolToken getFieldNameSymbol()
    {
        // TODO amzn/ion-java#27 We should memoize the results of symtab lookups.
        // BUT: that could cause thread-safety problems for read-only values.
        // I think makeReadOnly should populate the tokens fully
        // so that we only need to lookup from mutable instances.
        // However, the current invariants on these fields are nonexistant so
        // I do not trust that its safe to alter them here.

<span class="fc" id="L441">        return getFieldNameSymbol(new LazySymbolTableProvider(this));</span>
    }

    public final SymbolToken getFieldNameSymbol(SymbolTableProvider symbolTableProvider)
    {
<span class="fc" id="L446">        int sid = _fieldId;</span>
<span class="fc" id="L447">        String text = _fieldName;</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (text != null)</span>
        {
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            if (sid == UNKNOWN_SYMBOL_ID)</span>
            {
<span class="fc" id="L452">                SymbolToken tok = symbolTableProvider.getSymbolTable().find(text);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                if (tok != null)</span>
                {
<span class="fc" id="L455">                    return tok;</span>
                }
<span class="fc" id="L457">            }</span>
        }
<span class="fc bfc" id="L459" title="All 2 branches covered.">        else if (sid &gt; 0) {</span>
<span class="fc" id="L460">            text = symbolTableProvider.getSymbolTable().findKnownSymbol(sid);</span>
        }
<span class="fc bfc" id="L462" title="All 2 branches covered.">        else if(sid != 0){</span>
            // not a struct field
<span class="fc" id="L464">            return null;</span>
        }
<span class="fc" id="L466">        return PrivateUtils.newSymbolToken(text, sid);</span>
    }

    public final SymbolToken getKnownFieldNameSymbol()
    {
<span class="fc" id="L471">        SymbolToken token = this.getFieldNameSymbol();</span>
<span class="pc bpc" id="L472" title="2 of 4 branches missed.">        if (token.getText() == null &amp;&amp; token.getSid() != 0) {</span>
<span class="nc" id="L473">            throw new UnknownSymbolException(_fieldId);</span>
        }
<span class="fc" id="L475">        return token;</span>
    }

    /**
     * Sets this value's symbol table to null, and erases any SIDs here and
     * recursively.
     */
    void clearSymbolIDValues()
    {
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if (_fieldName != null)</span>
        {
<span class="fc" id="L486">            _fieldId = UNKNOWN_SYMBOL_ID;</span>
        }

<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (_annotations != null)</span>
        {
<span class="fc bfc" id="L491" title="All 2 branches covered.">            for (int i = 0; i &lt; _annotations.length; i++)</span>
            {
<span class="fc" id="L493">                SymbolToken annotation = _annotations[i];</span>

                // _annotations may have nulls at the end.
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">                if (annotation == null) break;</span>

<span class="fc" id="L498">                String text = annotation.getText();</span>
<span class="fc bfc" id="L499" title="All 4 branches covered.">                if (text != null &amp;&amp; annotation.getSid() != UNKNOWN_SYMBOL_ID)</span>
                {
<span class="fc" id="L501">                    _annotations[i] =</span>
<span class="fc" id="L502">                        newSymbolToken(text, UNKNOWN_SYMBOL_ID);</span>
                }
            }
        }
<span class="fc" id="L506">    }</span>


    final void setFieldName(String name)
    {
<span class="pc bpc" id="L511" title="2 of 4 branches missed.">        assert getContainer() instanceof IonStructLite;</span>
        // We can never change a field name once it's set.
<span class="pc bpc" id="L513" title="3 of 6 branches missed.">        assert _fieldId == UNKNOWN_SYMBOL_ID &amp;&amp; _fieldName == null;</span>
<span class="fc" id="L514">        _fieldName = name;</span>
<span class="fc" id="L515">    }</span>

    /**
     * Sets the field name and ID based on a SymbolToken.
     * Both parts of the SymbolToken are trusted!
     *
     * @param name is not retained by this value, but both fields are copied.
     */
    final void setFieldNameSymbol(SymbolToken name)
    {
<span class="pc bpc" id="L525" title="3 of 6 branches missed.">        assert _fieldId == UNKNOWN_SYMBOL_ID &amp;&amp; _fieldName == null;</span>
<span class="fc" id="L526">        _fieldName = name.getText();</span>
<span class="fc" id="L527">        _fieldId   = name.getSid();</span>
<span class="fc" id="L528">    }</span>

    public final String getFieldName()
    {
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (_fieldName != null) return _fieldName;</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if (_fieldId &lt;= 0) return null;</span>

        // TODO amzn/ion-java#27 why no symtab lookup, like getFieldNameSymbol()?
<span class="fc" id="L536">        throw new UnknownSymbolException(_fieldId);</span>
    }

    /**
     * @return not null, &lt;b&gt;in conflict with the public documentation&lt;/b&gt;.
     */
    public SymbolTable getSymbolTable()
    {
<span class="pc bpc" id="L544" title="2 of 4 branches missed.">        assert ! (this instanceof IonDatagram);</span>

<span class="fc" id="L546">        SymbolTable symbols = topLevelValue()._context.getContextSymbolTable();</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (symbols != null) {</span>
<span class="fc" id="L548">            return symbols;</span>
        }
<span class="fc" id="L550">        return _context.getSystem().getSystemSymbolTable();</span>
    }

    public SymbolTable getAssignedSymbolTable()
    {
<span class="pc bpc" id="L555" title="2 of 4 branches missed.">        assert ! (this instanceof IonDatagram);</span>

<span class="fc" id="L557">        SymbolTable symbols = _context.getContextSymbolTable();</span>
<span class="fc" id="L558">        return symbols;</span>
    }

    public IonSystemLite getSystem()
    {
<span class="fc" id="L563">        return _context.getSystem();</span>
    }

    public IonType getType()
    {
<span class="nc" id="L568">        throw new UnsupportedOperationException(&quot;this type &quot;+this.getClass().getSimpleName()+&quot; should not be instanciated, there is not IonType associated with it&quot;);</span>
    }

    public SymbolToken[] getTypeAnnotationSymbols()
    {
<span class="fc" id="L573">        return getTypeAnnotationSymbols(new LazySymbolTableProvider(this));</span>
    }

    public final SymbolToken[] getTypeAnnotationSymbols(SymbolTableProvider symbolTableProvider)
    {
        // first we have to count the number of non-null
        // elements there are in the annotations array
<span class="fc" id="L580">        int count = 0;</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (_annotations != null) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">            for (int i = 0; i &lt; _annotations.length; i++) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                if (_annotations[i] != null) {</span>
<span class="fc" id="L584">                    count++;</span>
                }
            }
        }
        // if there aren't any, we're done
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L590">            return SymbolToken.EMPTY_ARRAY;</span>
        }

<span class="fc" id="L593">        SymbolToken[] users_copy = new SymbolToken[count];</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc" id="L596">            SymbolToken token = _annotations[i];</span>
<span class="fc" id="L597">            String text = token.getText();</span>
<span class="pc bpc" id="L598" title="1 of 4 branches missed.">            if (text != null &amp;&amp; token.getSid() == UNKNOWN_SYMBOL_ID)</span>
            {
                // TODO amzn/ion-java#27 We should memoize the result of symtab lookups
                // into _annotations.
                // See getFieldNameSymbol() for challenges doing so.

<span class="fc" id="L604">                SymbolToken interned = symbolTableProvider.getSymbolTable().find(text);</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                if (interned != null)</span>
                {
<span class="fc" id="L607">                    token = interned;</span>
                }
            }

<span class="fc" id="L611">            users_copy[i] = token;</span>
        }
<span class="fc" id="L613">        return users_copy;</span>
    }

    public void setTypeAnnotationSymbols(SymbolToken... annotations)
    {
<span class="fc" id="L618">        checkForLock();</span>

<span class="pc bpc" id="L620" title="1 of 4 branches missed.">        if (annotations == null || annotations.length == 0)</span>
        {
            // Normalize all empty lists to the same instance.
<span class="fc" id="L623">            _annotations = SymbolToken.EMPTY_ARRAY;</span>
        }
        else
        {
<span class="fc" id="L627">            _annotations = annotations.clone();</span>
        }
<span class="fc" id="L629">    }</span>

    public final String[] getTypeAnnotations()
    {
        // first we have to count the number of non-null
        // elements there are in the annotations array
<span class="fc" id="L635">        int count = 0;</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (_annotations != null) {</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            for (int ii=0; ii&lt;_annotations.length; ) {</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">                if (_annotations[ii] == null) {</span>
<span class="fc" id="L639">                    break;</span>
                }
<span class="fc" id="L641">                ii++;</span>
<span class="fc" id="L642">                count = ii;</span>
            }
        }
        // if there aren't any, we're done
<span class="fc bfc" id="L646" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L647">            return EMPTY_STRING_ARRAY;</span>
        }

<span class="fc" id="L650">        return PrivateUtils.toStrings(_annotations, count);</span>
    }

    public void setTypeAnnotations(String... annotations)
    {
<span class="fc" id="L655">        checkForLock();</span>

<span class="fc" id="L657">        _annotations = PrivateUtils.newSymbolTokens(getSymbolTable(),</span>
                                                       annotations);
<span class="fc" id="L659">    }</span>

    public final boolean hasTypeAnnotation(String annotation)
    {
<span class="fc bfc" id="L663" title="All 4 branches covered.">        if (annotation != null &amp;&amp; annotation.length() &gt; 0) {</span>
<span class="fc" id="L664">            int pos = findTypeAnnotation(annotation);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">            if (pos &gt;= 0) {</span>
<span class="fc" id="L666">                return true;</span>
            }
        }
<span class="fc" id="L669">        return false;</span>
    }

    @Override
    public final int findTypeAnnotation(String annotation)
    {
<span class="pc bpc" id="L675" title="3 of 6 branches missed.">        assert(annotation != null &amp;&amp; annotation.length() &gt; 0);</span>

<span class="fc bfc" id="L677" title="All 2 branches covered.">        if (_annotations != null) {</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">            for (int ii=0; ii&lt;_annotations.length; ii++) {</span>
<span class="fc" id="L679">                SymbolToken a = _annotations[ii];</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">                if (a == null) {</span>
<span class="fc" id="L681">                    break;</span>
                }
<span class="fc bfc" id="L683" title="All 2 branches covered.">                if (annotation.equals(a.getText())) {</span>
<span class="fc" id="L684">                    return ii;</span>
                }
            }
        }
<span class="fc" id="L688">        return -1;</span>
    }

    protected int hashTypeAnnotations(final int original, SymbolTableProvider symbolTableProvider)
    {
<span class="fc" id="L693">        final SymbolToken[] tokens = getTypeAnnotationSymbols(symbolTableProvider);</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">        if (tokens.length == 0)</span>
        {
<span class="fc" id="L696">            return original;</span>
        }

<span class="fc" id="L699">        final int sidHashSalt   = 127;      // prime to salt sid of annotation</span>
<span class="fc" id="L700">        final int textHashSalt  = 31;       // prime to salt text of annotation</span>
<span class="fc" id="L701">        final int prime = 8191;</span>
<span class="fc" id="L702">        int result = original ^ TYPE_ANNOTATION_HASH_SIGNATURE;</span>

<span class="fc" id="L704">        result = prime * original + tokens.length;</span>

<span class="fc bfc" id="L706" title="All 2 branches covered.">        for (final SymbolToken token : tokens)</span>
        {
<span class="fc" id="L708">            String text = token.getText();</span>

<span class="fc bfc" id="L710" title="All 2 branches covered.">            int tokenHashCode = text == null</span>
<span class="fc" id="L711">                ? token.getSid()  * sidHashSalt</span>
<span class="fc" id="L712">                : text.hashCode() * textHashSalt;</span>

            // mixing to account for small text and sid deltas
<span class="fc" id="L715">            tokenHashCode ^= (tokenHashCode &lt;&lt; 19) ^ (tokenHashCode &gt;&gt; 13);</span>

<span class="fc" id="L717">            result = prime * result + tokenHashCode;</span>

            // mixing at each step to make the hash code order-dependent
<span class="fc" id="L720">            result ^= (result &lt;&lt; 25) ^ (result &gt;&gt; 7);</span>
        }

<span class="fc" id="L723">        return result;</span>
    }

    /**
     * Implements equality over values.
     * This is currently defined using the Equivalence class.
     *
     * @see software.amazon.ion.util.Equivalence
     *
     * @param   other   The value to compare with.
     *
     * @return  A boolean, true if the other value is an Ion Value that is the same
     *          content and annotations.
     */
    @Override
    public final boolean equals(final Object other)
    {
<span class="fc bfc" id="L740" title="All 2 branches covered.">        if (other == this) {</span>
            // we shouldn't make 3 deep method calls for this common case
<span class="fc" id="L742">            return true;</span>
        }
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">        if (other instanceof IonValue)</span>
        {
<span class="fc" id="L746">            return ionEquals(this, (IonValue) other);</span>
        }
<span class="nc" id="L748">        return false;</span>
    }


    public final boolean isNullValue()
    {
<span class="fc" id="L754">        return _isNullValue();</span>
    }

    public final boolean isReadOnly()
    {
<span class="fc" id="L759">        return _isLocked();</span>
    }

    public void makeReadOnly()
    {
<span class="fc bfc" id="L764" title="All 2 branches covered.">        if (!_isLocked()) {</span>
<span class="fc" id="L765">            makeReadOnlyInternal();</span>
        }
<span class="fc" id="L767">    }</span>

    void makeReadOnlyInternal()
    {
<span class="fc" id="L771">        clearSymbolIDValues();</span>
<span class="fc" id="L772">        _isLocked(true);</span>
<span class="fc" id="L773">    }</span>

    /**
     * Verifies that this value is not read-only.
     *
     * @throws ReadOnlyValueException
     *   if this value {@link #isReadOnly()}.
     */
    final void checkForLock()
        throws ReadOnlyValueException
    {
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (_isLocked()) {</span>
<span class="fc" id="L785">            throw new ReadOnlyValueException();</span>
        }
<span class="fc" id="L787">    }</span>


    public boolean removeFromContainer()
    {
<span class="fc" id="L792">        checkForLock();</span>

<span class="fc" id="L794">        boolean removed = false;</span>
<span class="fc" id="L795">        IonContainerLite parent = _context.getContextContainer();</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L797">            removed = parent.remove(this);</span>
        }
<span class="fc" id="L799">        return removed;</span>
    }

    public void removeTypeAnnotation(String annotation)
    {
<span class="fc" id="L804">        checkForLock();</span>

<span class="fc bfc" id="L806" title="All 4 branches covered.">        if (annotation != null &amp;&amp; annotation.length() &gt; 0) {</span>
<span class="fc" id="L807">            int pos = findTypeAnnotation(annotation);</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">            if (pos &lt; 0) {</span>
<span class="fc" id="L809">                return;</span>
            }
            int ii;
<span class="fc bfc" id="L812" title="All 2 branches covered.">            for (ii=pos; ii&lt;_annotations.length - 1; ii++) {</span>
<span class="fc" id="L813">                SymbolToken a = _annotations[ii+1];</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">                if (a == null) {</span>
<span class="fc" id="L815">                    break;</span>
                }
<span class="fc" id="L817">                _annotations[ii] = a;</span>
            }
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">            if (ii&lt;_annotations.length) {</span>
<span class="fc" id="L820">                _annotations[ii] = null;</span>
            }
        }
<span class="fc" id="L823">    }</span>

    @Override
    public String toString()
    {
<span class="fc" id="L828">        return toString(TO_STRING_TEXT_WRITER_BUILDER);</span>
    }

    public String toString(IonTextWriterBuilder writerBuilder)
    {
<span class="fc" id="L833">        StringBuilder buf = new StringBuilder(1024);</span>
        try
        {
<span class="fc" id="L836">            IonWriter writer = writerBuilder.build(buf);</span>
<span class="fc" id="L837">            writeTo(writer);</span>
<span class="fc" id="L838">            writer.finish();</span>
        }
<span class="nc" id="L840">        catch (IOException e)</span>
        {
<span class="nc" id="L842">            throw new IonException(e);</span>
<span class="fc" id="L843">        }</span>
<span class="fc" id="L844">        return buf.toString();</span>
    }

    public String toPrettyString()
    {
<span class="fc" id="L849">        return toString(IonTextWriterBuilder.pretty());</span>
    }

    public void writeTo(IonWriter writer)
    {
        // we use a Lazy 1-time resolution of the SymbolTable in case there is no need to
        // pull the symbol table, including situations where no symbol table would logically
        // be attached
<span class="fc" id="L857">        writeTo(writer, new LazySymbolTableProvider(this));</span>
<span class="fc" id="L858">    }</span>

    final void writeChildren(IonWriter writer, Iterable&lt;IonValue&gt; container,
                             SymbolTableProvider symbolTableProvider)
    {
<span class="fc" id="L863">        boolean isDatagram = this instanceof IonDatagram;</span>
        // unfortunately JDK5 does not allow for generic co-variant returns; i.e. specifying
        // IonContainerLite#iterator() return type as Iterator&lt;IonValueLite&gt; causes a compile-time
        // error under JDK5 as it doesn't understand this is an acceptable co-variant for
        // Iterator&lt;IonValue&gt; IonContainer#iterator(). This said we know the underlying data
        // structure is IonValueLite[] - so we can conduct the cast within the loop. When ion-java is
        // moved to allow JDK6+ compile time dependency we can remove these crufty casts.
<span class="fc bfc" id="L870" title="All 2 branches covered.">        for (IonValue iv : container) {</span>
<span class="fc" id="L871">            IonValueLite vlite = (IonValueLite) iv;</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">            if(isDatagram)</span>
            {
<span class="nc" id="L874">                vlite.writeTo(writer);</span>
            }
            else
            {
<span class="fc" id="L878">                vlite.writeTo(writer, symbolTableProvider);</span>
            }
<span class="fc" id="L880">        }</span>
<span class="fc" id="L881">    }</span>

    final void writeTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
    {
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if (writer.isInStruct()</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">            &amp;&amp; ! ((PrivateIonWriter) writer).isFieldNameSet())</span>
        {
<span class="fc" id="L888">            SymbolToken tok = getFieldNameSymbol(symbolTableProvider);</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">            if (tok == null)</span>
            {
<span class="nc" id="L891">                throw new IllegalStateException(&quot;Field name not set&quot;);</span>
            }

<span class="fc" id="L894">            writer.setFieldNameSymbol(tok);</span>
        }

<span class="fc" id="L897">        SymbolToken[] annotations = getTypeAnnotationSymbols(symbolTableProvider);</span>
<span class="fc" id="L898">        writer.setTypeAnnotationSymbols(annotations);</span>

        try
        {
<span class="fc" id="L902">            writeBodyTo(writer, symbolTableProvider);</span>
        }
<span class="nc" id="L904">        catch (IOException e)</span>
        {
<span class="nc" id="L906">            throw new IonException(e);</span>
<span class="fc" id="L907">        }</span>
<span class="fc" id="L908">    }</span>

    abstract void writeBodyTo(IonWriter writer, SymbolTableProvider symbolTableProvider)
        throws IOException;


    public void setSymbolTable(SymbolTable symbols)
    {
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">        if (getContext() instanceof TopLevelContext){</span>
<span class="nc" id="L917">            IonDatagramLite datagram = (IonDatagramLite) getContainer();</span>
<span class="nc" id="L918">            datagram.setSymbolTableAtIndex(_elementid(), symbols);</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">        } else if (this.topLevelValue() == this) {</span>
<span class="fc" id="L920">            setContext(ContainerlessContext.wrap(getContext().getSystem(), symbols));</span>
        } else {
<span class="nc" id="L922">            throw new UnsupportedOperationException(&quot;can't set the symboltable of a child value&quot;);</span>
        }
<span class="fc" id="L924">    }</span>

    /**
     * This method is used to re-set the context of an
     * IonValue.  This may occur when the value is added into
     * or removed from a container.  It may occur when the
     * symbol table state of a container changes.
     *
     * @param context must not be null.
     */
    final void setContext(IonContext context)
    {
<span class="pc bpc" id="L936" title="2 of 4 branches missed.">        assert context != null;</span>
<span class="fc" id="L937">        checkForLock();</span>

        //Clear all known sIDs.
<span class="fc" id="L940">        this.clearSymbolIDValues();</span>
<span class="fc" id="L941">        _context = context;</span>
<span class="fc" id="L942">    }</span>

    /**
     * used to query the current context.
     *
     * @return this value's context. Not null.
     */
    IonContext getContext()
    {
<span class="fc" id="L951">        return _context;</span>
    }

    /**
     * Ensures that this value is not an Ion null.  Used as a helper for
     * methods that have that precondition.
     * @throws NullValueException if &lt;code&gt;this.isNullValue()&lt;/code&gt;
     */
    final void validateThisNotNull()
        throws NullValueException
    {
<span class="fc bfc" id="L962" title="All 2 branches covered.">        if (_isNullValue())</span>
        {
<span class="fc" id="L964">            throw new NullValueException();</span>
        }
<span class="fc" id="L966">    }</span>

    /**
     * Removes this value from its container, ensuring that all data stays
     * available.  Dirties this value and it's original container.
     */
    final void detachFromContainer() // throws IOException
    {
<span class="fc" id="L974">        checkForLock();</span>

<span class="fc" id="L976">        clearSymbolIDValues();</span>
<span class="fc" id="L977">        _context = ContainerlessContext.wrap(getSystem());</span>

<span class="fc" id="L979">        _fieldName = null;</span>
<span class="fc" id="L980">        _fieldId = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L981">        _elementid(0);</span>
<span class="fc" id="L982">    }</span>

    public void dump(PrintWriter out)
    {
<span class="nc" id="L986">        out.println(this);</span>
<span class="nc" id="L987">    }</span>

    public String validate()
    {
<span class="nc" id="L991">        return null;</span>
    }
}

// current size 32 bit: 5*4 + 2 + 1 +  8 = 31 bytes (32 allocated)
//              64 bit: 5*8 + 2 + 1 + 16 = 59 bytes (64 allocated)

/*

private byte             _flags;

private IonValueContextLite _context {
    private IonContainerLite _parent;
    private IonSystem        _system;
    private SymbolTable      _symbolTable;
}

/ * nope: the cost of cloning a value when
* a field name is added seems like over
* kill.
*
* The cost of virtual calls for all value
* access also seems like too high a price
* to pay for the 1 reference saving.
*
* So we'll leave fieldName as a local member
*
//    private IonValueContentLite {
//        union IonValueValueLite {
//            IonContainer
//            IonScalar
//            IonField {
//                String _fieldName;
//            }
//        }
//    }


/ * nope:  by the time you have the reference to the
 *        array list like object (IonValueAnnotations
 *        below) you have half the overhead.  The vast
 *        majority of values have no annotations.  Of
 *        those that have annotations the vast majority
 *        have only 1.  2 and more drop off very quickly.
 *
 *        As such just an array that realloc-ed and the
 *        annotations come and go should be fine.
 *        Certainly the realloc cost is high but the
 *        normal case is alloc for 1 and you're done.
 *
 *        adding support for ignoring null references
 *        means we can mostly calculate the count as
 *        needed, drop out of search loops soon, and
 *        just pay a scan on add annotation.
 *
 * private IonValueAnnotations {
 *   private String[]         _annotations;
 *   private short            _annotation_count;
 * }
 * /
private String[]         _annotations; // just realloc as needed

32 bit: 3*4 + 1

*/

/**
 * ContainingContext is an interface supported
 * by all containers + a ConcreteContext object.
 *
 * For IonDatagramLite and any &quot;uncontained&quot; value
 * the _context member points to a ConcreteContext
 * where:
 *      getContainer return null
 *      getSymbolTable returns the current symbol table
 *      getSystem returns the instance of IonSystemLite
 *        that created this datagram (and it's contained
 *        values)
 *
 * For IonContainerLite each container implements the
 * interface directly.  In addition their _context
 * member has either their parent container or a concrete
 * context.  The IonContainerLite implementations return:
 *
 *      getContainer returns this
 *      getSymbolTable delegates to the _context object
 *      getSystem delegates to the _context object
 *
 *
 *    interface IonContainingContextLite {
 *        IonContainer getParent();
 *        IonSystem    getSystem();
 *        SymbolTable  getSymbolTable();
 *    }
 *
 *   private IonContainerLite _parent;
 *   private IonSystem        _system;
 *   private SymbolTable      _symbolTable;
 *
 */

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>