<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReverseBinaryEncoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl.lite</a> &gt; <span class="el_source">ReverseBinaryEncoder.java</span></div><h1>ReverseBinaryEncoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl.lite;

import static software.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static software.amazon.ion.SystemSymbols.IMPORTS_SID;
import static software.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE_SID;
import static software.amazon.ion.SystemSymbols.MAX_ID_SID;
import static software.amazon.ion.SystemSymbols.NAME_SID;
import static software.amazon.ion.SystemSymbols.SYMBOLS_SID;
import static software.amazon.ion.SystemSymbols.VERSION_SID;
import static software.amazon.ion.impl.PrivateIonConstants.BINARY_VERSION_MARKER_1_0;
import static software.amazon.ion.impl.PrivateIonConstants.lnBooleanFalse;
import static software.amazon.ion.impl.PrivateIonConstants.lnBooleanTrue;
import static software.amazon.ion.impl.PrivateIonConstants.lnIsNull;
import static software.amazon.ion.impl.PrivateIonConstants.lnIsVarLen;
import static software.amazon.ion.impl.PrivateIonConstants.tidBlob;
import static software.amazon.ion.impl.PrivateIonConstants.tidBoolean;
import static software.amazon.ion.impl.PrivateIonConstants.tidClob;
import static software.amazon.ion.impl.PrivateIonConstants.tidDecimal;
import static software.amazon.ion.impl.PrivateIonConstants.tidFloat;
import static software.amazon.ion.impl.PrivateIonConstants.tidList;
import static software.amazon.ion.impl.PrivateIonConstants.tidNegInt;
import static software.amazon.ion.impl.PrivateIonConstants.tidNull;
import static software.amazon.ion.impl.PrivateIonConstants.tidPosInt;
import static software.amazon.ion.impl.PrivateIonConstants.tidSexp;
import static software.amazon.ion.impl.PrivateIonConstants.tidString;
import static software.amazon.ion.impl.PrivateIonConstants.tidStruct;
import static software.amazon.ion.impl.PrivateIonConstants.tidSymbol;
import static software.amazon.ion.impl.PrivateIonConstants.tidTimestamp;
import static software.amazon.ion.impl.PrivateIonConstants.tidTypedecl;

import java.io.IOException;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.ListIterator;
import software.amazon.ion.Decimal;
import software.amazon.ion.IonBlob;
import software.amazon.ion.IonBool;
import software.amazon.ion.IonClob;
import software.amazon.ion.IonDatagram;
import software.amazon.ion.IonDecimal;
import software.amazon.ion.IonException;
import software.amazon.ion.IonFloat;
import software.amazon.ion.IonInt;
import software.amazon.ion.IonList;
import software.amazon.ion.IonSequence;
import software.amazon.ion.IonSexp;
import software.amazon.ion.IonString;
import software.amazon.ion.IonStruct;
import software.amazon.ion.IonSymbol;
import software.amazon.ion.IonSystem;
import software.amazon.ion.IonTimestamp;
import software.amazon.ion.IonValue;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.Timestamp;


/**
 * Encoder implementation that encodes a IonDatagram into binary format using a
 * reverse encoding algorithm instead of the default pre-order (left-to-right)
 * two-pass algorithm.
 * &lt;p&gt;
 * This reverse encoding algorithm requires a fully materialized IonDatagram
 * DOM to qualify for use. It uses a single buffer, {@link #myBuffer}, to hold
 * the entire binary-encoded data, with an integer, {@link #myOffset}, to index
 * the current position to write the bytes.
 * &lt;p&gt;
 * The algorithm begins by traversing from the last top-level value to the
 * first top-level value. During this traversal, it recursively goes into the
 * nested values of the top-level value being traversed in a similar
 * last-to-first (right-to-left) order.
 */
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">class ReverseBinaryEncoder</span>
{
<span class="fc" id="L91">    private static final BigInteger MAX_LONG_VALUE =</span>
<span class="fc" id="L92">        BigInteger.valueOf(Long.MAX_VALUE);</span>

    private static final int NULL_LENGTH_MASK   = lnIsNull;

    private static final int TYPE_NULL          = tidNull       &lt;&lt; 4;
    private static final int TYPE_BOOL          = tidBoolean    &lt;&lt; 4;
    private static final int TYPE_POS_INT       = tidPosInt     &lt;&lt; 4;
    private static final int TYPE_NEG_INT       = tidNegInt     &lt;&lt; 4;
    private static final int TYPE_FLOAT         = tidFloat      &lt;&lt; 4;
    private static final int TYPE_DECIMAL       = tidDecimal    &lt;&lt; 4;
    private static final int TYPE_TIMESTAMP     = tidTimestamp  &lt;&lt; 4;
    private static final int TYPE_SYMBOL        = tidSymbol     &lt;&lt; 4;
    private static final int TYPE_STRING        = tidString     &lt;&lt; 4;
    private static final int TYPE_CLOB          = tidClob       &lt;&lt; 4;
    private static final int TYPE_BLOB          = tidBlob       &lt;&lt; 4;
    private static final int TYPE_LIST          = tidList       &lt;&lt; 4;
    private static final int TYPE_SEXP          = tidSexp       &lt;&lt; 4;
    private static final int TYPE_STRUCT        = tidStruct     &lt;&lt; 4;
    private static final int TYPE_ANNOTATIONS   = tidTypedecl   &lt;&lt; 4;

    /**
     * Holds the entire binary encoded data. When IonDatagram is fully encoded
     * into binary data, this byte array will hold that data.
     */
    private byte[] myBuffer;

    /**
     * Index onto the position where the bytes are last written to the buffer.
     * That means that if you want to write 1 more byte to the buffer, you have
     * to decrease the index by 1 (myOffset - 1).
     */
    private int myOffset;

    /**
     * The symbol table attached to the IonValue (and its nested values)
     * that the encoder is currently traversing on.
     */
    private SymbolTable mySymbolTable;

    private IonSystem myIonSystem;

    ReverseBinaryEncoder(int initialSize)
<span class="fc" id="L134">    {</span>
<span class="fc" id="L135">        myBuffer = new byte[initialSize];</span>
<span class="fc" id="L136">        myOffset = initialSize;</span>
<span class="fc" id="L137">    }</span>

    /**
     * Returns the size of the Ion binary-encoded byte array.
     * &lt;p&gt;
     * This makes an unchecked assumption that {{@link #serialize(IonDatagram)}
     * is already called.
     *
     * @return the number of bytes of the byte array
     */
    int byteSize()
    {
<span class="fc" id="L149">        return myBuffer.length - myOffset;</span>
    }

    /**
     * Copies the current contents of the Ion binary-encoded byte array into a
     * new byte array. The allocates an array of the size needed to exactly hold
     * the output and copies the entire byte array to it.
     * &lt;p&gt;
     * This makes an unchecked assumption that {{@link #serialize(IonDatagram)}
     * is already called.
     *
     * @return the newly allocated byte array
     */
    byte[] toNewByteArray()
    {
<span class="fc" id="L164">        int length = myBuffer.length - myOffset;</span>
<span class="fc" id="L165">        byte[] bytes = new byte[length];</span>
<span class="fc" id="L166">        System.arraycopy(myBuffer, myOffset, bytes, 0, length);</span>
<span class="fc" id="L167">        return bytes;</span>
    }

    /**
     * Copies the current contents of the Ion binary-encoded byte array to a
     * specified stream.
     * &lt;p&gt;
     * This makes an unchecked assumption that {{@link #serialize(IonDatagram)}
     * is already called.
     *
     * @return the number of bytes written into {@code out}
     *
     * @throws IOException
     */
    int writeBytes(OutputStream out)
        throws IOException
    {
<span class="fc" id="L184">        int length = myBuffer.length - myOffset;</span>
<span class="fc" id="L185">        byte[] bytes = new byte[length];</span>
<span class="fc" id="L186">        System.arraycopy(myBuffer, myOffset, bytes, 0, length);</span>
<span class="fc" id="L187">        out.write(bytes);</span>
<span class="fc" id="L188">        return length;</span>
    }

    /**
     * Serialize the IonDatagram into Ion binary-encoding, to the internal
     * byte array buffer of the encoder.
     * &lt;p&gt;
     * If the IonDatagram has been modified after this method call, you
     * &lt;em&gt;must&lt;/em&gt; call this method again to correctly reflect the
     * modifications.
     *
     * @throws IonException
     */
    void serialize(IonDatagram dg)
        throws IonException
    {
<span class="fc" id="L204">        myIonSystem = dg.getSystem();</span>
<span class="fc" id="L205">        mySymbolTable = null;</span>

        // Write all top-level values in reverse
<span class="fc" id="L208">        writeIonValue(dg);</span>

        // After all top-level values are written, write the local symbol table
        // that is attached to the top-level value that has just been written,
        // if it exists.
<span class="fc bfc" id="L213" title="All 4 branches covered.">        if (mySymbolTable != null &amp;&amp; mySymbolTable.isLocalTable()) {</span>
<span class="fc" id="L214">            writeLocalSymbolTable(mySymbolTable);</span>
        }

        // Write IVM
<span class="fc" id="L218">        writeBytes(BINARY_VERSION_MARKER_1_0);</span>
<span class="fc" id="L219">    }</span>

    void serialize(SymbolTable symTab)
        throws IonException
    {
<span class="nc" id="L224">        writeLocalSymbolTable(symTab);</span>
<span class="nc" id="L225">    }</span>

    /**
     * Grows the current buffer and returns the updated offset.
     *
     * @param offset the original offset
     * @return the updated offset
     */
    private int growBuffer(int offset)
    {
<span class="nc bnc" id="L235" title="All 4 branches missed.">        assert offset &lt; 0;</span>
<span class="nc" id="L236">        byte[] oldBuf = myBuffer;</span>
<span class="nc" id="L237">        int oldLen = oldBuf.length;</span>
<span class="nc" id="L238">        byte[] newBuf = new byte[(-offset + oldLen) &lt;&lt; 1]; // Double the buffer</span>
<span class="nc" id="L239">        int oldBegin = newBuf.length - oldLen;</span>
<span class="nc" id="L240">        System.arraycopy(oldBuf, 0, newBuf, oldBegin, oldLen);</span>
<span class="nc" id="L241">        myBuffer = newBuf;</span>
<span class="nc" id="L242">        myOffset += oldBegin;</span>
<span class="nc" id="L243">        return offset + oldBegin;</span>
    }

    /**
     * Writes the IonValue and its nested values recursively, including
     * annotations.
     *
     * @param value
     * @throws IonException
     */
    private void writeIonValue(IonValue value)
        throws IonException
    {
<span class="fc" id="L256">        final int valueOffset = myBuffer.length - myOffset;</span>

<span class="pc bpc" id="L258" title="1 of 15 branches missed.">        switch (value.getType())</span>
        {
            // scalars
<span class="fc" id="L261">            case BLOB:      writeIonBlobContent((IonBlob) value);            break;</span>
<span class="fc" id="L262">            case BOOL:      writeIonBoolContent((IonBool) value);            break;</span>
<span class="fc" id="L263">            case CLOB:      writeIonClobContent((IonClob) value);            break;</span>
<span class="fc" id="L264">            case DECIMAL:   writeIonDecimalContent((IonDecimal) value);      break;</span>
<span class="fc" id="L265">            case FLOAT:     writeIonFloatContent((IonFloat) value);          break;</span>
<span class="fc" id="L266">            case INT:       writeIonIntContent((IonInt) value);              break;</span>
<span class="fc" id="L267">            case NULL:      writeIonNullContent();                           break;</span>
<span class="fc" id="L268">            case STRING:    writeIonStringContent((IonString) value);        break;</span>
<span class="fc" id="L269">            case SYMBOL:    writeIonSymbolContent((IonSymbol) value);        break;</span>
<span class="fc" id="L270">            case TIMESTAMP: writeIonTimestampContent((IonTimestamp) value);  break;</span>
            // containers
<span class="fc" id="L272">            case LIST:      writeIonListContent((IonList) value);            break;</span>
<span class="fc" id="L273">            case SEXP:      writeIonSexpContent((IonSexp) value);            break;</span>
<span class="fc" id="L274">            case STRUCT:    writeIonStructContent((IonStruct) value);        break;</span>
            // IonDatagram
<span class="fc" id="L276">            case DATAGRAM:  writeIonDatagramContent((IonDatagram) value);    break;</span>
            default:
<span class="nc" id="L278">                throw new IonException(&quot;IonType is unknown: &quot; + value.getType());</span>
        }

<span class="fc" id="L281">        writeAnnotations(value, valueOffset);</span>
<span class="fc" id="L282">    }</span>

    // =========================================================================
    // Basic Field Formats (Primitive Fields)
    // =========================================================================

    private void writeByte(int b)
    {
<span class="fc" id="L290">        int offset = myOffset;</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (--offset &lt; 0) {</span>
<span class="nc" id="L292">            offset = growBuffer(offset);</span>
        }
        // Using narrowing primitive conversion from int to byte
<span class="fc" id="L295">        myBuffer[offset] = (byte) b;</span>
<span class="fc" id="L296">        myOffset = offset;</span>
<span class="fc" id="L297">    }</span>

    private void writeBytes(byte[] bytes)
    {
<span class="fc" id="L301">        int length = bytes.length;</span>
<span class="fc" id="L302">        int offset = myOffset;</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if ((offset -= length) &lt; 0) {</span>
<span class="nc" id="L304">            offset = growBuffer(offset);</span>
        }
<span class="fc" id="L306">        System.arraycopy(bytes, 0, myBuffer, offset, length);</span>
<span class="fc" id="L307">        myOffset = offset;</span>
<span class="fc" id="L308">    }</span>

    private void writeUInt(long v)
    {
<span class="fc" id="L312">        int offset = myOffset;</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (v &lt; (1L &lt;&lt; (8 * 1)))</span>
        {
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (--offset &lt; 0) {</span>
<span class="nc" id="L317">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L319">            myBuffer[offset] = (byte) v;</span>
        }
<span class="fc bfc" id="L321" title="All 2 branches covered.">        else if (v &lt; (1L &lt;&lt; (8 * 2)))</span>
        {
<span class="fc" id="L323">            offset -= 2;</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">            if (offset &lt; 0) {</span>
<span class="nc" id="L325">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L327">            myBuffer[offset]   = (byte) (v &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L328">            myBuffer[offset+1] = (byte)  v;</span>
        }
<span class="fc bfc" id="L330" title="All 2 branches covered.">        else if (v &lt; (1L &lt;&lt; (8 * 3)))</span>
        {
<span class="fc" id="L332">            offset -= 3;</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (offset &lt; 0) {</span>
<span class="nc" id="L334">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L336">            myBuffer[offset]   = (byte) (v &gt;&gt;&gt; (8 * 2));</span>
<span class="fc" id="L337">            myBuffer[offset+1] = (byte) (v &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L338">            myBuffer[offset+2] = (byte)  v;</span>
        }
<span class="fc bfc" id="L340" title="All 2 branches covered.">        else if (v &lt; (1L &lt;&lt; (8 * 4)))</span>
        {
<span class="fc" id="L342">            offset -= 4;</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">            if (offset &lt; 0) {</span>
<span class="nc" id="L344">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L346">            myBuffer[offset]   = (byte) (v &gt;&gt;&gt; (8 * 3));</span>
<span class="fc" id="L347">            myBuffer[offset+1] = (byte) (v &gt;&gt;&gt; (8 * 2));</span>
<span class="fc" id="L348">            myBuffer[offset+2] = (byte) (v &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L349">            myBuffer[offset+3] = (byte)  v;</span>
        }
<span class="fc bfc" id="L351" title="All 2 branches covered.">        else if (v &lt; (1L &lt;&lt; (8 * 5)))</span>
        {
<span class="fc" id="L353">            offset -= 5;</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            if (offset &lt; 0) {</span>
<span class="nc" id="L355">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L357">            myBuffer[offset]   = (byte) (v &gt;&gt;&gt; (8 * 4));</span>
<span class="fc" id="L358">            myBuffer[offset+1] = (byte) (v &gt;&gt;&gt; (8 * 3));</span>
<span class="fc" id="L359">            myBuffer[offset+2] = (byte) (v &gt;&gt;&gt; (8 * 2));</span>
<span class="fc" id="L360">            myBuffer[offset+3] = (byte) (v &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L361">            myBuffer[offset+4] = (byte)  v;</span>
        }
<span class="fc bfc" id="L363" title="All 2 branches covered.">        else if (v &lt; (1L &lt;&lt; (8 * 6)))</span>
        {
<span class="fc" id="L365">            offset -= 6;</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            if (offset &lt; 0) {</span>
<span class="nc" id="L367">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L369">            myBuffer[offset]   = (byte) (v &gt;&gt;&gt; (8 * 5));</span>
<span class="fc" id="L370">            myBuffer[offset+1] = (byte) (v &gt;&gt;&gt; (8 * 4));</span>
<span class="fc" id="L371">            myBuffer[offset+2] = (byte) (v &gt;&gt;&gt; (8 * 3));</span>
<span class="fc" id="L372">            myBuffer[offset+3] = (byte) (v &gt;&gt;&gt; (8 * 2));</span>
<span class="fc" id="L373">            myBuffer[offset+4] = (byte) (v &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L374">            myBuffer[offset+5] = (byte)  v;</span>
        }
<span class="fc bfc" id="L376" title="All 2 branches covered.">        else if (v &lt; (1L &lt;&lt; (8 * 7)))</span>
        {
<span class="fc" id="L378">            offset -= 7;</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (offset &lt; 0) {</span>
<span class="nc" id="L380">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L382">            myBuffer[offset]   = (byte) (v &gt;&gt;&gt; (8 * 6));</span>
<span class="fc" id="L383">            myBuffer[offset+1] = (byte) (v &gt;&gt;&gt; (8 * 5));</span>
<span class="fc" id="L384">            myBuffer[offset+2] = (byte) (v &gt;&gt;&gt; (8 * 4));</span>
<span class="fc" id="L385">            myBuffer[offset+3] = (byte) (v &gt;&gt;&gt; (8 * 3));</span>
<span class="fc" id="L386">            myBuffer[offset+4] = (byte) (v &gt;&gt;&gt; (8 * 2));</span>
<span class="fc" id="L387">            myBuffer[offset+5] = (byte) (v &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L388">            myBuffer[offset+6] = (byte)  v;</span>
        }
        else
        {
<span class="fc" id="L392">            offset -= 8;</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">            if (offset &lt; 0) {</span>
<span class="nc" id="L394">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L396">            myBuffer[offset]   = (byte) (v &gt;&gt;&gt; (8 * 7));</span>
<span class="fc" id="L397">            myBuffer[offset+1] = (byte) (v &gt;&gt;&gt; (8 * 6));</span>
<span class="fc" id="L398">            myBuffer[offset+2] = (byte) (v &gt;&gt;&gt; (8 * 5));</span>
<span class="fc" id="L399">            myBuffer[offset+3] = (byte) (v &gt;&gt;&gt; (8 * 4));</span>
<span class="fc" id="L400">            myBuffer[offset+4] = (byte) (v &gt;&gt;&gt; (8 * 3));</span>
<span class="fc" id="L401">            myBuffer[offset+5] = (byte) (v &gt;&gt;&gt; (8 * 2));</span>
<span class="fc" id="L402">            myBuffer[offset+6] = (byte) (v &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L403">            myBuffer[offset+7] = (byte)  v;</span>
        }

<span class="fc" id="L406">        myOffset = offset;</span>
<span class="fc" id="L407">    }</span>

    /**
     * Write a VarUInt field. VarUInts are sequence of bytes. The high-order
     * bit of the last octet is one, indicating the end of the sequence. All
     * other high-order bits must be zero.
     * &lt;p&gt;
     * Writes at least one byte, even for zero values. int parameter is enough
     * as the scalar and container writers do not have APIs that return long or
     * BigInteger representations.
     *
     * @param v
     */
    private void writeVarUInt(int v)
    {
<span class="fc" id="L422">        int offset = myOffset;</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">        if (v &lt; (1 &lt;&lt; (7 * 1)))               // 1 byte - 7 bits used - 0x7f max</span>
        {
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">            if (--offset &lt; 0) {</span>
<span class="nc" id="L427">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L429">            myBuffer[offset]     = (byte) (v | 0x80 );</span>
        }
<span class="fc bfc" id="L431" title="All 2 branches covered.">        else if (v &lt; (1 &lt;&lt; (7 * 2)))          // 2 bytes - 14 bits used - 0x3fff max</span>
        {
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">            if ((offset -= 2) &lt; 0) {</span>
<span class="nc" id="L434">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L436">            myBuffer[offset]     = (byte) (v &gt;&gt;&gt; (7 * 1));</span>
<span class="fc" id="L437">            myBuffer[offset + 1] = (byte) (v | 0x80);</span>
        }
<span class="fc bfc" id="L439" title="All 2 branches covered.">        else if (v &lt; (1 &lt;&lt; (7 * 3)))          // 3 bytes - 21 bits used - 0x1fffff max</span>
        {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            if ((offset -= 3) &lt; 0) {</span>
<span class="nc" id="L442">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L444">            myBuffer[offset]     = (byte) ( v &gt;&gt;&gt; (7 * 2));</span>
<span class="fc" id="L445">            myBuffer[offset + 1] = (byte) ((v &gt;&gt;&gt; (7 * 1)) &amp; 0x7f);</span>
<span class="fc" id="L446">            myBuffer[offset + 2] = (byte) ( v | 0x80);</span>
        }
<span class="fc bfc" id="L448" title="All 2 branches covered.">        else if (v &lt; (1 &lt;&lt; (7 * 4)))          // 4 bytes - 28 bits used - 0xfffffff max</span>
        {
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            if ((offset -= 4) &lt; 0) {</span>
<span class="nc" id="L451">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L453">            myBuffer[offset]     = (byte) ( v &gt;&gt;&gt; (7 * 3));</span>
<span class="fc" id="L454">            myBuffer[offset + 1] = (byte) ((v &gt;&gt;&gt; (7 * 2)) &amp; 0x7f);</span>
<span class="fc" id="L455">            myBuffer[offset + 2] = (byte) ((v &gt;&gt;&gt; (7 * 1)) &amp; 0x7f);</span>
<span class="fc" id="L456">            myBuffer[offset + 3] = (byte) ( v | 0x80);</span>
        }
        else                                  // 5 bytes - 32 bits used - 0x7fffffff max (Integer.MAX_VALUE)
        {
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">            if ((offset -= 5) &lt; 0) {</span>
<span class="nc" id="L461">                offset = growBuffer(offset);</span>
            }
<span class="fc" id="L463">            myBuffer[offset]     = (byte) ( v &gt;&gt;&gt; (7 * 4));</span>
<span class="fc" id="L464">            myBuffer[offset + 1] = (byte) ((v &gt;&gt;&gt; (7 * 3)) &amp; 0x7f);</span>
<span class="fc" id="L465">            myBuffer[offset + 2] = (byte) ((v &gt;&gt;&gt; (7 * 2)) &amp; 0x7f);</span>
<span class="fc" id="L466">            myBuffer[offset + 3] = (byte) ((v &gt;&gt;&gt; (7 * 1)) &amp; 0x7f);</span>
<span class="fc" id="L467">            myBuffer[offset + 4] = (byte) ( v | 0x80);</span>
        }

<span class="fc" id="L470">        myOffset = offset;</span>
<span class="fc" id="L471">    }</span>

    /**
     * Write a VarInt field. VarInts are sequence of bytes. The high-order bit
     * of the last octet is one, indicating the end of the sequence. All other
     * high-order bits must be zero. The second-highest order bit (0x40) is a
     * sign flag in the first octet of the representation, but part of the
     * extension bits for all other octets.
     * &lt;p&gt;
     * Writes at least one byte, even for zero values. int parameter is enough
     * as the scalar and container writers do not have APIs that return long or
     * BigInteger representations.
     *
     * @param v
     */
    private void writeVarInt(int v)
    {
<span class="fc bfc" id="L488" title="All 2 branches covered.">        if (v == 0)</span>
        {
<span class="fc" id="L490">            writeByte(0x80);</span>
        }
        else
        {
<span class="fc" id="L494">            int offset = myOffset;</span>

<span class="fc bfc" id="L496" title="All 2 branches covered.">            boolean is_negative = (v &lt; 0);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (is_negative)</span>
            {
                // note that for Integer.MIN_VALUE (0x80000000) the negative
                // is the same, but that's also the bit pattern we need to
                // write out - so no worries
<span class="fc" id="L502">                v = -v;</span>
            }

<span class="fc bfc" id="L505" title="All 2 branches covered.">            if (v &lt; (1 &lt;&lt; (7 * 1 - 1)))           // 1 byte - 6 bits used - 0x3f max</span>
            {
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">                if (--offset &lt; 0) {</span>
<span class="nc" id="L508">                    offset = growBuffer(offset);</span>
                }
<span class="fc bfc" id="L510" title="All 2 branches covered.">                if (is_negative)</span>
<span class="fc" id="L511">                    v |= 0x40;</span>
<span class="fc" id="L512">                myBuffer[offset]     = (byte) (v | 0x80);</span>
            }
<span class="fc bfc" id="L514" title="All 2 branches covered.">            else if (v &lt; (1 &lt;&lt; (7 * 2 - 1)))      // 2 bytes - 13 bits used - 0x1fff max</span>
            {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                if ((offset -= 2) &lt; 0) {</span>
<span class="nc" id="L517">                    offset = growBuffer(offset);</span>
                }
<span class="fc bfc" id="L519" title="All 2 branches covered.">                if (is_negative)</span>
<span class="fc" id="L520">                    v |= 0x2000;</span>
<span class="fc" id="L521">                myBuffer[offset]     = (byte) (v &gt;&gt;&gt; (7 * 1));</span>
<span class="fc" id="L522">                myBuffer[offset + 1] = (byte) (v | 0x80);</span>
            }
<span class="fc bfc" id="L524" title="All 2 branches covered.">            else if (v &lt; (1 &lt;&lt; (7 * 3 - 1)))      // 3 bytes - 20 bits used - 0xfffff max</span>
            {
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                if ((offset -= 3) &lt; 0) {</span>
<span class="nc" id="L527">                    offset = growBuffer(offset);</span>
                }
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                if (is_negative)</span>
<span class="nc" id="L530">                    v |= 0x100000;</span>
<span class="fc" id="L531">                myBuffer[offset]     = (byte) ( v &gt;&gt;&gt; (7 * 2));</span>
<span class="fc" id="L532">                myBuffer[offset + 1] = (byte) ((v &gt;&gt;&gt; (7 * 1)) &amp; 0x7f);</span>
<span class="fc" id="L533">                myBuffer[offset + 2] = (byte) ( v | 0x80);</span>
            }
<span class="fc bfc" id="L535" title="All 2 branches covered.">            else if (v &lt; (1 &lt;&lt; (7 * 4 - 1)))      // 4 bytes - 27 bits used - 0x7ffffff max</span>
            {
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">                if ((offset -= 4) &lt; 0) {</span>
<span class="nc" id="L538">                    offset = growBuffer(offset);</span>
                }
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">                if (is_negative)</span>
<span class="nc" id="L541">                    v |= 0x8000000;</span>
<span class="fc" id="L542">                myBuffer[offset]     = (byte) ( v &gt;&gt;&gt; (7 * 3));</span>
<span class="fc" id="L543">                myBuffer[offset + 1] = (byte) ((v &gt;&gt;&gt; (7 * 2)) &amp; 0x7f);</span>
<span class="fc" id="L544">                myBuffer[offset + 2] = (byte) ((v &gt;&gt;&gt; (7 * 1)) &amp; 0x7f);</span>
<span class="fc" id="L545">                myBuffer[offset + 3] = (byte) ( v | 0x80);</span>
            }
            else                                  // 5 bytes - 31 bits used - 0x7fffffff max (Integer.MAX_VALUE)
            {
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">                if ((offset -= 5) &lt; 0) {</span>
<span class="nc" id="L550">                    offset = growBuffer(offset);</span>
                }

                // This is different from the previous if-blocks because we
                // cannot represent a int with more than 32 bits to perform
                // the &quot;OR-assignment&quot; (|=).
<span class="fc" id="L556">                myBuffer[offset]     = (byte) ((v &gt;&gt;&gt; (7 * 4)) &amp; 0x7f);</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">                if (is_negative) {</span>
<span class="nc" id="L558">                    myBuffer[offset] |= 0x40;</span>
                }

<span class="fc" id="L561">                myBuffer[offset + 1] = (byte) ((v &gt;&gt;&gt; (7 * 3)) &amp; 0x7f);</span>
<span class="fc" id="L562">                myBuffer[offset + 2] = (byte) ((v &gt;&gt;&gt; (7 * 2)) &amp; 0x7f);</span>
<span class="fc" id="L563">                myBuffer[offset + 3] = (byte) ((v &gt;&gt;&gt; (7 * 1)) &amp; 0x7f);</span>
<span class="fc" id="L564">                myBuffer[offset + 4] = (byte) ( v | 0x80);</span>
            }

<span class="fc" id="L567">            myOffset = offset;</span>
        }
<span class="fc" id="L569">    }</span>

    // =========================================================================
    // Type Descriptors
    // =========================================================================

    /**
     * Writes the prefix (type and length) preceding the body of an encoded
     * value. This method is only called &lt;em&gt;after&lt;/em&gt; a value's body is
     * written to the buffer.
     *
     * @param type
     *        the value's type, a four-bit high-nibble mask
     * @param length
     *        the number of bytes (octets) in the body, excluding the prefix
     *        itself
     */
    private void writePrefix(int type, int length)
    {
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (length &gt;= lnIsVarLen)</span>
        {
<span class="fc" id="L590">            writeVarUInt(length);</span>
<span class="fc" id="L591">            length = lnIsVarLen;</span>
        }

<span class="fc" id="L594">        int offset = myOffset;</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (--offset &lt; 0) {</span>
<span class="nc" id="L596">            offset = growBuffer(offset);</span>
        }
<span class="fc" id="L598">        myBuffer[offset] = (byte) (type | length);</span>
<span class="fc" id="L599">        myOffset = offset;</span>
<span class="fc" id="L600">    }</span>

    private void writeAnnotations(IonValue value, int endOfValueOffset)
    {
<span class="fc" id="L604">        SymbolToken[] annotationSymTokens = value.getTypeAnnotationSymbols();</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (annotationSymTokens.length &gt; 0)</span>
        {
<span class="fc" id="L607">            final int annotatedValueOffset = myBuffer.length - myOffset;</span>
            int sid;
<span class="fc bfc" id="L609" title="All 2 branches covered.">            for (int i = annotationSymTokens.length; --i &gt;= 0;)</span>
            {
<span class="fc" id="L611">                sid = findSid(annotationSymTokens[i]);</span>
<span class="fc" id="L612">                writeVarUInt(sid);</span>
            }
<span class="fc" id="L614">            writeVarUInt(myBuffer.length - myOffset - annotatedValueOffset);</span>
<span class="fc" id="L615">            writePrefix(TYPE_ANNOTATIONS,</span>
                        myBuffer.length - myOffset - endOfValueOffset);
        }
<span class="fc" id="L618">    }</span>

    // =========================================================================
    // Scalars
    // =========================================================================

    private void writeIonNullContent()
    {
        // null.null
<span class="fc" id="L627">        int encoded = TYPE_NULL | NULL_LENGTH_MASK;</span>
<span class="fc" id="L628">        writeByte(encoded);</span>
<span class="fc" id="L629">    }</span>

    private void writeIonBoolContent(IonBool val)
    {
        int encoded;
<span class="fc bfc" id="L634" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L636">            encoded = TYPE_BOOL | NULL_LENGTH_MASK;</span>
        }
        else
        {
<span class="fc" id="L640">            boolean b = val.booleanValue();</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">            encoded = b ? (TYPE_BOOL | lnBooleanTrue) :</span>
<span class="fc" id="L642">                          (TYPE_BOOL | lnBooleanFalse);</span>
        }
<span class="fc" id="L644">        writeByte(encoded);</span>
<span class="fc" id="L645">    }</span>

    private void writeIonIntContent(IonInt val)
    {
<span class="fc bfc" id="L649" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
            // NOTE: We are only writing the positive binary representation of
            // null value here.
<span class="fc" id="L653">            writeByte((byte) (TYPE_POS_INT | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L657">            BigInteger bigInt = val.bigIntegerValue();</span>
<span class="fc" id="L658">            int signum = bigInt.signum();</span>
            int type;
<span class="fc" id="L660">            final int originalOffset = myBuffer.length - myOffset;</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">            if (signum == 0)</span>
            {
                // Zero has no bytes of data at all
<span class="fc" id="L664">                writeByte((byte) TYPE_POS_INT);</span>
<span class="fc" id="L665">                return; // Finished writing IonInt as zero.</span>
            }
<span class="fc bfc" id="L667" title="All 2 branches covered.">            else if (signum &lt; 0)</span>
            {
<span class="fc" id="L669">                type = TYPE_NEG_INT;</span>
<span class="fc" id="L670">                bigInt = bigInt.negate();</span>
            }
            else
            {
<span class="fc" id="L674">                type = TYPE_POS_INT;</span>
            }

            // Check the value if it's smaller than a long, if so we can use a
            // simpler routine to write the BigInteger value.
<span class="fc bfc" id="L679" title="All 2 branches covered.">            if (bigInt.compareTo(MAX_LONG_VALUE) &lt; 0)</span>
            {
<span class="fc" id="L681">                long lvalue = bigInt.longValue();</span>
<span class="fc" id="L682">                writeUInt(lvalue);</span>
<span class="fc" id="L683">            }</span>
            else
            {
                // BigInteger.toByteArray() returns a two's complement
                // representation byte array. However, we have negated all
                // negative BigInts to become positive BigInts, so essentially
                // we don't have to convert the two's complement representation
                // to sign-magnitude UInt.
<span class="fc" id="L691">                byte[] bits = bigInt.toByteArray();</span>

                // BigInteger will pad this with a null byte sometimes
                // for negative numbers. Let's skip past any leading null bytes.
<span class="fc" id="L695">                int offset = 0;</span>
<span class="pc bpc" id="L696" title="1 of 4 branches missed.">                while (offset &lt; bits.length &amp;&amp; bits[offset] == 0)</span>
                {
<span class="fc" id="L698">                    offset++;</span>
                }

<span class="fc" id="L701">                int actualBitLength = bits.length - offset;</span>
<span class="fc" id="L702">                int bufferOffset = myOffset - actualBitLength;</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">                if (bufferOffset &lt; 0) {</span>
<span class="nc" id="L704">                    bufferOffset = growBuffer(bufferOffset);</span>
                }
<span class="fc" id="L706">                System.arraycopy(bits, offset, myBuffer, bufferOffset,</span>
                                 actualBitLength);
<span class="fc" id="L708">                myOffset = bufferOffset;</span>
            }

<span class="fc" id="L711">            writePrefix(type, myBuffer.length - myOffset - originalOffset);</span>
        }
<span class="fc" id="L713">    }</span>

    private void writeIonFloatContent(IonFloat val)
    {
<span class="fc bfc" id="L717" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L719">            writeByte((byte) (TYPE_FLOAT | NULL_LENGTH_MASK));</span>
        }
        else
        {
            // Write a 64-bit value in IEE-754 standard. This format happens to
            // match the 8-byte UInt encoding.
<span class="fc" id="L725">            long bits = Double.doubleToRawLongBits(val.doubleValue());</span>
<span class="fc" id="L726">            int offset = myOffset;</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">            if ((offset -= 8) &lt; 0) {</span>
<span class="nc" id="L728">                offset = growBuffer(offset);</span>
            }

<span class="fc" id="L731">            myBuffer[offset]     = (byte) (bits &gt;&gt;&gt; (8 * 7));</span>
<span class="fc" id="L732">            myBuffer[offset + 1] = (byte) (bits &gt;&gt;&gt; (8 * 6));</span>
<span class="fc" id="L733">            myBuffer[offset + 2] = (byte) (bits &gt;&gt;&gt; (8 * 5));</span>
<span class="fc" id="L734">            myBuffer[offset + 3] = (byte) (bits &gt;&gt;&gt; (8 * 4));</span>
<span class="fc" id="L735">            myBuffer[offset + 4] = (byte) (bits &gt;&gt;&gt; (8 * 3));</span>
<span class="fc" id="L736">            myBuffer[offset + 5] = (byte) (bits &gt;&gt;&gt; (8 * 2));</span>
<span class="fc" id="L737">            myBuffer[offset + 6] = (byte) (bits &gt;&gt;&gt; (8 * 1));</span>
<span class="fc" id="L738">            myBuffer[offset + 7] = (byte)  bits;</span>

<span class="fc" id="L740">            myOffset = offset;</span>

<span class="fc" id="L742">            writePrefix(TYPE_FLOAT, 8); // 64-bit IEE-754</span>
        }
<span class="fc" id="L744">    }</span>

<span class="fc" id="L746">    private static final byte[] negativeZeroBitArray = new byte[] { (byte) 0x80 };</span>
<span class="fc" id="L747">    private static final byte[] positiveZeroBitArray = new byte[0];</span>

    /**
     * @see software.amazon.ion.impl.IonBinary.Writer#writeDecimalContent
     */
    private void writeIonDecimalContent(BigDecimal bd)
    {
<span class="fc" id="L754">        BigInteger mantissa = bd.unscaledValue();</span>

        byte[] mantissaBits;

<span class="pc bpc" id="L758" title="1 of 4 branches missed.">        switch (mantissa.signum())</span>
        {
            case 0:
<span class="fc bfc" id="L761" title="All 2 branches covered.">                if (Decimal.isNegativeZero(bd))</span>
                {
<span class="fc" id="L763">                    mantissaBits = negativeZeroBitArray;</span>
                }
                else
                {
<span class="fc" id="L767">                    mantissaBits = positiveZeroBitArray;</span>
                }
<span class="fc" id="L769">                break;</span>
            case -1:
                // Obtain the unsigned value of the BigInteger
                // We cannot use the twos complement representation of a
                // negative BigInteger as this is different from the encoding
                // of basic field Int.
<span class="fc" id="L775">                mantissaBits = mantissa.negate().toByteArray();</span>
                // Set the sign on the highest order bit of the first octet
<span class="fc" id="L777">                mantissaBits[0] |= 0x80;</span>
<span class="fc" id="L778">                break;</span>
            case 1:
<span class="fc" id="L780">                mantissaBits = mantissa.toByteArray();</span>
<span class="fc" id="L781">                break;</span>
            default:
<span class="nc" id="L783">                throw new IllegalStateException(&quot;mantissa signum out of range&quot;);</span>
        }

<span class="fc" id="L786">        writeBytes(mantissaBits);</span>

        // Ion stores exponent, BigDecimal uses the negation 'scale' instead
<span class="fc" id="L789">        int exponent = -bd.scale();</span>
<span class="fc" id="L790">        writeVarInt(exponent);</span>
<span class="fc" id="L791">    }</span>

    private void writeIonDecimalContent(IonDecimal val)
    {
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L797">            writeByte((byte) (TYPE_DECIMAL | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L801">            final int originalOffset = myBuffer.length - myOffset;</span>
<span class="fc" id="L802">            writeIonDecimalContent(val.decimalValue());</span>
<span class="fc" id="L803">            writePrefix(TYPE_DECIMAL,</span>
                        myBuffer.length - myOffset - originalOffset);
        }
<span class="fc" id="L806">    }</span>

    private void writeIonTimestampContent(IonTimestamp val)
    {
<span class="fc bfc" id="L810" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L812">            writeByte((byte) (TYPE_TIMESTAMP | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L816">            final int originalOffset = myBuffer.length - myOffset;</span>

<span class="fc" id="L818">            Timestamp t = val.timestampValue();</span>

            // Time and date portion
<span class="pc bpc" id="L821" title="1 of 6 branches missed.">            switch (t.getPrecision())</span>
            {
                // Fall through each case - by design
                case SECOND:
                {
<span class="fc" id="L826">                    BigDecimal fraction = t.getZFractionalSecond();</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">                    if (fraction != null)</span>
                    {
<span class="pc bpc" id="L829" title="2 of 4 branches missed.">                        assert (fraction.signum() &gt;= 0</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">                                &amp;&amp; ! fraction.equals(BigDecimal.ZERO))</span>
                            : &quot;Bad timestamp fraction: &quot; + fraction;
<span class="fc" id="L832">                        writeIonDecimalContent(fraction);</span>
                    }
<span class="fc" id="L834">                    writeVarUInt(t.getZSecond());</span>
                }
                case MINUTE:
<span class="fc" id="L837">                    writeVarUInt(t.getZMinute());</span>
<span class="fc" id="L838">                    writeVarUInt(t.getZHour());</span>
                case DAY:
<span class="fc" id="L840">                    writeVarUInt(t.getZDay());</span>
                case MONTH:
<span class="fc" id="L842">                    writeVarUInt(t.getZMonth());</span>
                case YEAR:
<span class="fc" id="L844">                    writeVarUInt(t.getZYear());</span>
<span class="fc" id="L845">                    break;</span>
                default:
<span class="nc" id="L847">                    throw new IllegalStateException(</span>
                              &quot;unrecognized Timestamp precision: &quot; +
<span class="nc" id="L849">                              t.getPrecision());</span>
            }

            // Offset portion
<span class="fc" id="L853">            Integer offset = t.getLocalOffset();</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (offset == null)</span>
            {
<span class="fc" id="L856">                writeByte((byte) (0x80 | 0x40)); // Negative 0 (no timezone)</span>
            }
            else
            {
<span class="fc" id="L860">                writeVarInt(offset.intValue());</span>
            }

<span class="fc" id="L863">            writePrefix(TYPE_TIMESTAMP,</span>
                        myBuffer.length - myOffset - originalOffset);
        }
<span class="fc" id="L866">    }</span>

    private void writeIonSymbolContent(IonSymbol val)
    {
<span class="fc bfc" id="L870" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L872">            writeByte((byte) (TYPE_SYMBOL | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L876">            final int originalOffset = myBuffer.length - myOffset;</span>
<span class="fc" id="L877">            SymbolToken symToken = val.symbolValue();</span>
<span class="fc" id="L878">            int sid = findSid(symToken);</span>
<span class="fc" id="L879">            writeUInt(sid);</span>

<span class="fc" id="L881">            writePrefix(TYPE_SYMBOL,</span>
                        myBuffer.length - myOffset - originalOffset);
        }
<span class="fc" id="L884">    }</span>

    private void writeIonStringContent(IonString val)
    {
<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L890">            writeByte((byte) (TYPE_STRING | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L894">            writeIonStringContent(val.stringValue());</span>
        }
<span class="fc" id="L896">    }</span>

    private void writeIonStringContent(String str)
    {
<span class="fc" id="L900">        int strlen = str.length();</span>
<span class="fc" id="L901">        byte[] buffer = myBuffer;</span>
<span class="fc" id="L902">        int offset = myOffset;</span>

        // The number of UTF-8 code units (bytes) we will write is at least as
        // large as the number of UTF-16 code units (ints) that are in the
        // input string.  Ensure we have at least that much capacity, to reduce
        // the number of times we need to grow the buffer.
<span class="fc" id="L908">        offset -= strlen;</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">        if (offset &lt; 0)</span>
        {
<span class="nc" id="L911">            offset = growBuffer(offset);</span>
<span class="nc" id="L912">            buffer = myBuffer;</span>
        }
<span class="fc" id="L914">        offset += strlen;</span>

        // Optimize for ASCII, under the assumption that it happens a lot.
        // This fits within the capacity allocated above, so we don't have to
        // grow the buffer within this loop.
<span class="fc" id="L919">        int i = strlen - 1;</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">        for (; i &gt;= 0; --i)</span>
        {
<span class="fc" id="L922">            int c = str.charAt(i);</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">            if (!(c &lt;= 0x7f))</span>
<span class="fc" id="L924">                break;</span>
<span class="fc" id="L925">            buffer[--offset] = (byte) c;</span>
        }

<span class="fc bfc" id="L928" title="All 2 branches covered.">        for (; i &gt;= 0; --i)</span>
        {
<span class="fc" id="L930">            int c = str.charAt(i);</span>

<span class="fc bfc" id="L932" title="All 2 branches covered.">            if (c &lt;= 0x7f)              // U+0000 to U+007f codepoints</span>
            {
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">                if (--offset &lt; 0)</span>
                {
<span class="nc" id="L936">                    offset = growBuffer(offset);</span>
<span class="nc" id="L937">                    buffer = myBuffer;</span>
                }
<span class="fc" id="L939">                buffer[offset] = (byte) c;</span>
            }
<span class="fc bfc" id="L941" title="All 2 branches covered.">            else if (c &lt;= 0x7ff)        // U+0080 to U+07ff codepoints</span>
            {
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">                if ((offset -= 2) &lt; 0)</span>
                {
<span class="nc" id="L945">                    offset = growBuffer(offset);</span>
<span class="nc" id="L946">                    buffer = myBuffer;</span>
                }
<span class="fc" id="L948">                buffer[offset]     = (byte) (0xc0 | ((c &gt;&gt; 6) &amp; 0x1f));</span>
<span class="fc" id="L949">                buffer[offset + 1] = (byte) (0x80 | (c &amp; 0x3f));</span>
            }
<span class="fc bfc" id="L951" title="All 4 branches covered.">            else if (c &gt;= 0xd800 &amp;&amp; c &lt;= 0xdfff) // Surrogate!</span>
            {
                // high surrogate not followed by low surrogate
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">                if (c &lt;= 0xdbff)</span>
                {
<span class="nc" id="L956">                    throw new IonException(&quot;invalid string, unpaired high surrogate character&quot;);</span>
                }

                // string starts with low surrogate
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">                if (i == 0)</span>
                {
<span class="nc" id="L962">                    throw new IonException(&quot;invalid string, unpaired low surrogate character&quot;);</span>
                }

                // low surrogate not preceded by high surrogate
                // charAt(--i) is never out of bounds as i == 0 is asserted to
                // be false in previous if-block
<span class="fc" id="L968">                int c2 = str.charAt(--i);</span>
<span class="pc bpc" id="L969" title="2 of 4 branches missed.">                if (!(c2 &gt;= 0xd800 &amp;&amp; c2 &lt;= 0xdbff))</span>
                {
<span class="nc" id="L971">                    throw new IonException(&quot;invalid string, unpaired low surrogate character&quot;);</span>
                }

                // valid surrogate pair: (c2, c)
<span class="fc" id="L975">                int codepoint = 0x10000 + (((c2 &amp; 0x3ff) &lt;&lt; 10) | (c &amp; 0x3ff));</span>

<span class="pc bpc" id="L977" title="1 of 2 branches missed.">                if ((offset -= 4) &lt; 0)</span>
                {
<span class="nc" id="L979">                    offset = growBuffer(offset);</span>
<span class="nc" id="L980">                    buffer = myBuffer;</span>
                }
<span class="fc" id="L982">                buffer[offset]     = (byte) (0xF0 | ((codepoint &gt;&gt; 18) &amp; 0x07));</span>
<span class="fc" id="L983">                buffer[offset + 1] = (byte) (0x80 | ((codepoint &gt;&gt; 12) &amp; 0x3F));</span>
<span class="fc" id="L984">                buffer[offset + 2] = (byte) (0x80 | ((codepoint &gt;&gt; 6)  &amp; 0x3F));</span>
<span class="fc" id="L985">                buffer[offset + 3] = (byte) (0x80 | ((codepoint &gt;&gt; 0)  &amp; 0x3F));</span>
<span class="fc" id="L986">            }</span>
            else // U+0800 to U+D7FF and U+E000 to U+FFFF codepoints
            {
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">                if ((offset -= 3) &lt; 0)</span>
                {
<span class="nc" id="L991">                    offset = growBuffer(offset);</span>
<span class="nc" id="L992">                    buffer = myBuffer;</span>
                }
<span class="fc" id="L994">                buffer[offset]     = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));</span>
<span class="fc" id="L995">                buffer[offset + 1] = (byte) (0x80 | ((c &gt;&gt; 6) &amp; 0x3F));</span>
<span class="fc" id="L996">                buffer[offset + 2] = (byte) (0x80 | (c &amp; 0x3F));</span>
            }
        }

<span class="fc" id="L1000">        int length = myOffset - offset;</span>
<span class="fc" id="L1001">        myOffset = offset;</span>

<span class="fc" id="L1003">        writePrefix(TYPE_STRING, length);</span>
<span class="fc" id="L1004">    }</span>

    private void writeIonClobContent(IonClob val)
    {
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L1010">            writeByte((byte) (TYPE_CLOB | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L1014">            byte[] lob = val.getBytes();</span>
<span class="fc" id="L1015">            writeLobContent(lob);</span>
<span class="fc" id="L1016">            writePrefix(TYPE_CLOB, lob.length);</span>
        }
<span class="fc" id="L1018">    }</span>

    private void writeIonBlobContent(IonBlob val)
    {
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L1024">            writeByte((byte) (TYPE_BLOB | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L1028">            byte[] lob = val.getBytes();</span>
<span class="fc" id="L1029">            writeLobContent(lob);</span>
<span class="fc" id="L1030">            writePrefix(TYPE_BLOB, lob.length);</span>
        }
<span class="fc" id="L1032">    }</span>

    private void writeLobContent(byte[] lob)
    {
<span class="fc" id="L1036">        int length = lob.length;</span>
<span class="fc" id="L1037">        int offset = myOffset - length;</span>
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">        if (offset &lt; 0) {</span>
<span class="nc" id="L1039">            offset = growBuffer(offset);</span>
        }
<span class="fc" id="L1041">        System.arraycopy(lob, 0, myBuffer, offset, length);</span>
<span class="fc" id="L1042">        myOffset = offset;</span>
<span class="fc" id="L1043">    }</span>

    // =========================================================================
    // Containers
    // =========================================================================

    private void writeIonListContent(IonList val)
    {
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L1053">            writeByte((byte) (TYPE_LIST | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L1057">            writeIonSequenceContent(val);</span>
        }
<span class="fc" id="L1059">    }</span>

    private void writeIonSexpContent(IonSexp val)
    {
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L1065">            writeByte((byte) (TYPE_SEXP | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L1069">            writeIonSequenceContent(val);</span>
        }
<span class="fc" id="L1071">    }</span>

    private void writeIonSequenceContent(IonSequence seq)
    {
<span class="fc" id="L1075">        final int originalOffset = myBuffer.length - myOffset;</span>
<span class="fc" id="L1076">        IonValue[] values = seq.toArray();</span>

<span class="fc bfc" id="L1078" title="All 2 branches covered.">        for (int i = values.length; --i &gt;= 0;)</span>
        {
<span class="fc" id="L1080">            writeIonValue(values[i]);</span>
        }

<span class="pc bpc" id="L1083" title="1 of 3 branches missed.">        switch (seq.getType())</span>
        {
            case LIST:
<span class="fc" id="L1086">                writePrefix(TYPE_LIST,</span>
                            myBuffer.length - myOffset - originalOffset);
<span class="fc" id="L1088">                break;</span>
            case SEXP:
<span class="fc" id="L1090">                writePrefix(TYPE_SEXP,</span>
                            myBuffer.length - myOffset - originalOffset);
<span class="fc" id="L1092">                break;</span>
            default:
<span class="nc" id="L1094">                throw new IonException(</span>
                          &quot;cannot identify instance of IonSequence&quot;);
        }
<span class="fc" id="L1097">    }</span>

    private void writeIonStructContent(IonStruct val)
    {
<span class="fc bfc" id="L1101" title="All 2 branches covered.">        if (val.isNullValue())</span>
        {
<span class="fc" id="L1103">            writeByte((byte) (TYPE_STRUCT | NULL_LENGTH_MASK));</span>
        }
        else
        {
<span class="fc" id="L1107">            final int originalOffset = myBuffer.length - myOffset;</span>

            // TODO amzn/ion-java#31 should not preserve the ordering of fields
<span class="fc" id="L1110">            ArrayList&lt;IonValue&gt; values = new ArrayList&lt;IonValue&gt;();</span>

            // Fill ArrayList with IonValues, the add() just copies the
            // references of the IonValues
<span class="fc bfc" id="L1114" title="All 2 branches covered.">            for (IonValue curr : val)</span>
            {
<span class="fc" id="L1116">                values.add(curr);</span>
<span class="fc" id="L1117">            }</span>

<span class="fc bfc" id="L1119" title="All 2 branches covered.">            for (int i = values.size(); --i &gt;= 0; )</span>
            {
<span class="fc" id="L1121">                IonValue v = values.get(i);</span>
<span class="fc" id="L1122">                SymbolToken symToken = v.getFieldNameSymbol();</span>

<span class="fc" id="L1124">                writeIonValue(v);</span>

<span class="fc" id="L1126">                int sid = findSid(symToken);</span>
<span class="fc" id="L1127">                writeVarUInt(sid);</span>
<span class="fc" id="L1128">            }</span>

            // TODO amzn/ion-java#41 Detect if the struct fields are sorted in ascending
            // order of Sids. If so, 1 should be written into 'length' field.
            // Note that this 'length' field is not the same as the four-bit
            // length L in the type descriptor octet.
<span class="fc" id="L1134">            writePrefix(TYPE_STRUCT,</span>
                        myBuffer.length - myOffset - originalOffset);
        }
<span class="fc" id="L1137">    }</span>

    private void writeIonDatagramContent(IonDatagram dg)
    {
<span class="fc" id="L1141">        ListIterator&lt;IonValue&gt; reverseIter = dg.listIterator(dg.size());</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">        while (reverseIter.hasPrevious())</span>
        {
<span class="fc" id="L1144">            IonValue currentTopLevelValue = reverseIter.previous();</span>
<span class="fc" id="L1145">            checkLocalSymbolTablePlacement(currentTopLevelValue);</span>
<span class="fc" id="L1146">            writeIonValue(currentTopLevelValue);</span>
<span class="fc" id="L1147">        }</span>
<span class="fc" id="L1148">    }</span>

    // =========================================================================
    // Symbol Tables
    // =========================================================================

    private int findSid(SymbolToken symToken)
    {
<span class="fc" id="L1156">        int sid = symToken.getSid();</span>
<span class="fc" id="L1157">        String text = symToken.getText();</span>

<span class="fc bfc" id="L1159" title="All 2 branches covered.">        if (sid != UNKNOWN_SYMBOL_ID)   // sid is assigned</span>
        {
<span class="pc bpc" id="L1161" title="1 of 4 branches missed.">            assert text == null ||</span>
<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">                   text.equals(mySymbolTable.findKnownSymbol(sid));</span>
        }
        else                            // sid is not assigned
        {
<span class="fc bfc" id="L1166" title="All 2 branches covered.">            if (mySymbolTable.isSystemTable())</span>
            {
                // Replace current symtab with a new local symbol table
                // using the default system symtab
<span class="fc" id="L1170">                mySymbolTable = myIonSystem.newLocalSymbolTable();</span>
            }

            // Intern the new symbol and get its assigned sid
<span class="fc" id="L1174">            sid = mySymbolTable.intern(text).getSid();</span>
        }

<span class="fc" id="L1177">        return sid;</span>
    }

    /**
     * Determine if the local symbol table attached to the previous top-level
     * value (TLV), {@link #mySymbolTable}, needs to be encoded before the
     * next TLV is encoded. This is called &lt;em&gt;before&lt;/em&gt; encoding each
     * TLV by {@link #writeIonValue(IonValue)}.
     * &lt;p&gt;
     * Connotations of &quot;Previous TLV&quot; and &quot;Next TLV&quot; in this method are
     * &lt;em&gt;different&lt;/em&gt; from those defined outside of this method.
     * This is done on purpose within this method to facilitate a clear
     * understanding of what is going on within this method.
     * &lt;ul&gt;
     *    &lt;li&gt;&quot;Previous top-level value&quot; refers to the top-level IonValue that
     *    has already been encoded into the buffer.
     *    &lt;li&gt;&quot;Next top-level value&quot; refers to the top-level IonValue that
     *    is about to be encoded to the buffer. Its contents are &lt;em&gt;not&lt;/em&gt;
     *    traversed yet.
     *    &lt;li&gt;&quot;Previous symbol table&quot; refers to previous TLV's symbol table.
     *    &lt;li&gt;&quot;Next symbol table&quot; refers to next TLV's symbol table.
     * &lt;/ul&gt;
     *
     * Local symbol tables and IVMs can be interspersed within an IonDatagram.
     * This method checks for such cases by looking at the next symtab and
     * previous symtab.
     *
     * &lt;h2&gt;The following 4 cases define the scenarios where a LST/IVM is
     * written to the buffer:&lt;/h2&gt;
     * &lt;p&gt;
     * Next symtab is a local table:
     * &lt;ul&gt;
     *    &lt;li&gt;Previous symtab is a local table - write LST if the two symtabs
     *    are different references
     *    &lt;li&gt;Previous symtab is a system table - write IVM always
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Next symtab is a system table:
     * &lt;ul&gt;
     *    &lt;li&gt;Previous symtab is a local table - propagate LST upwards
     *    &lt;li&gt;Previous symtab is a system table - write IVM if the two symtabs
     *    have different Ion versions.
     * &lt;/ul&gt;
     *
     * TODO amzn/ion-java#25 Currently, {@link IonDatagram#systemIterator()} doesn't
     * retain information about interspersed IVMs within the IonDatagram.
     * As such, we cannot obtain the location of interspersed IVMs, if any.
     *
     * @param nextTopLevelValue the next top-level IonValue to be encoded
     */
    private void checkLocalSymbolTablePlacement(IonValue nextTopLevelValue)
    {
        // Check that nextTopLevelValue is indeed a top-level value
<span class="pc bpc" id="L1230" title="2 of 4 branches missed.">        assert nextTopLevelValue == nextTopLevelValue.topLevelValue();</span>

<span class="fc" id="L1232">        SymbolTable nextSymTab = nextTopLevelValue.getSymbolTable();</span>

<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">        if (nextSymTab == null) {</span>
<span class="nc" id="L1235">            throw new IllegalStateException(</span>
                      &quot;Binary reverse encoder isn't using LiteImpl&quot;);
        }

<span class="fc bfc" id="L1239" title="All 2 branches covered.">        if (mySymbolTable == null) {</span>
            // There is no current symtab, i.e. there wasn't any TLV encoded
            // before this, return and continue encoding next TLV.
<span class="fc" id="L1242">            mySymbolTable = nextSymTab;</span>
<span class="fc" id="L1243">            return;</span>
        }

<span class="pc bpc" id="L1246" title="2 of 6 branches missed.">        assert nextSymTab.isLocalTable() || nextSymTab.isSystemTable();</span>

<span class="fc bfc" id="L1248" title="All 2 branches covered.">        if (nextSymTab.isLocalTable())</span>
        {
<span class="fc bfc" id="L1250" title="All 2 branches covered.">            if (mySymbolTable.isSystemTable())</span>
            {
<span class="fc" id="L1252">                writeBytes(BINARY_VERSION_MARKER_1_0);</span>
<span class="fc" id="L1253">                mySymbolTable = nextSymTab;</span>
            }
            // mySymbolTable is local
<span class="fc bfc" id="L1256" title="All 2 branches covered.">            else if (nextSymTab != mySymbolTable)</span>
            {
<span class="fc" id="L1258">                writeLocalSymbolTable(mySymbolTable);</span>
<span class="fc" id="L1259">                mySymbolTable = nextSymTab;</span>
            }
        }
        // nextSymTab is system
<span class="fc bfc" id="L1263" title="All 2 branches covered.">        else if (mySymbolTable.isSystemTable() &amp;&amp;</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">                !mySymbolTable.getIonVersionId().equals(nextSymTab.getIonVersionId()))</span>
        {
<span class="nc" id="L1266">            writeBytes(BINARY_VERSION_MARKER_1_0);</span>
<span class="nc" id="L1267">            mySymbolTable = nextSymTab;</span>
        }
<span class="fc" id="L1269">    }</span>

    /**
     * Write contents of a local symbol table as a struct.
     * The contents are the IST:: annotation, declared symbols, and import
     * declarations (that refer to shared symtabs) if they exist.
     *
     * @param symTab the local symbol table, not shared, not system
     */
    private void writeLocalSymbolTable(SymbolTable symTab)
    {
<span class="pc bpc" id="L1280" title="2 of 4 branches missed.">        assert symTab.isLocalTable();</span>

<span class="fc" id="L1282">        final int originalOffset = myBuffer.length - myOffset;</span>

        // Write declared local symbol strings if any exists
<span class="fc" id="L1285">        writeSymbolsField(symTab);</span>

        // Write import declarations if any exists
<span class="fc" id="L1288">        writeImportsField(symTab);</span>

        // Write the struct prefix
<span class="fc" id="L1291">        writePrefix(TYPE_STRUCT, myBuffer.length - myOffset - originalOffset);</span>

        // Write the $ion_symbol_table annotation
<span class="fc" id="L1294">        byte[] ionSymbolTableByteArray = {</span>
               (byte) (0x80 | 1),                       /* annot-length */
               (byte) (0x80 | ION_SYMBOL_TABLE_SID)     /* annot */
               };
<span class="fc" id="L1298">        writeBytes(ionSymbolTableByteArray);</span>
<span class="fc" id="L1299">        writePrefix(TYPE_ANNOTATIONS,</span>
                    myBuffer.length - myOffset - originalOffset);
<span class="fc" id="L1301">    }</span>

    /**
     * Write a single import declaration (which refers to a shared SymbolTable).
     *
     * @param symTab the shared symbol table, not local, not system
     */
    private void writeImport(SymbolTable symTab)
    {
<span class="pc bpc" id="L1310" title="2 of 4 branches missed.">        assert symTab.isSharedTable();</span>

<span class="fc" id="L1312">        final int originalOffset = myBuffer.length - myOffset;</span>

        // Write the maxId as int
<span class="fc" id="L1315">        int maxId = symTab.getMaxId();</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        if (maxId == 0) {</span>
<span class="fc" id="L1317">            writeByte((byte) TYPE_POS_INT);</span>
        } else {
<span class="fc" id="L1319">            writeUInt(maxId);</span>
<span class="fc" id="L1320">            writePrefix(TYPE_POS_INT,</span>
                        myBuffer.length - myOffset - originalOffset);
        }

        // Write the &quot;max_id&quot; field name
<span class="fc" id="L1325">        writeByte((byte) (0x80 | MAX_ID_SID));</span>

<span class="fc" id="L1327">        final int maxIdOffset = myBuffer.length - myOffset;</span>

        // Write the version as int (version will be at least one)
<span class="fc" id="L1330">        int version = symTab.getVersion();</span>
<span class="fc" id="L1331">        writeUInt(version);</span>
<span class="fc" id="L1332">        writePrefix(TYPE_POS_INT, myBuffer.length - myOffset - maxIdOffset);</span>

        // Write the &quot;version&quot; field name
<span class="fc" id="L1335">        writeByte((byte) (0x80 | VERSION_SID));</span>

        // Write the name as string
<span class="fc" id="L1338">        String name = symTab.getName();</span>
<span class="fc" id="L1339">        writeIonStringContent(name);</span>

        // Write the &quot;name&quot; field name
<span class="fc" id="L1342">        writeByte((byte) (0x80 | NAME_SID));</span>

        // Write the struct prefix
<span class="fc" id="L1345">        writePrefix(TYPE_STRUCT, myBuffer.length - myOffset - originalOffset);</span>
<span class="fc" id="L1346">    }</span>

    /**
     * Write import declarations (which refer to shared symbol tables) if any
     * exists.
     *
     * @param symTab the local symbol table, not shared, not system
     */
    private void writeImportsField(SymbolTable symTab)
    {
        // SymbolTable[] holds accurate information, i.e. it contains the
        // actual import declaration information, through the means of
        // substitute tables if an exact match was not found by the catalog.
<span class="fc" id="L1359">        SymbolTable[] sharedSymTabs = symTab.getImportedTables();</span>

<span class="fc bfc" id="L1361" title="All 2 branches covered.">        if (sharedSymTabs.length == 0)</span>
        {
<span class="fc" id="L1363">            return;</span>
        }

<span class="fc" id="L1366">        final int importsOffset = myBuffer.length - myOffset;</span>

<span class="fc bfc" id="L1368" title="All 2 branches covered.">        for (int i = sharedSymTabs.length; --i &gt;= 0;)</span>
        {
<span class="fc" id="L1370">            writeImport(sharedSymTabs[i]);</span>
        }

<span class="fc" id="L1373">        writePrefix(TYPE_LIST, myBuffer.length - myOffset - importsOffset);</span>
<span class="fc" id="L1374">        writeByte((byte) (0x80 | IMPORTS_SID));</span>
<span class="fc" id="L1375">    }</span>

    /**
     * Write declared local symbol names if any exists.
     *
     * @param symTab the local symbol table, not shared, not system
     */
    private void writeSymbolsField(SymbolTable symTab)
    {
        // SymbolTable's APIs doesn't expose an Iterator to traverse declared
        // symbol strings in reverse order. As such, we utilize these two
        // indexes to traverse the strings in reverse.
<span class="fc" id="L1387">        int importedMaxId = symTab.getImportedMaxId();</span>
<span class="fc" id="L1388">        int maxId = symTab.getMaxId();</span>

<span class="fc bfc" id="L1390" title="All 2 branches covered.">        if (importedMaxId == maxId) {</span>
            // There are no declared local symbols
<span class="fc" id="L1392">            return;</span>
        }

<span class="fc" id="L1395">        final int originalOffset = myBuffer.length - myOffset;</span>

<span class="fc bfc" id="L1397" title="All 2 branches covered.">        for (int i = maxId; i &gt; importedMaxId; i--)</span>
        {
<span class="fc" id="L1399">            String str = symTab.findKnownSymbol(i);</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">            if (str == null) {</span>
<span class="fc" id="L1401">                writeByte((byte) (TYPE_STRING | NULL_LENGTH_MASK));</span>
            } else {
<span class="fc" id="L1403">                writeIonStringContent(str);</span>
            }
        }

<span class="fc" id="L1407">        writePrefix(TYPE_LIST, myBuffer.length - myOffset - originalOffset);</span>
<span class="fc" id="L1408">        writeByte((byte) (0x80 | SYMBOLS_SID));</span>
<span class="fc" id="L1409">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>