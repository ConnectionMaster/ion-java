<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Timestamp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion</a> &gt; <span class="el_source">Timestamp.java</span></div><h1>Timestamp.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion;

import static com.amazon.ion.impl._Private_Utils.safeEquals;
import static com.amazon.ion.util.IonTextUtils.printCodePointAsString;

import com.amazon.ion.impl._Private_Utils;
import com.amazon.ion.util.IonTextUtils;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

/**
 * An immutable representation of a point in time. Ion defines a simple
 * representation of time based on Coordinated Universal Time (UTC).
 * In practice the use of time could be more accurately described as
 * UTC-SLS (UTC Smoothed Leap Seconds) as there is no representation for the
 * leap second discontinuities that UTC has added.
 * &lt;p&gt;
 * Timestamps preserve precision, meaning the fields that are included, and the
 * significant digits of any fractional second.  Only common break
 * points in the values are supported.  Any unspecified fields are handled
 * as the start of the new year/month/day.
 *
 *
 * &lt;h3&gt;Equality and Comparison&lt;/h3&gt;
 *
 * As with {@link IonValue} classes, the {@link #equals equals} methods on this class
 * perform a strict equivalence that observes the precision and local offset
 * of each timestamp.
 * This means that it's possible to have two {@link Timestamp} instances that
 * represent the same point in time but are not {@code equals}.
 * &lt;p&gt;
 * On the other hand, the {@link #compareTo} methods perform point in time
 * comparison, ignoring precision and local offset.
 * Thus the &lt;em&gt;natural comparison method&lt;/em&gt; of this class is &lt;em&gt;not
 * consistent with equals&lt;/em&gt;. See the documentation of {@link Comparable} for
 * further discussion.
 * &lt;p&gt;
 * To illustrate this distinction, consider the following timestamps. None are
 * {@link #equals} to each other, but any pair will return a zero result from
 * {@link #compareTo}.
 * &lt;ul&gt;
 *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.000Z} &lt;em&gt;etc.&lt;/em&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @see #equals(Timestamp)
 * @see #compareTo(Timestamp)
 */
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">public final class Timestamp</span>
    implements Comparable&lt;Timestamp&gt;, Cloneable
{
    private static final boolean APPLY_OFFSET_YES = true;
    private static final boolean APPLY_OFFSET_NO = false;

    private static final int NO_MONTH = 0;
    private static final int NO_DAY = 0;
    private static final int NO_HOURS = 0;
    private static final int NO_MINUTES = 0;
    private static final int NO_SECONDS = 0;
<span class="fc" id="L85">    private static final BigDecimal NO_FRACTIONAL_SECONDS = null;</span>

    // 0001-01-01T00:00:00.0Z in millis
    static final long MINIMUM_TIMESTAMP_IN_MILLIS = -62135769600000L;

    // 0001-01-01T00:00:00.0Z in millis
<span class="fc" id="L91">    static final BigDecimal MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(MINIMUM_TIMESTAMP_IN_MILLIS);</span>

    // 10000T in millis, upper bound exclusive
    static final long MAXIMUM_TIMESTAMP_IN_MILLIS = 253402300800000L;

    // 10000T in millis, upper bound exclusive
<span class="fc" id="L97">    static final BigDecimal MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(MAXIMUM_TIMESTAMP_IN_MILLIS);</span>

    /**
     * Unknown local offset from UTC.
     */
<span class="fc" id="L102">    public static final Integer UNKNOWN_OFFSET = null;</span>

    /**
     * Local offset of zero hours from UTC.
     */
<span class="fc" id="L107">    public static final Integer UTC_OFFSET = Integer.valueOf(0);</span>

    private static final int FLAG_YEAR      = 0x01;
    private static final int FLAG_MONTH     = 0x02;
    private static final int FLAG_DAY       = 0x04;
    private static final int FLAG_MINUTE    = 0x08;
    private static final int FLAG_SECOND    = 0x10;

    /**
     * The precision of the Timestamp.
     */
<span class="fc" id="L118">    public static enum Precision {</span>
<span class="fc" id="L119">        YEAR    (FLAG_YEAR),</span>
<span class="fc" id="L120">        MONTH   (FLAG_YEAR | FLAG_MONTH),</span>
<span class="fc" id="L121">        DAY     (FLAG_YEAR | FLAG_MONTH | FLAG_DAY),</span>
        // HOUR is not a supported precision per https://www.w3.org/TR/NOTE-datetime
<span class="fc" id="L123">        MINUTE  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE),</span>
<span class="fc" id="L124">        SECOND  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE | FLAG_SECOND),</span>

        /**
         * DEPRECATED! Treating the fractional part of seconds separate from
         * the integer part has led to countless bugs. We intend to combine
         * the two under the SECOND precision.
         *
         */
<span class="fc" id="L132">        @Deprecated</span>
        FRACTION(FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE | FLAG_SECOND);

        /** Bit flags for the precision. */
        private final int flags;

        private Precision(int flags)
<span class="fc" id="L139">        {</span>
<span class="fc" id="L140">            this.flags = flags;</span>
<span class="fc" id="L141">        }</span>

        public boolean includes(Precision isIncluded)
        {
<span class="pc bpc" id="L145" title="1 of 6 branches missed.">            switch (isIncluded)</span>
            {
                case FRACTION:
<span class="fc bfc" id="L148" title="All 2 branches covered.">                case SECOND:    return (flags &amp; FLAG_SECOND)   != 0;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                case MINUTE:    return (flags &amp; FLAG_MINUTE)   != 0;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">                case DAY:       return (flags &amp; FLAG_DAY)      != 0;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">                case MONTH:     return (flags &amp; FLAG_MONTH)    != 0;</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">                case YEAR:      return (flags &amp; FLAG_YEAR)     != 0;</span>
                default:        break;
            }
<span class="nc" id="L155">            throw new IllegalStateException(&quot;unrecognized precision&quot; + isIncluded);</span>
        }

        private boolean alwaysUnknownOffset()
        {
<span class="fc bfc" id="L160" title="All 2 branches covered.">            return this.ordinal() &lt;= DAY.ordinal();</span>
        }
    }

<span class="fc" id="L164">    private static final int HASH_SIGNATURE =</span>
<span class="fc" id="L165">        &quot;INTERNAL TIMESTAMP&quot;.hashCode();</span>

    /**
     * The precision of the Timestamp. The fractional seconds component is
     * defined by a BigDecimal.
     * &lt;p&gt;
     * During construction of all Timestamps, they will have a
     * date value (i.e. Year, Month, Day) but with reduced precision they may
     * exclude any time values that are more precise than the precision that is
     * being defined.
     */
    private Precision   _precision;

    // These are the time field values for the Timestamp.
    // _month and _day are 1-based (0 is an invalid value for
    // these in a non-null Timestamp).
    private short       _year;
<span class="fc" id="L182">    private byte        _month = 1; // Initialized to valid default</span>
<span class="fc" id="L183">    private byte        _day   = 1; // Initialized to valid default</span>
    private byte        _hour;
    private byte        _minute;
    private byte        _second;
    private BigDecimal  _fraction;  // fractional seconds, must be within range [0, 1)

    /**
     * Minutes offset from UTC; zero means UTC proper,
     * &lt;code&gt;null&lt;/code&gt; means that the offset is unknown.
     */
    private Integer     _offset;

                                                      //   jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
                                                      // the first 0 is to make these arrays 1 based (since month values are 1-12)
<span class="fc" id="L197">    private static final int[] LEAP_DAYS_IN_MONTH   = { 0,  31,  29,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };</span>
<span class="fc" id="L198">    private static final int[] NORMAL_DAYS_IN_MONTH = { 0,  31,  28,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };</span>

    private static int last_day_in_month(int year, int month) {
        boolean is_leap;
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if ((year % 4) == 0) {</span>
            // divisible by 4 (lower 2 bits are zero) - may be a leap year
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if ((year % 100) == 0) {</span>
                // and divisible by 100 - not a leap year
<span class="fc bfc" id="L206" title="All 2 branches covered.">                if ((year % 400) == 0) {</span>
                    // but divisible by 400 - then it is a leap year
<span class="fc" id="L208">                    is_leap = true;</span>
                }
                else {
<span class="fc" id="L211">                    is_leap = false;</span>
                }
            }
            else {
<span class="fc" id="L215">                is_leap = true;</span>
            }
        }
        else {
<span class="fc" id="L219">            is_leap = false;</span>
        }
<span class="fc bfc" id="L221" title="All 2 branches covered.">        return is_leap ? LEAP_DAYS_IN_MONTH[month] : NORMAL_DAYS_IN_MONTH[month];</span>
    }

    /**
     * Applies the local time zone offset from UTC to the applicable time field
     * values. Depending on the local time zone offset, adjustments
     * (i.e. rollover) will be made to the Year, Day, Hour, Minute time field
     * values.
     *
     * @param offset the local offset, in minutes from UTC.
     */
    private void apply_offset(int offset)
    {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (offset == 0) return;</span>
<span class="pc bpc" id="L235" title="2 of 4 branches missed.">        if (offset &lt; -24*60 || offset &gt; 24*60) {</span>
<span class="nc" id="L236">            throw new IllegalArgumentException(&quot;bad offset &quot; + offset);</span>
        }
        // To convert _to_ UTC you must SUBTRACT the local offset
<span class="fc" id="L239">        offset = -offset;</span>
<span class="fc" id="L240">        int hour_offset = offset / 60;</span>
<span class="fc" id="L241">        int min_offset = offset - (hour_offset * 60);</span>

<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (offset &lt; 0) {</span>
<span class="fc" id="L244">            _minute += min_offset;  // lower the minute value by adding a negative offset</span>
<span class="fc" id="L245">            _hour += hour_offset;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">            if (_minute &lt; 0) {</span>
<span class="fc" id="L247">                _minute += 60;</span>
<span class="fc" id="L248">                _hour -= 1;</span>
            }
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (_hour &gt;= 0) return;  // hour is 0-23</span>
<span class="fc" id="L251">            _hour += 24;</span>
<span class="fc" id="L252">            _day -= 1;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (_day &gt;= 1) return;  // day is 1-31</span>
            // we can't do this until we've figured out the month and year: _day += last_day_in_month(_year, _month);
<span class="fc" id="L255">            _month -= 1;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (_month &gt;= 1) {</span>
<span class="fc" id="L257">                _day += last_day_in_month(_year, _month);  // now we know (when the year doesn't change</span>
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">                assert(_day == last_day_in_month(_year, _month));</span>
<span class="fc" id="L259">                return;  // 1-12</span>
            }
<span class="fc" id="L261">            _month += 12;</span>
<span class="fc" id="L262">            _year -= 1;</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            if (_year &lt; 1) throw new IllegalArgumentException(&quot;year is less than 1&quot;);</span>
<span class="fc" id="L264">            _day += last_day_in_month(_year, _month);  // and now we know, even if the year did change</span>
<span class="pc bpc" id="L265" title="2 of 4 branches missed.">            assert(_day == last_day_in_month(_year, _month));</span>
        }
        else {
<span class="fc" id="L268">            _minute += min_offset;  // lower the minute value by adding a negative offset</span>
<span class="fc" id="L269">            _hour += hour_offset;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (_minute &gt; 59) {</span>
<span class="fc" id="L271">                _minute -= 60;</span>
<span class="fc" id="L272">                _hour += 1;</span>
            }
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (_hour &lt; 24) return;  // hour is 0-23</span>
<span class="fc" id="L275">            _hour -= 24;</span>
<span class="fc" id="L276">            _day += 1;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (_day &lt;= last_day_in_month(_year, _month)) return;  // day is 1-31</span>
            // we can't do this until we figure out the final month and year: _day -= last_day_in_month(_year, _month);
<span class="fc" id="L279">            _day = 1; // this is always the case</span>
<span class="fc" id="L280">            _month += 1;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (_month &lt;= 12) {</span>
<span class="fc" id="L282">                return;  // 1-12</span>
            }
<span class="fc" id="L284">            _month -= 12;</span>
<span class="fc" id="L285">            _year += 1;</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            if (_year &gt; 9999) throw new IllegalArgumentException(&quot;year exceeds 9999&quot;);</span>
        }
<span class="fc" id="L288">    }</span>

    private static byte requireByte(int value, String location) {
<span class="pc bpc" id="L291" title="2 of 4 branches missed.">        if (value &gt; Byte.MAX_VALUE || value &lt; Byte.MIN_VALUE) {</span>
<span class="nc" id="L292">            throw new IllegalArgumentException(String.format(&quot;%s of %d is out of range.&quot;, location, value));</span>
        }
<span class="fc" id="L294">        return (byte) value;</span>
    }

    private static short requireShort(int value, String location) {
<span class="pc bpc" id="L298" title="2 of 4 branches missed.">        if (value &gt; Short.MAX_VALUE || value &lt; Short.MIN_VALUE) {</span>
<span class="nc" id="L299">            throw new IllegalArgumentException(String.format(&quot;%s of %d is out of range.&quot;, location, value));</span>
        }
<span class="fc" id="L301">        return (short) value;</span>
    }

    /**
     * This method uses deprecated methods from {@link java.util.Date}
     * instead of {@link Calendar} so that this code can be used (more easily)
     * on the mobile Java platform (which has Date but does not have Calendar).
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    private void set_fields_from_millis(long millis)
    {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if(millis &lt; MINIMUM_TIMESTAMP_IN_MILLIS){</span>
<span class="nc" id="L313">            throw new IllegalArgumentException(&quot;year is less than 1&quot;);</span>
        }

<span class="fc" id="L316">        Date date = new Date(millis);</span>

        // The Date getters return values in the Date's time zone (i.e. the system time zone).
        // The components need to be converted to UTC before being validated for exact ranges, because the offset
        // conversion can affect which values are considered valid. Simply verify that the values can fit in the
        // destination type here. If they do not, they would be out of range no matter the offset.
<span class="fc" id="L322">        _minute = requireByte(date.getMinutes(), &quot;Minute&quot;);</span>
<span class="fc" id="L323">        _second = requireByte(date.getSeconds(), &quot;Second&quot;);</span>
<span class="fc" id="L324">        _hour = requireByte(date.getHours(), &quot;Hour&quot;);</span>
<span class="fc" id="L325">        _day = requireByte(date.getDate(), &quot;Day&quot;);</span>
<span class="fc" id="L326">        _month = requireByte(date.getMonth() + 1, &quot;Month&quot;);</span>

        // Date does not correctly handle year values that represent year 0 or earlier in the system time zone through
        // getYear(). This case is detected and forced to zero.
<span class="fc" id="L330">        int offset = -date.getTimezoneOffset();</span>
<span class="pc bpc" id="L331" title="3 of 4 branches missed.">        if(offset &lt; 0 &amp;&amp; MINIMUM_TIMESTAMP_IN_MILLIS - offset &gt; millis) {</span>
<span class="nc" id="L332">            _year = 0;</span>
        } else {
<span class="fc" id="L334">            _year = requireShort(date.getYear() + 1900, &quot;Year&quot;);</span>
        }

        // Now apply the offset to convert the components to UTC.
<span class="fc" id="L338">        apply_offset(offset);</span>

        // Now that all components are in UTC, they may be validated for exact ranges.
<span class="fc" id="L341">        this._year    = checkAndCastYear(_year);</span>
<span class="fc" id="L342">        this._month   = checkAndCastMonth(_month);</span>
<span class="fc" id="L343">        this._day     = checkAndCastDay(_day, _year, _month);</span>
<span class="fc" id="L344">        this._hour    = checkAndCastHour(_hour);</span>
<span class="fc" id="L345">        this._minute  = checkAndCastMinute(_minute);</span>
<span class="fc" id="L346">        this._second  = checkAndCastSecond(_second);</span>
<span class="fc" id="L347">    }</span>

    /**
     * Copies data from a {@link Calendar} into this timestamp.
     * Must only be called during construction due to timestamp immutabliity.
     *
     * @param cal must have at least one field set.
     *
     * @throws IllegalArgumentException if the calendar has no fields set.
     */
    private void set_fields_from_calendar(Calendar cal,
                                          Precision precision,
                                          boolean setLocalOffset)
    {
<span class="fc" id="L361">        _precision = precision;</span>
<span class="fc" id="L362">        _offset = UNKNOWN_OFFSET;</span>
<span class="fc" id="L363">        boolean dayPrecision = false;</span>
<span class="fc" id="L364">        boolean calendarHasMilliseconds = cal.isSet(Calendar.MILLISECOND);</span>

<span class="pc bpc" id="L366" title="1 of 6 branches missed.">        switch (this._precision) {</span>
            case FRACTION:
            case SECOND:
<span class="fc" id="L369">                this._second = checkAndCastSecond(cal.get(Calendar.SECOND));</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">                if (calendarHasMilliseconds) {</span>
<span class="fc" id="L371">                    BigDecimal millis = BigDecimal.valueOf(cal.get(Calendar.MILLISECOND));</span>
<span class="fc" id="L372">                    this._fraction = millis.movePointLeft(3); // convert to fraction</span>
<span class="fc" id="L373">                    checkFraction(precision, this._fraction);</span>
                }
            case MINUTE:
            {
<span class="fc" id="L377">                this._hour   = checkAndCastHour(cal.get(Calendar.HOUR_OF_DAY));</span>
<span class="fc" id="L378">                this._minute = checkAndCastMinute(cal.get(Calendar.MINUTE));</span>

                // If this test is made before calling get(), it will return
                // false even when Calendar.setTimeZone() was called.
<span class="pc bpc" id="L382" title="1 of 4 branches missed.">                if (setLocalOffset &amp;&amp; cal.isSet(Calendar.ZONE_OFFSET))</span>
                {
<span class="fc" id="L384">                    int offset = cal.get(Calendar.ZONE_OFFSET);</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">                    if (cal.isSet(Calendar.DST_OFFSET)) {</span>
<span class="fc" id="L386">                        offset += cal.get(Calendar.DST_OFFSET);</span>
                    }

                    // convert ms to minutes
<span class="fc" id="L390">                    _offset = offset / (1000*60);</span>
                }
            }
            case DAY:
<span class="fc" id="L394">                dayPrecision = true;</span>
            case MONTH:
                // Calendar months are 0 based, Timestamp months are 1 based
<span class="fc" id="L397">                this._month  = checkAndCastMonth((cal.get(Calendar.MONTH) + 1));</span>
            case YEAR:
                int year;
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if(cal.get(Calendar.ERA) == GregorianCalendar.AD) {</span>
<span class="fc" id="L401">                    year = cal.get(Calendar.YEAR);</span>
                }
                else {
<span class="fc" id="L404">                    year = -cal.get(Calendar.YEAR);</span>
                }

<span class="fc" id="L407">                this._year = checkAndCastYear(year);</span>
        }

<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (dayPrecision)</span>
        {
<span class="fc" id="L412">            this._day = checkAndCastDay(cal.get(Calendar.DAY_OF_MONTH), _year, _month);</span>
        }

<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (_offset != UNKNOWN_OFFSET) {</span>
            // Transform our members from local time to Zulu
<span class="fc" id="L417">            this.apply_offset(_offset);</span>
        }
<span class="fc" id="L419">    }</span>

    /**
     * Creates a new Timestamp, precise to the year, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    private Timestamp(int zyear)
    {
<span class="fc" id="L428">        this(Precision.YEAR, zyear, NO_MONTH, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L429">    }</span>

    /**
     * Creates a new Timestamp, precise to the month, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    private Timestamp(int zyear, int zmonth)
    {
<span class="fc" id="L438">        this(Precision.MONTH, zyear, zmonth, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L439">    }</span>

    /**
     * Creates a new Timestamp, precise to the day, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     *
     * @deprecated Use {@link #forDay(int, int, int)} instead.
     */
    @Deprecated
    public Timestamp(int zyear, int zmonth, int zday)
    {
<span class="fc" id="L451">        this(Precision.DAY, zyear, zmonth, zday, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L452">    }</span>


    /**
     * Creates a new Timestamp, precise to the minute, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @deprecated Use {@link #forMinute(int, int, int, int, int, Integer)} instead.
     */
    @Deprecated
    public Timestamp(int year, int month, int day,
                     int hour, int minute,
                     Integer offset)
    {
<span class="fc" id="L474">        this(Precision.MINUTE, year, month, day, hour, minute, NO_SECONDS, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L475">    }</span>

    /**
     * Creates a new Timestamp, precise to the second, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     * @deprecated Use {@link #forSecond(int, int, int, int, int, int, Integer)} instead.
     */
    @Deprecated
    public Timestamp(int year, int month, int day,
                     int hour, int minute, int second,
                     Integer offset)
    {
<span class="fc" id="L496">        this(Precision.SECOND, year, month, day, hour, minute, second, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L497">    }</span>

    /**
     * Creates a new Timestamp, precise to the second or fractional second,
     * with a given local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss.fff+-oo:oo}, where {@code oo:oo} represents
     * the hour and minutes of the local offset from UTC, and {@code fff}
     * represents the fractional seconds.
     *
     * @param frac
     *          the fractional seconds; must not be {@code null}; if negative,
     *          its absolute value is used
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code frac} is {@code null}
     *
     * @deprecated Use {@link #forSecond(int, int, int, int, int, BigDecimal, Integer)}
     * instead.
     */
    @Deprecated
    public Timestamp(int year, int month, int day,
                     int hour, int minute, int second, BigDecimal frac,
                     Integer offset)
    {
<span class="fc" id="L525">        this(Precision.SECOND, year, month, day, hour, minute, second, frac, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L526">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     *
     * @param frac must be &gt;= 0 and &lt; 1
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @see #createFromUtcFields(Precision, int, int, int, int, int, int, BigDecimal, Integer)
     */
    private Timestamp(Precision p, int zyear, int zmonth, int zday,
                      int zhour, int zminute, int zsecond, BigDecimal frac,
                      Integer offset, boolean shouldApplyOffset)
<span class="fc" id="L549">    {</span>
<span class="fc" id="L550">        boolean dayPrecision = false;</span>

<span class="pc bpc" id="L552" title="1 of 6 branches missed.">        switch (p) {</span>
        default:
<span class="nc" id="L554">            throw new IllegalArgumentException(&quot;invalid Precision passed to constructor&quot;);</span>
        case FRACTION:
        case SECOND:
<span class="fc bfc" id="L557" title="All 4 branches covered.">            if (frac == null || frac.equals(BigDecimal.ZERO))</span>
            {
<span class="fc" id="L559">                _fraction = null;</span>
            }
            else
            {
<span class="fc" id="L563">                _fraction = frac.abs();</span>
            }
<span class="fc" id="L565">            _second = checkAndCastSecond(zsecond);</span>
        case MINUTE:
<span class="fc" id="L567">            _minute = checkAndCastMinute(zminute);</span>
<span class="fc" id="L568">            _hour   = checkAndCastHour(zhour);</span>
<span class="fc" id="L569">            _offset = offset;      // offset must be null for years/months/days</span>
        case DAY:
<span class="fc" id="L571">             dayPrecision = true;</span>
        case MONTH:
<span class="fc" id="L573">            _month  = checkAndCastMonth(zmonth);</span>
        case YEAR:
<span class="fc" id="L575">            _year   = checkAndCastYear(zyear);</span>
        }

<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (dayPrecision)</span>
        {
<span class="fc" id="L580">            _day    = checkAndCastDay(zday, zyear, zmonth);</span>
        }

<span class="fc" id="L583">        _precision = checkFraction(p, _fraction);</span>

<span class="fc bfc" id="L585" title="All 4 branches covered.">        if (shouldApplyOffset &amp;&amp; offset != null) {</span>
<span class="fc" id="L586">            apply_offset(offset);</span>
        }
<span class="fc" id="L588">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * As such, if the given {@code offset} is non-null or zero, the resulting
     * Timestamp will have time values that &lt;em&gt;DO NOT&lt;/em&gt; match the time
     * parameters. This method also has a behavior of precision &quot;narrowing&quot;,
     * detailed in the sub-section below.
     *
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values (in its local time) respectively:
     *&lt;pre&gt;
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;null&lt;/b&gt;)    will return 2012-02-03T04:05:06.007-00:00 (match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;0&lt;/b&gt;)       will return 2012-02-03T04:05:06.007+00:00 (match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;480&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;12&lt;/b&gt;:05:06.007&lt;b&gt;+08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-480&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;20&lt;/b&gt;:05:06.007&lt;b&gt;-08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;720&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;+12:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-720&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;-12:00&lt;/b&gt; (do not match)
     *&lt;/pre&gt;
     * Note: All of these resulting Timestamps have the similar value (in UTC) 2012-02-03T04:05:06.007Z.
     *
     * &lt;h3&gt;Precision &quot;Narrowing&quot;&lt;/h3&gt;
     *
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values respectively:
     *&lt;pre&gt;
     * createFromUtcFields(&lt;b&gt;Precision.YEAR&lt;/b&gt;    , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012T
     * createFromUtcFields(&lt;b&gt;Precision.MONTH&lt;/b&gt;   , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02T
     * createFromUtcFields(&lt;b&gt;Precision.DAY&lt;/b&gt;     , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T
     * createFromUtcFields(&lt;b&gt;Precision.MINUTE&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05Z
     * createFromUtcFields(&lt;b&gt;Precision.SECOND&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6,  null, 0)    will return 2012-02-03T04:05:06Z
     * createFromUtcFields(&lt;b&gt;Precision.SECOND&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05:06.007Z
     *&lt;/pre&gt;
     *
     * @param p the desired timestamp precision. The result may have a
     * different precision if the input data isn't precise enough.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     */
    @Deprecated
    public static Timestamp
    createFromUtcFields(Precision p, int zyear, int zmonth, int zday,
                        int zhour, int zminute, int zsecond, BigDecimal frac,
                        Integer offset)
    {
<span class="fc" id="L644">        return new Timestamp(p, zyear, zmonth, zday,</span>
                             zhour, zminute, zsecond, frac,
                             offset, APPLY_OFFSET_NO);
    }

    /**
     * Creates a new Timestamp from a {@link Calendar}, preserving the
     * {@link Calendar}'s precision and local offset from UTC.
     * &lt;p&gt;
     * The most precise calendar field of {@code cal} will be used to determine
     * the precision of the resulting Timestamp.
     *
     * For example, the calendar field will have a Timestamp precision accordingly:
     * &lt;ul&gt;
     *   &lt;li&gt;{@link Calendar#YEAR} - year precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MONTH} - month precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#DAY_OF_MONTH} - day precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#HOUR_OF_DAY} or {@link Calendar#MINUTE} - minute precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#SECOND} - second precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MILLISECOND} - fractional second precision&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @throws IllegalArgumentException
     *          if {@code cal} has no appropriate calendar fields set.
     *
     * @deprecated Use {@link #forCalendar(Calendar)} instead.
     */
    @Deprecated
    public Timestamp(Calendar cal)
<span class="fc" id="L673">    {</span>
        Precision precision;

<span class="fc bfc" id="L676" title="All 4 branches covered.">        if (cal.isSet(Calendar.MILLISECOND) || cal.isSet(Calendar.SECOND)) {</span>
<span class="fc" id="L677">            precision = Precision.SECOND;</span>
        }
<span class="pc bpc" id="L679" title="1 of 4 branches missed.">        else if (cal.isSet(Calendar.HOUR_OF_DAY) || cal.isSet(Calendar.MINUTE)) {</span>
<span class="fc" id="L680">            precision = Precision.MINUTE;</span>
        }
<span class="fc bfc" id="L682" title="All 2 branches covered.">        else if (cal.isSet(Calendar.DAY_OF_MONTH)) {</span>
<span class="fc" id="L683">            precision = Precision.DAY;</span>
        }
<span class="fc bfc" id="L685" title="All 2 branches covered.">        else if (cal.isSet(Calendar.MONTH)) {</span>
<span class="fc" id="L686">            precision = Precision.MONTH;</span>
        }
<span class="fc bfc" id="L688" title="All 2 branches covered.">        else if (cal.isSet(Calendar.YEAR)) {</span>
<span class="fc" id="L689">            precision = Precision.YEAR;</span>
        }
        else {
<span class="fc" id="L692">            throw new IllegalArgumentException(&quot;Calendar has no fields set&quot;);</span>
        }

<span class="fc" id="L695">        set_fields_from_calendar(cal, precision, true);</span>
<span class="fc" id="L696">    }</span>


    private Timestamp(Calendar cal, Precision precision, BigDecimal fraction,
                      Integer offset)
<span class="fc" id="L701">    {</span>
<span class="fc" id="L702">        set_fields_from_calendar(cal, precision, false);</span>
<span class="fc" id="L703">        _fraction = fraction;</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (offset != null)</span>
        {
<span class="fc" id="L706">            _offset = offset;</span>
<span class="fc" id="L707">            apply_offset(offset);</span>
        }
<span class="fc" id="L709">    }</span>


    private Timestamp(BigDecimal millis, Precision precision, Integer localOffset)
<span class="fc" id="L713">    {</span>
        // check bounds to avoid hanging when calling longValue() on decimals with large positive exponents,
        // e.g. 1e10000000
<span class="fc bfc" id="L716" title="All 2 branches covered.">        if(millis.compareTo(MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL) &lt; 0 ||</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">                MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL.compareTo(millis) &lt;= 0) {</span>
<span class="nc" id="L718">            throwTimestampOutOfRangeError(millis);</span>
        }
        // quick handle integral zero
<span class="fc bfc" id="L721" title="All 2 branches covered.">        long ms = isIntegralZero(millis) ? 0 : millis.longValue();</span>
<span class="fc" id="L722">        set_fields_from_millis(ms);</span>

<span class="fc bfc" id="L724" title="All 5 branches covered.">        switch (precision)</span>
        {
            case YEAR:
<span class="fc" id="L727">                _month  = 1;</span>
            case MONTH:
<span class="fc" id="L729">                _day    = 1;</span>
            case DAY:
<span class="fc" id="L731">                _hour   = 0;</span>
<span class="fc" id="L732">                _minute = 0;</span>
            case MINUTE:
<span class="fc" id="L734">                _second = 0;</span>
            case SECOND:
            case FRACTION:
        }

<span class="fc" id="L739">        _offset = localOffset;</span>
        // The given BigDecimal may contain greater than milliseconds precision, which is the maximum precision that
        // a Calendar can handle. Set the _fraction here so that extra precision (if any) is not lost.
        // However, don't set the fraction if the given BigDecimal does not have precision at least to the tenth of
        // a second.
<span class="pc bpc" id="L744" title="1 of 4 branches missed.">        if ((precision.includes(Precision.SECOND)) &amp;&amp; millis.scale() &gt; -3) {</span>
<span class="fc" id="L745">            BigDecimal secs = millis.movePointLeft(3);</span>
<span class="fc" id="L746">            BigDecimal secsDown = fastRoundZeroFloor(secs);</span>
<span class="fc" id="L747">            _fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L748">        } else {</span>
<span class="fc" id="L749">            _fraction = null;</span>
        }
<span class="fc" id="L751">        _precision = checkFraction(precision, _fraction);</span>
<span class="fc" id="L752">    }</span>


    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds (including any fractional
     * milliseconds) from the epoch, with a given local offset.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the second if {@code millis}
     * doesn't contain information that is more granular than seconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;132541995e4 (132541995 &amp;times; 10&lt;sup&gt;4&lt;/sup&gt;)&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30Z},
     * precise to the second.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second if
     * {@code millis} contains information that is at least granular to
     * milliseconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;1325419950555&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30.555Z},
     * precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     *
     * @deprecated Use {@link #forMillis(BigDecimal, Integer)} instead.
     */
    @Deprecated
    public Timestamp(BigDecimal millis, Integer localOffset)
<span class="fc" id="L791">    {</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">        if (millis == null) throw new NullPointerException(&quot;millis is null&quot;);</span>

        // check bounds to avoid hanging when calling longValue() on decimals with large positive exponents,
        // e.g. 1e10000000
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if(millis.compareTo(MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL) &lt; 0 ||</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">            MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL.compareTo(millis) &lt; 0) {</span>
<span class="nc" id="L798">            throwTimestampOutOfRangeError(millis);</span>
        }

        // quick handle integral zero
<span class="fc bfc" id="L802" title="All 2 branches covered.">        long ms = isIntegralZero(millis) ? 0 : millis.longValue();</span>

<span class="fc" id="L804">        set_fields_from_millis(ms);</span>

<span class="fc" id="L806">        int scale = millis.scale();</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">        if (scale &lt;= -3) {</span>
<span class="fc" id="L808">            this._precision = Precision.SECOND;</span>
<span class="fc" id="L809">            this._fraction = null;</span>
        }
        else {
<span class="fc" id="L812">            BigDecimal secs = millis.movePointLeft(3);</span>
<span class="fc" id="L813">            BigDecimal secsDown = fastRoundZeroFloor(secs);</span>
<span class="fc" id="L814">            this._fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L815">            this._precision = checkFraction(Precision.SECOND, _fraction);</span>
        }
<span class="fc" id="L817">        this._offset = localOffset;</span>
<span class="fc" id="L818">    }</span>

    private BigDecimal fastRoundZeroFloor(final BigDecimal decimal) {
<span class="fc bfc" id="L821" title="All 2 branches covered.">        BigDecimal fastValue = decimal.signum() &lt; 0 ? BigDecimal.ONE.negate() : BigDecimal.ZERO;</span>

<span class="fc bfc" id="L823" title="All 2 branches covered.">        return isIntegralZero(decimal) ? fastValue : decimal.setScale(0, RoundingMode.FLOOR);</span>
    }

    private boolean isIntegralZero(final BigDecimal decimal) {
        // zero || no low-order bits || &lt; 1.0
<span class="fc bfc" id="L828" title="All 2 branches covered.">        return  decimal.signum() == 0</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">            || decimal.scale() &lt; -63</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">            || (decimal.precision() - decimal.scale() &lt;= 0);</span>
    }

    private static void throwTimestampOutOfRangeError(Number millis) {
<span class="fc" id="L834">        throw new IllegalArgumentException(&quot;millis: &quot; + millis + &quot; is outside of valid the range: from &quot;</span>
                + MINIMUM_TIMESTAMP_IN_MILLIS
                + &quot; (0001T)&quot;
                + &quot;, inclusive, to &quot;
                + MAXIMUM_TIMESTAMP_IN_MILLIS
                + &quot; (10000T)&quot;
                + &quot; , exclusive&quot;);
    }

    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds from the epoch, with a given local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds from the epoch (1970-01-01T00:00:00.000Z)
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     * @deprecated Use {@link #forMillis(long, Integer)} instead.
     */
    @Deprecated
    public Timestamp(long millis, Integer localOffset)
<span class="fc" id="L859">    {</span>
<span class="fc bfc" id="L860" title="All 4 branches covered.">        if(millis &lt; MINIMUM_TIMESTAMP_IN_MILLIS || millis &gt;= MAXIMUM_TIMESTAMP_IN_MILLIS) {</span>
<span class="nc" id="L861">            throwTimestampOutOfRangeError(millis);</span>
        }
<span class="fc" id="L863">        this.set_fields_from_millis(millis);</span>

        // fractional seconds portion
<span class="fc" id="L866">        BigDecimal secs = BigDecimal.valueOf(millis).movePointLeft(3);</span>
<span class="fc" id="L867">        BigDecimal secsDown = secs.setScale(0, RoundingMode.FLOOR);</span>
<span class="fc" id="L868">        this._fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L869">        this._precision = checkFraction(Precision.SECOND, _fraction);</span>

<span class="fc" id="L871">        this._offset = localOffset;</span>
<span class="fc" id="L872">    }</span>


    private static IllegalArgumentException fail(CharSequence input, String reason)
    {
<span class="fc" id="L877">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L878">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + reason</span>
                                            + &quot;: &quot; + input);
    }

    private static IllegalArgumentException fail(CharSequence input)
    {
<span class="fc" id="L884">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L885">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + input);</span>
    }

    static final String NULL_TIMESTAMP_IMAGE = &quot;null.timestamp&quot;;
<span class="fc" id="L889">    static final int    LEN_OF_NULL_IMAGE    = NULL_TIMESTAMP_IMAGE.length();</span>
    static final int    END_OF_YEAR          =  4;  // 1234T
    static final int    END_OF_MONTH         =  7;  // 1234-67T
    static final int    END_OF_DAY           = 10;  // 1234-67-90T
    static final int    END_OF_MINUTES       = 16;
    static final int    END_OF_SECONDS       = 19;


    /**
     * Returns a new Timestamp that represents the point in time, precision
     * and local offset defined in Ion format by the {@link CharSequence}.
     *
     * @param ionFormattedTimestamp
     *          a sequence of characters that is the Ion representation of a
     *          Timestamp
     *
     * @throws IllegalArgumentException
     *          if the {@code CharSequence} is an invalid Ion representation
     *          of a Timestamp;
     *          or if the {@code CharSequence} has excess characters which
     *          are not one of the following valid thirteen numeric-stop
     *          characters (escaped accordingly for readability):
     *          &lt;code&gt;{}[](),\&quot;\'\ \t\n\r}&lt;/code&gt;
     *
     * @return
     *          {@code null} if the {@code CharSequence} is &quot;null.timestamp&quot;
     *
     * @see &lt;a href=&quot;http://amzn.github.io/ion-docs/docs/spec.html#timestamp&quot;&gt;Ion Timestamp Page&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;W3C Note on Date and Time Formats&lt;/a&gt;
     */
    public static Timestamp valueOf(CharSequence ionFormattedTimestamp)
    {
<span class="fc" id="L921">        final CharSequence in = ionFormattedTimestamp;</span>
        int pos;

<span class="fc" id="L924">        final int length = in.length();</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">        if (length == 0)</span>
        {
<span class="nc" id="L927">            throw fail(in);</span>
        }

        // check for 'null.timestamp'
<span class="fc bfc" id="L931" title="All 2 branches covered.">        if (in.charAt(0) == 'n') {</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">            if (length &gt;= LEN_OF_NULL_IMAGE</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">                &amp;&amp; NULL_TIMESTAMP_IMAGE.contentEquals(in.subSequence(0, LEN_OF_NULL_IMAGE)))</span>
            {
<span class="fc bfc" id="L935" title="All 2 branches covered.">                if (length &gt; LEN_OF_NULL_IMAGE) {</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">                    if (!isValidFollowChar(in.charAt(LEN_OF_NULL_IMAGE))) {</span>
<span class="fc" id="L937">                        throw fail(in);</span>
                    }
                }
<span class="fc" id="L940">                return null;</span>
            }
<span class="fc" id="L942">            throw fail(in);</span>
        }

<span class="fc" id="L945">        int year  = 1;</span>
<span class="fc" id="L946">        int month = 1;</span>
<span class="fc" id="L947">        int day   = 1;</span>
<span class="fc" id="L948">        int hour  = 0;</span>
<span class="fc" id="L949">        int minute = 0;</span>
<span class="fc" id="L950">        int seconds = 0;</span>
<span class="fc" id="L951">        BigDecimal fraction = null;</span>
        Precision precision;

        // fake label to turn goto's into a break so Java is happy :) enjoy
        do {
            // otherwise we expect yyyy-mm-ddThh:mm:ss.ssss+hh:mm
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">            if (length &lt; END_OF_YEAR + 1) {  // +1 for the &quot;T&quot;</span>
<span class="nc" id="L958">                throw fail(in, &quot;year is too short (must be at least yyyyT)&quot;);</span>
            }
<span class="fc" id="L960">            pos = END_OF_YEAR;</span>
<span class="fc" id="L961">            precision = Precision.YEAR;</span>
<span class="fc" id="L962">            year  = read_digits(in, 0, 4, -1, &quot;year&quot;);</span>

<span class="fc" id="L964">            char c = in.charAt(END_OF_YEAR);</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L967">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between year and month, found &quot;
<span class="fc" id="L969">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L971" title="All 2 branches covered.">            if (length &lt; END_OF_MONTH + 1) {  // +1 for the &quot;T&quot;</span>
<span class="fc" id="L972">                throw fail(in, &quot;month is too short (must be yyyy-mmT)&quot;);</span>
            }
<span class="fc" id="L974">            pos = END_OF_MONTH;</span>
<span class="fc" id="L975">            precision = Precision.MONTH;</span>
<span class="fc" id="L976">            month = read_digits(in, END_OF_YEAR + 1, 2, -1,  &quot;month&quot;);</span>

<span class="fc" id="L978">            c = in.charAt(END_OF_MONTH);</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L981">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between month and day, found &quot;
<span class="fc" id="L983">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L985" title="All 2 branches covered.">            if (length &lt; END_OF_DAY) {</span>
<span class="fc" id="L986">                throw fail(in, &quot;too short for yyyy-mm-dd&quot;);</span>
            }
<span class="fc" id="L988">            pos = END_OF_DAY;</span>
<span class="fc" id="L989">            precision = Precision.DAY;</span>
<span class="fc" id="L990">            day   = read_digits(in, END_OF_MONTH + 1, 2, -1, &quot;day&quot;);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">            if (length == END_OF_DAY) break;</span>
<span class="fc" id="L992">            c = in.charAt(END_OF_DAY);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">            if (c != 'T') {</span>
<span class="fc" id="L994">                throw fail(in,</span>
                           &quot;expected \&quot;T\&quot; after day, found &quot;
<span class="fc" id="L996">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L998" title="All 2 branches covered.">            if (length == END_OF_DAY + 1) break;</span>

            // now lets see if we have a time value
<span class="fc bfc" id="L1001" title="All 2 branches covered.">            if (length &lt; END_OF_MINUTES) {</span>
<span class="fc" id="L1002">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm&quot;);</span>
            }
<span class="fc" id="L1004">            hour   = read_digits(in, 11, 2, ':', &quot;hour&quot;);</span>
<span class="fc" id="L1005">            minute = read_digits(in, 14, 2, -1, &quot;minutes&quot;);</span>
<span class="fc" id="L1006">            pos = END_OF_MINUTES;</span>
<span class="fc" id="L1007">            precision = Precision.MINUTE;</span>

            // we may have seconds
<span class="fc bfc" id="L1010" title="All 4 branches covered.">            if (length &lt;= END_OF_MINUTES || in.charAt(END_OF_MINUTES) != ':')</span>
            {
<span class="fc" id="L1012">                break;</span>
            }
<span class="fc bfc" id="L1014" title="All 2 branches covered.">            if (length &lt; END_OF_SECONDS) {</span>
<span class="fc" id="L1015">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm:ss&quot;);</span>
            }
<span class="fc" id="L1017">            seconds = read_digits(in, 17, 2, -1, &quot;seconds&quot;);</span>
<span class="fc" id="L1018">            pos = END_OF_SECONDS;</span>
<span class="fc" id="L1019">            precision = Precision.SECOND;</span>

<span class="fc bfc" id="L1021" title="All 4 branches covered.">            if (length &lt;= END_OF_SECONDS || in.charAt(END_OF_SECONDS) != '.')</span>
            {
<span class="fc" id="L1023">                break;</span>
            }
<span class="fc" id="L1025">            pos = END_OF_SECONDS + 1;</span>
<span class="fc bfc" id="L1026" title="All 4 branches covered.">            while (length &gt; pos &amp;&amp; Character.isDigit(in.charAt(pos))) {</span>
<span class="fc" id="L1027">                pos++;</span>
            }
<span class="fc bfc" id="L1029" title="All 2 branches covered.">            if (pos &lt;= END_OF_SECONDS + 1) {</span>
<span class="fc" id="L1030">                throw fail(in,</span>
                           &quot;must have at least one digit after decimal point&quot;);
            }
<span class="fc" id="L1033">            fraction = new BigDecimal(in.subSequence(19, pos).toString());</span>
        } while (false);

        Integer offset;

        // now see if they included a timezone offset
<span class="fc bfc" id="L1039" title="All 2 branches covered.">        char timezone_start = pos &lt; length ? in.charAt(pos) : '\n';</span>
<span class="fc bfc" id="L1040" title="All 2 branches covered.">        if (timezone_start == 'Z') {</span>
<span class="fc" id="L1041">            offset = 0;</span>
<span class="fc" id="L1042">            pos++;</span>
        }
<span class="fc bfc" id="L1044" title="All 4 branches covered.">        else if (timezone_start == '+' || timezone_start == '-')</span>
        {
<span class="fc bfc" id="L1046" title="All 2 branches covered.">            if (length &lt; pos + 5) {</span>
<span class="fc" id="L1047">                throw fail(in, &quot;local offset too short&quot;);</span>
            }
            // +/- hh:mm
<span class="fc" id="L1050">            pos++;</span>
<span class="fc" id="L1051">            int tzdHours = read_digits(in, pos, 2, ':', &quot;local offset hours&quot;);</span>
<span class="pc bpc" id="L1052" title="1 of 4 branches missed.">            if (tzdHours &lt; 0 || tzdHours &gt; 23) {</span>
<span class="fc" id="L1053">                throw fail(in,</span>
                           &quot;local offset hours must be between 0 and 23 inclusive&quot;);
            }
<span class="fc" id="L1056">            pos += 3;</span>

<span class="fc" id="L1058">            int tzdMinutes = read_digits(in, pos, 2, -1, &quot;local offset minutes&quot;);</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">            if (tzdMinutes &gt; 59) {</span>
<span class="fc" id="L1060">                throw fail(in,</span>
                           &quot;local offset minutes must be between 0 and 59 inclusive&quot;);
            }
<span class="fc" id="L1063">            pos += 2;</span>

<span class="fc" id="L1065">            int temp = tzdHours * 60 + tzdMinutes;</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">            if (timezone_start == '-') {</span>
<span class="fc" id="L1067">                temp = -temp;</span>
            }
<span class="fc bfc" id="L1069" title="All 4 branches covered.">            if (temp == 0 &amp;&amp; timezone_start == '-') {</span>
                // int doesn't do negative zero very elegantly
<span class="fc" id="L1071">                offset = null;</span>
            }
            else {
<span class="fc" id="L1074">                offset = temp;</span>
            }
<span class="fc" id="L1076">        }</span>
        else {
<span class="fc bfc" id="L1078" title="All 2 branches covered.">            switch (precision) {</span>
                case YEAR:
                case MONTH:
                case DAY:
<span class="fc" id="L1082">                    break;</span>
                default:
<span class="fc" id="L1084">                    throw fail(in, &quot;missing local offset&quot;);</span>
            }
<span class="fc" id="L1086">            offset = null;</span>
        }
<span class="pc bpc" id="L1088" title="1 of 4 branches missed.">        if (length &gt; (pos + 1) &amp;&amp; !isValidFollowChar(in.charAt(pos + 1)))</span>
        {
<span class="fc" id="L1090">            throw fail(in, &quot;invalid excess characters&quot;);</span>
        }

<span class="fc" id="L1093">        Timestamp ts =</span>
            new Timestamp(precision, year, month, day,
                          hour, minute, seconds, fraction, offset, APPLY_OFFSET_YES);
<span class="fc" id="L1096">        return ts;</span>
    }

    private static int read_digits(CharSequence in, int start, int length,
                                   int terminator, String field)
    {
<span class="fc" id="L1102">        int ii, value = 0;</span>
<span class="fc" id="L1103">        int end = start + length;</span>

<span class="fc bfc" id="L1105" title="All 2 branches covered.">        if (in.length() &lt; end) {</span>
<span class="fc" id="L1106">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits&quot;);
        }

<span class="fc bfc" id="L1110" title="All 2 branches covered.">        for (ii=start; ii&lt;end; ii++) {</span>
<span class="fc" id="L1111">            char c = in.charAt(ii);</span>
<span class="fc bfc" id="L1112" title="All 2 branches covered.">            if (!Character.isDigit(c)) {</span>
                // FIXME this will give incorrect message if c is a surrogate
<span class="fc" id="L1114">                throw fail(in,</span>
                           field + &quot; has non-digit character &quot;
<span class="fc" id="L1116">                               + printCodePointAsString(c));</span>
            }
<span class="fc" id="L1118">            value *= 10;</span>
<span class="fc" id="L1119">            value += c - '0';</span>
        }

        // Check the terminator if requested.
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (terminator != -1) {</span>
<span class="pc bpc" id="L1124" title="1 of 4 branches missed.">            if (ii &gt;= in.length() || in.charAt(ii) != terminator) {</span>
<span class="fc" id="L1125">                throw fail(in,</span>
                           field + &quot; should end with &quot;
<span class="fc" id="L1127">                               + printCodePointAsString(terminator));</span>
            }
        }
        // Otherwise make sure we don't have too many digits.
<span class="fc bfc" id="L1131" title="All 4 branches covered.">        else if (ii &lt; in.length() &amp;&amp; Character.isDigit(in.charAt(ii))) {</span>
<span class="fc" id="L1132">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits but has more&quot;);
        }

<span class="fc" id="L1136">        return value;</span>
    }

    private static boolean isValidFollowChar(char c) {
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">        switch (c) {</span>
        default:
<span class="fc" id="L1142">            return false;</span>
        case '{':
        case '}':
        case '[':
        case ']':
        case '(':
        case ')':
        case ',':
        case '\&quot;':
        case '\'':
        case '\\':
        case '\t':
        case '\n':
        case '\r':
<span class="nc" id="L1156">            return true;</span>
        }
    }

    /**
     * Creates a copy of this Timestamp. The resulting Timestamp will
     * represent the same point in time and has the same precision and local
     * offset.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public Timestamp clone()
    {
        // The Copy-Constructor we're using here already expects the time field
        // values to be in UTC, and that is already what we have for this
        // Timestamp -- no adjustment necessary to make it local time.
<span class="fc" id="L1173">        return new Timestamp(_precision,</span>
                             _year,
                             _month,
                             _day,
                             _hour,
                             _minute,
                             _second,
                             _fraction,
                             _offset,
                             APPLY_OFFSET_NO);
    }

    /**
     * Applies the local offset from UTC to each of the applicable time field
     * values and returns the new Timestamp. In short, this makes the Timestamp
     * represent local time.
     *
     * @return a new Timestamp in its local time
     */
    private Timestamp make_localtime()
    {
<span class="fc bfc" id="L1194" title="All 2 branches covered.">        int offset = _offset != null</span>
<span class="fc" id="L1195">            ? _offset.intValue()</span>
<span class="fc" id="L1196">            : 0;</span>

        // We use a Copy-Constructor that expects the time parameters to be in
        // UTC, as that's what we're supposed to have.
        // As this Copy-Constructor doesn't apply local offset to the time
        // field values (it assumes that the local offset is already applied to
        // them), we explicitly apply the local offset to the time field values
        // after we obtain the new Timestamp instance.
<span class="fc" id="L1204">        Timestamp localtime = new Timestamp(_precision,</span>
                                            _year,
                                            _month,
                                            _day,
                                            _hour,
                                            _minute,
                                            _second,
                                            _fraction,
                                            _offset,
                                            APPLY_OFFSET_NO);
        // explicitly apply the local offset to the time field values
<span class="fc" id="L1215">        localtime.apply_offset(-offset);</span>

<span class="pc bpc" id="L1217" title="2 of 4 branches missed.">        assert localtime._offset == _offset;</span>

<span class="fc" id="L1219">        return localtime;</span>
    }

    /**
     * Returns a Timestamp, precise to the year, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    public static Timestamp forYear(int yearZ)
    {
<span class="fc" id="L1229">        return new Timestamp(yearZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the month, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    public static Timestamp forMonth(int yearZ, int monthZ)
    {
<span class="fc" id="L1239">        return new Timestamp(yearZ, monthZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the day, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     *
     */
    public static Timestamp forDay(int yearZ, int monthZ, int dayZ)
    {
<span class="fc" id="L1250">        return new Timestamp(yearZ, monthZ, dayZ);</span>
    }


    /**
     * Returns a Timestamp, precise to the minute, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *

     */
    public static Timestamp forMinute(int year, int month, int day,
                                      int hour, int minute,
                                      Integer offset)
    {
<span class="nc" id="L1272">        return new Timestamp(year, month, day, hour, minute, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *

     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, int second,
                                      Integer offset)
    {
<span class="fc" id="L1293">        return new Timestamp(year, month, day, hour, minute, second, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss.sss+-oo:oo}, where {@code oo:oo} represents
     * the hour and minutes of the local offset from UTC.
     *
     * @param second must be at least zero and less than 60.
     * Must not be null.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *

     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, BigDecimal second,
                                      Integer offset)
    {
        // Tease apart the whole and fractional seconds.
        // Storing them separately is silly.
<span class="fc" id="L1319">        int s = second.intValue();</span>
<span class="fc" id="L1320">        BigDecimal frac = second.subtract(BigDecimal.valueOf(s));</span>
<span class="fc" id="L1321">        return new Timestamp(Precision.SECOND, year, month, day, hour, minute, s, frac, offset, APPLY_OFFSET_YES);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is
     * {@code millis} milliseconds from the epoch, with a given local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @param millis
     * the number of milliseconds from the epoch (1970-01-01T00:00:00.000Z).
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *

     */
    public static Timestamp forMillis(long millis, Integer localOffset)
    {
<span class="fc" id="L1341">        return new Timestamp(millis, localOffset);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is
     * {@code millis} milliseconds (including any fractional
     * milliseconds) from the epoch, with a given local offset.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the second if {@code millis}
     * doesn't contain information that is more granular than seconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;132541995e4 (132541995 &amp;times; 10&lt;sup&gt;4&lt;/sup&gt;)&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30Z},
     * precise to the second.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second if
     * {@code millis} contains information that is at least granular to
     * milliseconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;1325419950555&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30.555Z},
     * precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     *

     */
    public static Timestamp forMillis(BigDecimal millis, Integer localOffset)
    {
<span class="fc" id="L1381">        return new Timestamp(millis, localOffset);</span>
    }


    /**
     * Converts a {@link Calendar} to a Timestamp, preserving the calendar's
     * time zone as the equivalent local offset when it has at least minutes
     * precision.
     *
     * @return a Timestamp instance, with precision determined by the smallest
     *   field set in the {@code Calendar};
     *   or {@code null} if {@code calendar} is {@code null}
     *

     */
    public static Timestamp forCalendar(Calendar calendar)
    {
<span class="pc bpc" id="L1398" title="1 of 2 branches missed.">        if (calendar == null) return null;</span>
<span class="fc" id="L1399">        return new Timestamp(calendar);</span>
    }


    /**
     * Converts a {@link Date} to a Timestamp in UTC representing the same
     * point in time.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the millisecond;
     *          {@code null} if {@code date} is {@code null}
     *

     */
    public static Timestamp forDateZ(Date date)
    {
<span class="fc bfc" id="L1417" title="All 2 branches covered.">        if (date == null) return null;</span>
<span class="fc" id="L1418">        long millis = date.getTime();</span>
<span class="fc" id="L1419">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts a {@link java.sql.Timestamp} to a Timestamp in UTC representing
     * the same point in time.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the nanosecond.
     *
     * @param sqlTimestamp assumed to have nanoseconds precision
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the
     *          nanosecond
     *          {@code null} if {@code sqlTimestamp} is {@code null}
     *

     */
    public static Timestamp forSqlTimestampZ(java.sql.Timestamp sqlTimestamp)
    {
<span class="fc bfc" id="L1440" title="All 2 branches covered.">        if (sqlTimestamp == null) return null;</span>

<span class="fc" id="L1442">        long millis = sqlTimestamp.getTime();</span>
<span class="fc" id="L1443">        Timestamp ts = new Timestamp(millis, UTC_OFFSET);</span>
<span class="fc" id="L1444">        int nanos = sqlTimestamp.getNanos();</span>
<span class="fc" id="L1445">        BigDecimal frac = BigDecimal.valueOf(nanos).movePointLeft(9);</span>
<span class="fc" id="L1446">        ts._fraction = frac;</span>
<span class="fc" id="L1447">        return ts;</span>
    }


    /**
     * Returns a Timestamp representing the current time (based on the JVM
     * clock), with an unknown local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance representing the current time.
     */
    public static Timestamp now()
    {
<span class="nc" id="L1462">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1463">        return new Timestamp(millis, UNKNOWN_OFFSET);</span>
    }

    /**
     * Returns a Timestamp in UTC representing the current time (based on the
     * the JVM clock).
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, representing the current
     *          time.
     *

     */
    public static Timestamp nowZ()
    {
<span class="nc" id="L1480">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1481">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts the value of this Timestamp into a {@link Date},
     * representing the time in UTC.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     * &lt;p&gt;
     * Because {@link Date} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Date} instance, in UTC
     */
    public Date dateValue()
    {
<span class="fc" id="L1499">        long millis = getMillis();</span>
<span class="fc" id="L1500">        return new Date(millis);</span>
    }


    /**
     * Converts the value of this Timestamp as a {@link Calendar}, in its
     * local time.
     * &lt;p&gt;
     * Because {@link Calendar} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Calendar} instance, in its local time.
     *

     */
    public Calendar calendarValue()
    {
<span class="fc" id="L1517">        Calendar cal = new GregorianCalendar(_Private_Utils.UTC);</span>

<span class="fc" id="L1519">        long millis = getMillis();</span>
<span class="fc" id="L1520">        Integer offset = _offset;</span>
<span class="fc bfc" id="L1521" title="All 4 branches covered.">        if (offset != null &amp;&amp; offset != 0)</span>
        {
<span class="fc" id="L1523">            int offsetMillis = offset * 60 * 1000;</span>
<span class="fc" id="L1524">            millis += offsetMillis;</span>
<span class="fc" id="L1525">            cal.setTimeInMillis(millis);                // Resets the offset!</span>
<span class="fc" id="L1526">            cal.set(Calendar.ZONE_OFFSET, offsetMillis);</span>
<span class="fc" id="L1527">        }</span>
        else
        {
<span class="fc" id="L1530">            cal.setTimeInMillis(millis);</span>
        }

<span class="pc bpc" id="L1533" title="1 of 6 branches missed.">        switch (_precision) {</span>
            case YEAR:
<span class="fc" id="L1535">                cal.clear(Calendar.MONTH);</span>
            case MONTH:
<span class="fc" id="L1537">                cal.clear(Calendar.DAY_OF_MONTH);</span>
            case DAY:
<span class="fc" id="L1539">                cal.clear(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L1540">                cal.clear(Calendar.MINUTE);</span>
            case MINUTE:
<span class="fc" id="L1542">                cal.clear(Calendar.SECOND);</span>
<span class="fc" id="L1543">                cal.clear(Calendar.MILLISECOND);</span>
            case SECOND:
<span class="fc bfc" id="L1545" title="All 2 branches covered.">                if (_fraction == null) {</span>
<span class="fc" id="L1546">                    cal.clear(Calendar.MILLISECOND);</span>
                }
        }

<span class="fc" id="L1550">        return cal;</span>
    }


    /**
     * Returns a number representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional milliseconds)
     * from the epoch.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public long getMillis()
    {
        //                                        month is 0 based for Date
<span class="fc" id="L1570">        long millis = Date.UTC(this._year - 1900, this._month - 1, this._day, this._hour, this._minute, this._second);</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">        if (this._fraction != null) {</span>
<span class="fc" id="L1572">            BigDecimal fracAsDecimal = this._fraction.movePointRight(3);</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">            int frac = isIntegralZero(fracAsDecimal) ? 0 : fracAsDecimal.intValue();</span>
<span class="fc" id="L1574">            millis += frac;</span>
        }
<span class="fc" id="L1576">        return millis;</span>

    }

    /**
     * Returns a BigDecimal representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional milliseconds)
     * from the epoch.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public BigDecimal getDecimalMillis()
    {
<span class="pc bpc" id="L1595" title="1 of 2 branches missed.">        switch (this._precision) {</span>
        case YEAR:
        case MONTH:
        case DAY:
        case MINUTE:
        case SECOND:
        case FRACTION:
<span class="fc" id="L1602">            long millis = Date.UTC(this._year - 1900, this._month - 1, this._day, this._hour, this._minute, this._second);</span>
<span class="fc" id="L1603">            BigDecimal dec = BigDecimal.valueOf(millis);</span>
<span class="fc bfc" id="L1604" title="All 2 branches covered.">            if (_fraction != null) {</span>
<span class="fc" id="L1605">                dec = dec.add(this._fraction.movePointRight(3));</span>
            }
<span class="fc" id="L1607">            return dec;</span>
        }
<span class="nc" id="L1609">        throw new IllegalArgumentException();</span>
    }


    /**
     * Returns the precision of this Timestamp.
     */
    public Precision getPrecision()
    {
<span class="fc" id="L1618">        return this._precision;</span>
    }

    /**
     * Returns the offset of this Timestamp, measured in minutes, for the local
     * timezone in UTC.
     * &lt;p&gt;
     * For example, calling this method on Timestamps of:
     * &lt;ul&gt;
     *     &lt;li&gt;{@code 1969-02-23T07:00+07:00} will return {@code 420}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-22T22:45:00.00-01:15} will return {@code -75}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-23} (by Ion's definition, equivalent to
     *     {@code 1969-02-23T00:00-00:00}) will return {@code null}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return
     *          {@code null} if the local offset is unknown
     *          (i.e. {@code -00:00})
     */
    public Integer getLocalOffset()
    {
<span class="fc" id="L1639">        return _offset;</span>
    }


    /**
     * Returns the year of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 9999], in its local time
     */
    public int getYear()
    {
<span class="fc" id="L1651">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1653" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1655">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1658">        return adjusted._year;</span>
    }


    /**
     * Returns the month of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in its local time;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getMonth()
    {
<span class="fc" id="L1673">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1675" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1676" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1677">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1680">        return adjusted._month;</span>
    }


    /**
     * Returns the day (within the month) of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 31], in its local time;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getDay()
    {
<span class="fc" id="L1694">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1697">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1700">        return adjusted._day;</span>
    }


    /**
     * Returns the hour of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 23], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getHour()
    {
<span class="fc" id="L1714">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1715" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1717">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1720">        return adjusted._hour;</span>
    }


    /**
     * Returns the minute of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 59], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getMinute()
    {
<span class="fc" id="L1734">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1735" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1737">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1740">        return adjusted._minute;</span>
    }


    /**
     * Returns the seconds of this Timestamp, truncated to an integer.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getZSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZSecond()
     */
    public int getSecond()
    {
<span class="fc" id="L1758">        return this._second;</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getZDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZDecimalSecond()
     */
    public BigDecimal getDecimalSecond()
    {
<span class="fc" id="L1777">        BigDecimal sec = BigDecimal.valueOf(_second);</span>
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">        if (_fraction != null)</span>
        {
<span class="fc" id="L1780">            sec = sec.add(_fraction);</span>
        }
<span class="fc" id="L1782">        return sec;</span>
    }


    /**
     * Returns the fractional second of this Timestamp.
     * &lt;p&gt;
     * Fractional seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getZFractionalSecond()}.
     *
     * @return
     *          a BigDecimal within the range [0, 1);
     *          {@code null} is returned if the Timestamp isn't
     *          precise to the fractional second
     *
     * @see #getZFractionalSecond()
     *
     * Use {@link #getDecimalSecond()} instead.
     */
    @Deprecated
    public BigDecimal getFractionalSecond()
    {
<span class="fc" id="L1805">        return this._fraction;</span>
    }


    /**
     * Returns the year of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 9999], in UTC
     */
    public int getZYear()
    {
<span class="fc" id="L1817">        return this._year;</span>
    }


    /**
     * Returns the month of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in UTC;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getZMonth()
    {
<span class="fc" id="L1832">        return this._month;</span>
    }


    /**
     * Returns the day of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 31], in UTC;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getZDay()
    {
<span class="fc" id="L1846">        return this._day;</span>
    }


    /**
     * Returns the hour of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 23], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getZHour()
    {
<span class="fc" id="L1860">        return this._hour;</span>
    }


    /**
     * Returns the minute of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 59], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getZMinute()
    {
<span class="fc" id="L1874">        return this._minute;</span>
    }


    /**
     * Returns the second of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getSecond()
     */
    public int getZSecond()
    {
<span class="fc" id="L1892">        return this._second;</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getDecimalSecond()
     */
    public BigDecimal getZDecimalSecond()
    {
<span class="nc" id="L1911">        return getDecimalSecond();</span>
    }


    /**
     * Returns the fractional second of this Timestamp.
     * &lt;p&gt;
     * Fractional seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getFractionalSecond()}.
     *
     * @return
     *          a BigDecimal within the range [0, 1);
     *          {@code null} is returned if the Timestamp isn't
     *          precise to the fractional second
     *
     * @see #getFractionalSecond()
     *
     * @deprecated Use {@link #getZDecimalSecond()} instead.
     */
    @Deprecated
    public BigDecimal getZFractionalSecond()
    {
<span class="fc" id="L1934">        return this._fraction;</span>
    }


    //=========================================================================
    // Modification methods


    /**
     * Returns a timestamp at the same point in time, but with the given local
     * offset.  If this timestamp has precision coarser than minutes, then it
     * is returned unchanged since such timestamps always have an unknown
     * offset.
     */
    public Timestamp withLocalOffset(Integer offset)
    {
<span class="fc" id="L1950">        Precision precision = getPrecision();</span>
<span class="fc bfc" id="L1951" title="All 2 branches covered.">        if (precision.alwaysUnknownOffset() ||</span>
<span class="fc bfc" id="L1952" title="All 2 branches covered.">            safeEquals(offset, getLocalOffset()))</span>
        {
<span class="fc" id="L1954">            return this;</span>
        }

<span class="fc" id="L1957">        Timestamp ts = createFromUtcFields(precision,</span>
<span class="fc" id="L1958">                                           getZYear(),</span>
<span class="fc" id="L1959">                                           getZMonth(),</span>
<span class="fc" id="L1960">                                           getZDay(),</span>
<span class="fc" id="L1961">                                           getZHour(),</span>
<span class="fc" id="L1962">                                           getZMinute(),</span>
<span class="fc" id="L1963">                                           getZSecond(),</span>
<span class="fc" id="L1964">                                           getZFractionalSecond(),</span>
                                           offset);
<span class="fc" id="L1966">        return ts;</span>
    }


    //=========================================================================


    /**
     * Returns the string representation (in Ion format) of this Timestamp in
     * its local time.
     *
     * @see #toZString()
     * @see #print(Appendable)
     */
    @Override
    public String toString()
    {
<span class="fc" id="L1983">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L1986">            print(buffer);</span>
        }
<span class="nc" id="L1988">        catch (IOException e)</span>
        {
<span class="nc" id="L1990">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                                       e);
<span class="fc" id="L1992">        }</span>
<span class="fc" id="L1993">        return buffer.toString();</span>
    }


    /**
     * Returns the string representation (in Ion format) of this Timestamp
     * in UTC.
     *
     * @see #toString()
     * @see #printZ(Appendable)
     */
    public String toZString()
    {
<span class="fc" id="L2006">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L2009">            printZ(buffer);</span>
        }
<span class="nc" id="L2011">        catch (IOException e)</span>
        {
<span class="nc" id="L2013">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                                       e);
<span class="fc" id="L2015">        }</span>
<span class="fc" id="L2016">        return buffer.toString();</span>
    }


    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in its local time.
     * &lt;p&gt;
     * This method produces the same output as {@link #toString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@link Appendable} throws it
     *
     * @see #printZ(Appendable)
     */
    public void print(Appendable out)
        throws IOException
    {
        // we have to make a copy to preserve the &quot;immutable&quot; contract
        // on Timestamp and we don't want someone reading the calendar
        // member while we've shifted it around.
<span class="fc" id="L2038">        Timestamp adjusted = this;</span>

        // Adjust UTC time back to local time
<span class="fc bfc" id="L2041" title="All 4 branches covered.">        if (this._offset != null &amp;&amp; this._offset.intValue() != 0) {</span>
<span class="fc" id="L2042">            adjusted = make_localtime();</span>
        }

<span class="fc" id="L2045">        print(out, adjusted);</span>
<span class="fc" id="L2046">    }</span>


    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in UTC.
     * &lt;p&gt;
     * This method produces the same output as {@link #toZString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@code Appendable} throws it.
     *
     * @see #print(Appendable)
     */
    public void printZ(Appendable out)
        throws IOException
    {
<span class="pc bpc" id="L2064" title="1 of 3 branches missed.">        switch (_precision)</span>
        {
            case YEAR:
            case MONTH:
            case DAY:
            {
<span class="pc bpc" id="L2070" title="2 of 4 branches missed.">                assert _offset == UNKNOWN_OFFSET;</span>
                // No need to adjust offset, we won't be using it.
<span class="fc" id="L2072">                print(out);</span>
<span class="fc" id="L2073">                break;</span>
            }
            case MINUTE:
            case SECOND:
            case FRACTION:
            {
<span class="fc" id="L2079">                Timestamp ztime = this.clone();</span>
<span class="fc" id="L2080">                ztime._offset = UTC_OFFSET;</span>
<span class="fc" id="L2081">                ztime.print(out);</span>
<span class="fc" id="L2082">                break;</span>
            }
        }
<span class="fc" id="L2085">    }</span>


    /**
     * helper for print(out) and printZ(out) so that printZ can create
     * a zulu time and pass it directly and print can apply the local
     * offset and adjust the various fields (without breaking the
     * contract to be immutable).
     * @param out destination for the text image of the value
     * @param adjusted the time value with the fields adjusted to match the desired text output
     * @throws IOException
     */
    private static void print(Appendable out, Timestamp adjusted)
        throws IOException
    {
        // null is our first &quot;guess&quot; to get it out of the way
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">        if (adjusted == null) {</span>
<span class="nc" id="L2102">            out.append(&quot;null.timestamp&quot;);</span>
<span class="nc" id="L2103">            return;</span>
        }

        // so we have a real value - we'll start with the date portion
        // which we always have
<span class="fc" id="L2108">        print_digits(out, adjusted._year, 4);</span>
<span class="fc bfc" id="L2109" title="All 2 branches covered.">        if (adjusted._precision == Precision.YEAR) {</span>
<span class="pc bpc" id="L2110" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L2111">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L2112">            return;</span>
        }

<span class="fc" id="L2115">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L2116">        print_digits(out, adjusted._month, 2);  // convert calendar months to a base 1 value</span>
<span class="fc bfc" id="L2117" title="All 2 branches covered.">        if (adjusted._precision == Precision.MONTH) {</span>
<span class="pc bpc" id="L2118" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L2119">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L2120">            return;</span>
        }

<span class="fc" id="L2123">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L2124">        print_digits(out, adjusted._day, 2);</span>
<span class="fc bfc" id="L2125" title="All 2 branches covered.">        if (adjusted._precision == Precision.DAY) {</span>
<span class="pc bpc" id="L2126" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
            // out.append(&quot;T&quot;);
<span class="fc" id="L2128">            return;</span>
        }

<span class="fc" id="L2131">        out.append(&quot;T&quot;);</span>
<span class="fc" id="L2132">        print_digits(out, adjusted._hour, 2);</span>
<span class="fc" id="L2133">        out.append(&quot;:&quot;);</span>
<span class="fc" id="L2134">        print_digits(out, adjusted._minute, 2);</span>
        // ok, so how much time do we have ?
<span class="fc bfc" id="L2136" title="All 2 branches covered.">        if (adjusted._precision == Precision.SECOND) {</span>
<span class="fc" id="L2137">            out.append(&quot;:&quot;);</span>
<span class="fc" id="L2138">            print_digits(out, adjusted._second, 2);</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">            if (adjusted._fraction != null) {</span>
<span class="fc" id="L2140">                print_fractional_digits(out, adjusted._fraction);</span>
            }
        }

<span class="fc bfc" id="L2144" title="All 2 branches covered.">        if (adjusted._offset != UNKNOWN_OFFSET) {</span>
            int min, hour;
<span class="fc" id="L2146">            min = adjusted._offset;</span>
<span class="fc bfc" id="L2147" title="All 2 branches covered.">            if (min == 0) {</span>
<span class="fc" id="L2148">                out.append('Z');</span>
            }
            else {
<span class="fc bfc" id="L2151" title="All 2 branches covered.">                if (min &lt; 0) {</span>
<span class="fc" id="L2152">                    min = -min;</span>
<span class="fc" id="L2153">                    out.append('-');</span>
                }
                else {
<span class="fc" id="L2156">                    out.append('+');</span>
                }
<span class="fc" id="L2158">                hour = min / 60;</span>
<span class="fc" id="L2159">                min = min - hour*60;</span>
<span class="fc" id="L2160">                print_digits(out, hour, 2);</span>
<span class="fc" id="L2161">                out.append(&quot;:&quot;);</span>
<span class="fc" id="L2162">                print_digits(out, min, 2);</span>
            }
<span class="fc" id="L2164">        }</span>
        else {
<span class="fc" id="L2166">            out.append(&quot;-00:00&quot;);</span>
        }
<span class="fc" id="L2168">    }</span>
    private static void print_digits(Appendable out, int value, int length)
        throws IOException
    {
<span class="fc" id="L2172">        char temp[] = new char[length];</span>
<span class="fc bfc" id="L2173" title="All 2 branches covered.">        while (length &gt; 0) {</span>
<span class="fc" id="L2174">            length--;</span>
<span class="fc" id="L2175">            int next = value / 10;</span>
<span class="fc" id="L2176">            temp[length] =  (char)('0' + (value - next*10));</span>
<span class="fc" id="L2177">            value = next;</span>
<span class="fc" id="L2178">        }</span>
<span class="pc bpc" id="L2179" title="1 of 2 branches missed.">        while (length &gt; 0) {</span>
<span class="nc" id="L2180">            length--;</span>
<span class="nc" id="L2181">            temp[length] =  '0';</span>
        }
<span class="fc bfc" id="L2183" title="All 2 branches covered.">        for (char c : temp) {</span>
<span class="fc" id="L2184">            out.append(c);</span>
        }
<span class="fc" id="L2186">    }</span>
    private static void print_fractional_digits(Appendable out, BigDecimal value)
        throws IOException
    {
<span class="fc" id="L2190">        String temp = value.toPlainString(); // crude, but it works</span>
<span class="pc bpc" id="L2191" title="1 of 2 branches missed.">        if (temp.charAt(0) == '0') { // this should always be true</span>
<span class="fc" id="L2192">            temp = temp.substring(1);</span>
        }
<span class="fc" id="L2194">        out.append(temp);</span>
<span class="fc" id="L2195">    }</span>


    //=========================================================================
    // Timestamp arithmetic


    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. After performing the arithmetic, the resulting Timestamp's
     * seconds value will be truncated to the same fractional precision as the
     * original. For example, adjusting {@code 2012-04-01T00:00:00Z} by one
     * millisecond results in {@code 2012-04-01T00:00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00.0010Z} by -1 millisecond results in
     * {@code 2012-04-01T00:00:00.0000Z}. To extend the precision when the
     * original Timestamp has coarser than SECOND precision and to avoid
     * truncation of the seconds value, use {@link #addSecond(int)}.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp adjustMillis(long amount) {
<span class="fc bfc" id="L2219" title="All 2 branches covered.">        if (amount == 0) return this;</span>
<span class="fc" id="L2220">        Timestamp ts = addMillisForPrecision(amount, _precision, false);</span>
        //ts._precision = _precision;
<span class="fc" id="L2222">        ts.clearUnusedPrecision();</span>
<span class="fc bfc" id="L2223" title="All 2 branches covered.">        if (ts._precision.includes(Precision.SECOND)) {</span>
            // Maintain the same amount of fractional precision.
<span class="fc bfc" id="L2225" title="All 2 branches covered.">            if (_fraction == null) {</span>
<span class="fc" id="L2226">                ts._fraction = null;</span>
            } else {
                // Truncate the result only if it exceeds the fractional precision of the original.
<span class="pc bpc" id="L2229" title="1 of 2 branches missed.">                if (ts._fraction.scale() &gt; _fraction.scale()) {</span>
<span class="nc" id="L2230">                    ts._fraction = ts._fraction.setScale(_fraction.scale(), RoundingMode.FLOOR);</span>
                }
            }
        }
<span class="fc" id="L2234">        return ts;</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision and a seconds
     * value precise at least to the millisecond. For example, adding one millisecond
     * to {@code 2011T} results in {@code 2011-01-01T00:00:00.001-00:00}. To receive
     * a Timestamp that always maintains the same precision as the original, use
     * {@link #adjustMillis(long)}.
     * milliseconds.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp addMillis(long amount)
    {
<span class="fc bfc" id="L2252" title="All 8 branches covered.">        if (amount == 0 &amp;&amp; _precision.includes(Precision.SECOND) &amp;&amp; _fraction != null &amp;&amp; _fraction.scale() &gt;= 3) {</span>
            // Zero milliseconds are to be added, and the precision does not need to be increased.
<span class="fc" id="L2254">            return this;</span>
        }
<span class="fc" id="L2256">        return addMillisForPrecision(amount, Precision.SECOND, true);</span>
    }

    /**
     * Adds the given number of milliseconds, extending (if necessary) the resulting Timestamp to the given
     * precision.
     * @param amount the number of milliseconds to add.
     * @param precision the precision that the Timestamp will be extended to, if it does not already include that
     *                  precision.
     * @param millisecondsPrecision true if and only if the `amount` includes milliseconds precision. If true, the
     *                              resulting timestamp's fraction will have precision at least to the millisecond.
     * @return a new Timestamp.
     */
    private Timestamp addMillisForPrecision(long amount, Precision precision, boolean millisecondsPrecision) {
        // When millisecondsPrecision is true, the caller must do its own short-circuiting because it must
        // check the fractional precision.
<span class="fc bfc" id="L2272" title="All 6 branches covered.">        if (!millisecondsPrecision &amp;&amp; amount == 0 &amp;&amp; _precision == precision) return this;</span>
        // This strips off the local offset, expressing our fields as if they
        // were UTC.
<span class="fc" id="L2275">        BigDecimal millis = make_localtime().getDecimalMillis();</span>
<span class="fc" id="L2276">        millis = millis.add(BigDecimal.valueOf(amount));</span>
<span class="fc bfc" id="L2277" title="All 2 branches covered.">        Precision newPrecision = _precision.includes(precision) ? _precision : precision;</span>


<span class="fc" id="L2280">        Timestamp ts = new Timestamp(millis, newPrecision, _offset);</span>
        // Anything with courser-than-millis precision will have been extended
        // to 3 decimal places due to use of getDecimalMillis(). Compensate for
        // that by setting the scale such that it is never extended unless
        // milliseconds precision is being added and the fraction does not yet
        // have milliseconds precision.
<span class="fc bfc" id="L2286" title="All 2 branches covered.">        int newScale = millisecondsPrecision ? 3 : 0;</span>
<span class="fc bfc" id="L2287" title="All 2 branches covered.">        if (_fraction != null) {</span>
<span class="fc" id="L2288">            newScale = Math.max(newScale, _fraction.scale());</span>
        }
<span class="fc bfc" id="L2290" title="All 2 branches covered.">        if (ts._fraction != null) {</span>
<span class="fc bfc" id="L2291" title="All 2 branches covered.">            ts._fraction = newScale == 0 ? null : ts._fraction.setScale(newScale, RoundingMode.FLOOR);</span>
        }
<span class="fc bfc" id="L2293" title="All 4 branches covered.">        if (_offset != null &amp;&amp; _offset != 0)</span>
        {
<span class="fc" id="L2295">            ts.apply_offset(_offset);</span>
        }
<span class="fc" id="L2297">        return ts;</span>
    }

    /**
     * Clears any fields more precise than this Timestamp's precision supports.
     */
    private void clearUnusedPrecision() {
<span class="fc bfc" id="L2304" title="All 5 branches covered.">        switch (_precision) {</span>
            case YEAR:
<span class="fc" id="L2306">                _month = 1;</span>
            case MONTH:
<span class="fc" id="L2308">                _day = 1;</span>
            case DAY:
<span class="fc" id="L2310">                _hour = 0;</span>
<span class="fc" id="L2311">                _minute = 0;</span>
            case MINUTE:
<span class="fc" id="L2313">                _second = 0;</span>
<span class="fc" id="L2314">                _fraction = null;</span>
            case SECOND:
        }
<span class="fc" id="L2317">    }</span>

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T00:00Z} by one
     * second results in {@code 2012-04-01T00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00Z} by -1 second results in
     * {@code 2012-03-31T23:59:59Z}. To extend the precision when the original
     * Timestamp has coarser than SECOND precision, use {@link #addSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp adjustSecond(int amount)
    {
<span class="fc" id="L2333">        long delta = (long) amount * 1000;</span>
<span class="fc" id="L2334">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision.
     * For example, adding one second to {@code 2011T} results in
     * {@code 2011-01-01T00:00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp addSecond(int amount)
    {
<span class="fc" id="L2349">        long delta = (long) amount * 1000;</span>
<span class="fc" id="L2350">        return addMillisForPrecision(delta, Precision.SECOND, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one minute
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 minute results in {@code 2012-03-31T23:59-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp adjustMinute(int amount)
    {
<span class="fc" id="L2367">        long delta = (long) amount * 60 * 1000;</span>
<span class="fc" id="L2368">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one minute to {@code 2011T} results in
     * {@code 2011-01-01T00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp addMinute(int amount)
    {
<span class="fc" id="L2383">        long delta = (long) amount * 60 * 1000;</span>
<span class="fc" id="L2384">        return addMillisForPrecision(delta, Precision.MINUTE, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one hour
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 hour results in {@code 2012-03-31T23:00-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp adjustHour(int amount)
    {
<span class="fc" id="L2401">        long delta = (long) amount * 60 * 60 * 1000;</span>
<span class="fc" id="L2402">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one hour to {@code 2011T} results in
     * {@code 2011-01-01T01:00-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp addHour(int amount)
    {
<span class="fc" id="L2417">        long delta = (long) amount * 60 * 60 * 1000;</span>
<span class="fc" id="L2418">        return addMillisForPrecision(delta, Precision.MINUTE, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04T} by one day results
     * in {@code 2012-04T}; adjusting {@code 2012-04-01T} by -1 days results in
     * {@code 2012-03-31T}. To extend the precision when the original Timestamp
     * has coarser than DAY precision, use {@link #addDay(int)}.
     *
     * @param amount a number of days.
     */
    public final Timestamp adjustDay(int amount)
    {
<span class="fc" id="L2434">        long delta = (long) amount * 24 * 60 * 60 * 1000;</span>
<span class="fc" id="L2435">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     *
     * @param amount a number of days.
     */
    public final Timestamp addDay(int amount)
    {
<span class="fc" id="L2445">        long delta = (long) amount * 24 * 60 * 60 * 1000;</span>
<span class="fc" id="L2446">        return addMillisForPrecision(delta, Precision.DAY, false);</span>
    }

    // Shifting month and year are more complicated since the length of a month
    // varies and we want the day-of-month to stay the same when possible.
    // We rely on Calendar for the logic.

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as the
     * original. For example, adjusting {@code 2011T} by one month results in
     * {@code 2011T}; adding 12 months to {@code 2011T} results in {@code 2012T}.
     * To extend the precision when the original Timestamp has coarser than MONTH
     * precision, use {@link #addMonth(int)}.
     *
     * @param amount a number of months.
     */
    public final Timestamp adjustMonth(int amount)
    {
<span class="pc bpc" id="L2468" title="1 of 2 branches missed.">        if (amount == 0) return this;</span>
<span class="fc" id="L2469">        return addMonthForPrecision(amount, _precision);</span>
    }

    /**
     * Adds the given number of months, extending (if necessary) the resulting Timestamp to the given
     * precision.
     * @param amount the number of months to add.
     * @param precision the precision that the Timestamp will be extended to, if it does not already include that
     *                  precision.
     * @return a new Timestamp.
     */
    private Timestamp addMonthForPrecision(int amount, Precision precision) {
<span class="fc" id="L2481">        Calendar cal = calendarValue();</span>
<span class="fc" id="L2482">        cal.add(Calendar.MONTH, amount);</span>
<span class="fc" id="L2483">        return new Timestamp(cal, precision, _fraction, _offset);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days.  For example, adding one month to {@code 2011-01-31}
     * results in {@code 2011-02-28}.
     *
     * @param amount a number of months.
     */
    public final Timestamp addMonth(int amount)
    {
<span class="pc bpc" id="L2496" title="3 of 4 branches missed.">        if (amount == 0 &amp;&amp; _precision.includes(Precision.MONTH)) return this;</span>
<span class="fc bfc" id="L2497" title="All 2 branches covered.">        return addMonthForPrecision(amount, _precision.includes(Precision.MONTH) ? _precision : Precision.MONTH);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days. For example,
     * adjusting {@code 2012-02-29} by one year results in {@code 2013-02-28}.
     * &lt;p&gt;
     * Because YEAR is the coarsest precision possible, this method always
     * returns a Timestamp with the same precision as the original and
     * behaves identically to {@link #addYear(int)}.
     *
     * @param amount a number of years.
     */
    public final Timestamp adjustYear(int amount) {
<span class="fc" id="L2512">        return addYear(amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days.  For example,
     * adding one year to {@code 2012-02-29} results in {@code 2013-02-28}.
     *
     * @param amount a number of years.
     */
    public final Timestamp addYear(int amount)
    {
<span class="pc bpc" id="L2524" title="1 of 2 branches missed.">        if (amount == 0) return this;</span>

<span class="fc" id="L2526">        Calendar cal = calendarValue();</span>
<span class="fc" id="L2527">        cal.add(Calendar.YEAR, amount);</span>
<span class="fc" id="L2528">        return new Timestamp(cal, _precision, _fraction, _offset);</span>
    }


    //=========================================================================

    /**
     * Returns a hash code consistent with {@link #equals(Object)}.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public int hashCode()
    {
        // Performs a Shift-Add-XOR-Rotate hash. Rotating at each step to
        // produce an &quot;Avalanche&quot; effect for timestamps with small deltas, which
        // is found to be a common input data set.

<span class="fc" id="L2546">        final int prime = 8191;</span>
<span class="fc" id="L2547">        int result = HASH_SIGNATURE;</span>

<span class="fc bfc" id="L2549" title="All 2 branches covered.">        result = prime * result + (_fraction != null</span>
<span class="fc" id="L2550">            ? _fraction.hashCode()</span>
<span class="fc" id="L2551">            : 0);</span>

<span class="fc" id="L2553">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2555">        result = prime * result + this._year;</span>
<span class="fc" id="L2556">        result = prime * result + this._month;</span>
<span class="fc" id="L2557">        result = prime * result + this._day;</span>
<span class="fc" id="L2558">        result = prime * result + this._hour;</span>
<span class="fc" id="L2559">        result = prime * result + this._minute;</span>
<span class="fc" id="L2560">        result = prime * result + this._second;</span>

<span class="fc" id="L2562">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc bfc" id="L2564" title="All 2 branches covered.">        Precision precision = this._precision == Precision.FRACTION ? Precision.SECOND : this._precision;</span>
<span class="fc" id="L2565">        result = prime * result + precision.toString().hashCode();</span>

<span class="fc" id="L2567">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc bfc" id="L2569" title="All 2 branches covered.">        result = prime * result + (_offset == null ? 0 : _offset.hashCode());</span>

<span class="fc" id="L2571">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2573">        return result;</span>
    }



    /**
     * Performs a comparison of the two points in time represented by two
     * Timestamps.
     * If the point in time represented by this Timestamp precedes that of
     * {@code t}, then {@code -1} is returned.
     * If {@code t} precedes this Timestamp then {@code 1} is returned.
     * If the Timestamps represent the same point in time, then
     * {@code 0} is returned.
     * Note that a {@code 0} result does not imply that the two Timestamps are
     * {@link #equals}, as the local offset or precision of the two Timestamps
     * may be different.
     *
     * &lt;p&gt;
     * This method is provided in preference to individual methods for each of
     * the six boolean comparison operators (&amp;lt;, ==, &amp;gt;, &amp;gt;=, !=, &amp;lt;=).
     * The suggested idiom for performing these comparisons is:
     * {@code (x.compareTo(y)}&lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt;{@code 0)},
     * where &lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt; is one of the six comparison operators.
     *
     * &lt;p&gt;
     * For example, the pairs below will return a {@code 0} result:
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2008-12-31T16:00-08:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2008-12-31T12:00-12:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T12:00+12:00}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #equals(Timestamp)} method to compare the point
     * in time, &lt;em&gt;including&lt;/em&gt; precision and local offset.
     *
     * @param t
     *          the other {@code Timestamp} to compare this {@code Timestamp} to
     *
     * @return
     *          -1, 0, or 1 if this {@code Timestamp}
     *          is less than, equal to, or greater than {@code t} respectively
     *
     * @throws NullPointerException if {@code t} is null.
     *
     * @see #equals(Timestamp)
     */
    public int compareTo(Timestamp t)
    {
        // Test at millisecond precision first.
<span class="fc" id="L2631">        long this_millis = this.getMillis();</span>
<span class="fc" id="L2632">        long arg_millis = t.getMillis();</span>
<span class="fc bfc" id="L2633" title="All 2 branches covered.">        if (this_millis != arg_millis) {</span>
<span class="fc bfc" id="L2634" title="All 2 branches covered.">            return (this_millis &lt; arg_millis) ? -1 : 1;</span>
        }

        // Values are equivalent at millisecond precision, so compare fraction

        BigDecimal this_fraction =
<span class="fc bfc" id="L2640" title="All 2 branches covered.">            ((this._fraction == null) ? BigDecimal.ZERO : this._fraction);</span>
        BigDecimal arg_fraction =
<span class="fc bfc" id="L2642" title="All 2 branches covered.">            (( t._fraction == null) ? BigDecimal.ZERO :  t._fraction);</span>
<span class="fc" id="L2643">        return this_fraction.compareTo(arg_fraction);</span>
    }


    /**
     * Compares this {@link Timestamp} to the specified Object.
     * The result is {@code true} if and only if the parameter is a
     * {@link Timestamp} object that represents the same point in time,
     * precision and local offset as this Timestamp.
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #equals(Timestamp)
     * @see #compareTo(Timestamp)
     */
    @Override
    public boolean equals(Object t)
    {
<span class="pc bpc" id="L2662" title="1 of 2 branches missed.">        if (!(t instanceof Timestamp)) return false;</span>
<span class="fc" id="L2663">        return equals((Timestamp)t);</span>
    }

    /**
     * Compares this {@link Timestamp} to another {@link Timestamp} object.
     * The result is {@code true} if and only if the parameter
     * represents the same point in time and has
     * the same precision and local offset as this object.
     * &lt;p&gt;
     * These pairs are {@link #equals} to each other, as they
     * represent the same points in time, precision and local offset:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22+00:00} (minute precision, in UTC)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22Z} (minute precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * On the other hand, none of these pairs are {@link #equals} to each other,
     * they represent the same points in time, but with different precisions
     * and/or local offsets:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001T} (year precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01T} (month precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T} (day precision, unknown local offset)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00-00:00} (second precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00+00:00} (second precision, in UTC)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00.000-00:00} (millisecond precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00.000+00:00} (millisecond precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #compareTo(Timestamp)
     */
    public boolean equals(Timestamp t)
    {
<span class="fc bfc" id="L2705" title="All 2 branches covered.">        if (this == t) return true;</span>
<span class="pc bpc" id="L2706" title="1 of 2 branches missed.">        if (t == null) return false;</span>

        // FRACTION precision is equivalent to SECOND precision.
<span class="fc bfc" id="L2709" title="All 2 branches covered.">        Precision thisPrecision = this._precision.includes(Precision.SECOND) ? Precision.SECOND : this._precision;</span>
<span class="fc bfc" id="L2710" title="All 2 branches covered.">        Precision thatPrecision = t._precision.includes(Precision.SECOND) ? Precision.SECOND : t._precision;</span>

        // if the precisions are not the same the values are not
        // precision doesn't matter WRT equality
<span class="fc bfc" id="L2714" title="All 2 branches covered.">        if (thisPrecision != thatPrecision) return false;</span>

        // if the local offset are not the same the values are not
<span class="fc bfc" id="L2717" title="All 2 branches covered.">        if (this._offset == null) {</span>
<span class="fc bfc" id="L2718" title="All 2 branches covered.">            if (t._offset != null)  return false;</span>
        }
        else {
<span class="fc bfc" id="L2721" title="All 2 branches covered.">            if (t._offset == null) return false;</span>
        }

        // so now we check the actual time value
<span class="fc bfc" id="L2725" title="All 2 branches covered.">        if (this._year   != t._year)    return false;</span>
<span class="fc bfc" id="L2726" title="All 2 branches covered.">        if (this._month  != t._month)   return false;</span>
<span class="fc bfc" id="L2727" title="All 2 branches covered.">        if (this._day    != t._day)     return false;</span>
<span class="fc bfc" id="L2728" title="All 2 branches covered.">        if (this._hour   != t._hour)    return false;</span>
<span class="fc bfc" id="L2729" title="All 2 branches covered.">        if (this._minute != t._minute)  return false;</span>
<span class="fc bfc" id="L2730" title="All 2 branches covered.">        if (this._second != t._second)  return false;</span>

        // and if we have a local offset, check the value here
<span class="fc bfc" id="L2733" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L2734" title="All 2 branches covered.">            if (this._offset.intValue() != t._offset.intValue()) return false;</span>
        }

        // we only look at the fraction if we know that it's actually there
<span class="fc bfc" id="L2738" title="All 8 branches covered.">        if ((this._fraction != null &amp;&amp; t._fraction == null)</span>
                || (this._fraction == null &amp;&amp; t._fraction != null)) {
            // one of the fractions are null
<span class="fc" id="L2741">            return false;</span>
        }
<span class="pc bpc" id="L2743" title="1 of 4 branches missed.">        if (this._fraction == null &amp;&amp; t._fraction == null) {</span>
            // both are null
<span class="fc" id="L2745">            return true;</span>
        }
<span class="fc" id="L2747">        return this._fraction.equals(t._fraction);</span>
    }

    private static short checkAndCastYear(int year)
    {
<span class="fc bfc" id="L2752" title="All 4 branches covered.">        if (year &lt; 1 || year &gt; 9999)</span>
        {
<span class="fc" id="L2754">            throw new IllegalArgumentException(String.format(&quot;Year %s must be between 1 and 9999 inclusive&quot;, year));</span>
        }

<span class="fc" id="L2757">        return (short) year;</span>
    }

    private static byte checkAndCastMonth(int month)
    {
<span class="fc bfc" id="L2762" title="All 4 branches covered.">        if (month &lt; 1 || month &gt; 12)</span>
        {
<span class="fc" id="L2764">            throw new IllegalArgumentException(String.format(&quot;Month %s must be between 1 and 12 inclusive&quot;, month));</span>
        }

<span class="fc" id="L2767">        return (byte) month;</span>
    }

    private static byte checkAndCastDay(int day, int year, int month)
    {
<span class="fc" id="L2772">        int lastDayInMonth = last_day_in_month(year, month);</span>
<span class="fc bfc" id="L2773" title="All 4 branches covered.">        if (day &lt; 1 || day &gt; lastDayInMonth) {</span>
<span class="fc" id="L2774">            throw new IllegalArgumentException(String.format(&quot;Day %s for year %s and month %s must be between 1 and %s inclusive&quot;, day, year, month, lastDayInMonth));</span>
        }

<span class="fc" id="L2777">        return (byte) day;</span>
    }

    private static byte checkAndCastHour(int hour)
    {
<span class="pc bpc" id="L2782" title="1 of 4 branches missed.">        if (hour &lt; 0 || hour &gt; 23)</span>
        {
<span class="fc" id="L2784">            throw new IllegalArgumentException(String.format(&quot;Hour %s must be between 0 and 23 inclusive&quot;, hour));</span>
        }

<span class="fc" id="L2787">        return (byte) hour;</span>
    }

    private static byte checkAndCastMinute(int minute)
    {
<span class="pc bpc" id="L2792" title="1 of 4 branches missed.">        if (minute &lt; 0 || minute &gt; 59)</span>
        {
<span class="fc" id="L2794">            throw new IllegalArgumentException(String.format(&quot;Minute %s must be between between 0 and 59 inclusive&quot;, minute));</span>
        }

<span class="fc" id="L2797">        return (byte) minute;</span>
    }

    private static byte checkAndCastSecond(int second)
    {
<span class="fc bfc" id="L2802" title="All 4 branches covered.">        if (second &lt; 0 || second &gt; 59)</span>
        {
<span class="fc" id="L2804">            throw new IllegalArgumentException(String.format(&quot;Second %s must be between between 0 and 59 inclusive&quot;, second));</span>
        }

<span class="fc" id="L2807">        return (byte) second;</span>
    }

    private static Precision checkFraction(Precision precision, BigDecimal fraction)
    {
<span class="fc bfc" id="L2812" title="All 2 branches covered.">        if (precision.includes(Precision.SECOND)) {</span>
<span class="pc bpc" id="L2813" title="1 of 6 branches missed.">            if (fraction != null &amp;&amp; (fraction.signum() == -1 || BigDecimal.ONE.compareTo(fraction) != 1)) {</span>
<span class="fc" id="L2814">                throw new IllegalArgumentException(String.format(&quot;Fractional seconds %s must be greater than or equal to 0 and less than 1&quot;, fraction));</span>
            }
        }
        else {
<span class="pc bpc" id="L2818" title="1 of 2 branches missed.">            if (fraction != null) {</span>
<span class="nc" id="L2819">                throw new IllegalArgumentException(&quot;Fraction must be null for non-second precision: &quot; + fraction);</span>
            }
        }

<span class="fc" id="L2823">        return precision;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>