<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonRawBinaryWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl.bin</a> &gt; <span class="el_source">IonRawBinaryWriter.java</span></div><h1>IonRawBinaryWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl.bin;

import static com.amazon.ion.Decimal.isNegativeZero;
import static com.amazon.ion.IonType.BLOB;
import static com.amazon.ion.IonType.BOOL;
import static com.amazon.ion.IonType.CLOB;
import static com.amazon.ion.IonType.DECIMAL;
import static com.amazon.ion.IonType.FLOAT;
import static com.amazon.ion.IonType.INT;
import static com.amazon.ion.IonType.LIST;
import static com.amazon.ion.IonType.NULL;
import static com.amazon.ion.IonType.SEXP;
import static com.amazon.ion.IonType.STRING;
import static com.amazon.ion.IonType.STRUCT;
import static com.amazon.ion.IonType.SYMBOL;
import static com.amazon.ion.IonType.TIMESTAMP;
import static com.amazon.ion.IonType.isContainer;
import static com.amazon.ion.SystemSymbols.ION_1_0_SID;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE_SID;
import static com.amazon.ion.Timestamp.Precision.DAY;
import static com.amazon.ion.Timestamp.Precision.MINUTE;
import static com.amazon.ion.Timestamp.Precision.MONTH;
import static com.amazon.ion.Timestamp.Precision.SECOND;
import static java.lang.Double.doubleToRawLongBits;
import static java.lang.Float.floatToRawIntBits;

import com.amazon.ion.IonCatalog;
import com.amazon.ion.IonException;
import com.amazon.ion.IonType;
import com.amazon.ion.IonWriter;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.Timestamp;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * Low-level binary {@link IonWriter} that understands encoding concerns but doesn't operate with any sense of symbol table management.
 */
@SuppressWarnings(&quot;deprecation&quot;)
/*package*/ final class IonRawBinaryWriter extends AbstractIonWriter implements _Private_IonRawWriter
{
    /** short-hand for array of bytes--useful for static definitions. */
    private static byte[] bytes(int... vals) {
<span class="fc" id="L71">        final byte[] octets = new byte[vals.length];</span>

<span class="fc bfc" id="L73" title="All 2 branches covered.">        for (int i = 0; i &lt; vals.length; i++) {</span>
<span class="fc" id="L74">            octets[i] = (byte) vals[i];</span>
        }

<span class="fc" id="L77">        return octets;</span>
    }

<span class="fc" id="L80">    private static final byte[] IVM = bytes(0xE0, 0x01, 0x00, 0xEA);</span>

    private static final byte[] NULLS;
    static {
<span class="fc" id="L84">        final IonType[] types = IonType.values();</span>
<span class="fc" id="L85">        NULLS = new byte[types.length];</span>

<span class="fc" id="L87">        NULLS[NULL.ordinal()]           = (byte) 0x0F;</span>
<span class="fc" id="L88">        NULLS[BOOL.ordinal()]           = (byte) 0x1F;</span>
<span class="fc" id="L89">        NULLS[INT.ordinal()]            = (byte) 0x2F;</span>
<span class="fc" id="L90">        NULLS[FLOAT.ordinal()]          = (byte) 0x4F;</span>
<span class="fc" id="L91">        NULLS[DECIMAL.ordinal()]        = (byte) 0x5F;</span>
<span class="fc" id="L92">        NULLS[TIMESTAMP.ordinal()]      = (byte) 0x6F;</span>
<span class="fc" id="L93">        NULLS[SYMBOL.ordinal()]         = (byte) 0x7F;</span>
<span class="fc" id="L94">        NULLS[STRING.ordinal()]         = (byte) 0x8F;</span>
<span class="fc" id="L95">        NULLS[CLOB.ordinal()]           = (byte) 0x9F;</span>
<span class="fc" id="L96">        NULLS[BLOB.ordinal()]           = (byte) 0xAF;</span>
<span class="fc" id="L97">        NULLS[LIST.ordinal()]           = (byte) 0xBF;</span>
<span class="fc" id="L98">        NULLS[SEXP.ordinal()]           = (byte) 0xCF;</span>
<span class="fc" id="L99">        NULLS[STRUCT.ordinal()]         = (byte) 0xDF;</span>
    }
<span class="fc" id="L101">    private static final byte NULL_NULL = NULLS[NULL.ordinal()];</span>

    private static final byte BOOL_FALSE        = (byte) 0x10;
    private static final byte BOOL_TRUE         = (byte) 0x11;

    private static final byte INT_ZERO          = (byte) 0x20;

    private static final byte POS_INT_TYPE      = (byte) 0x20;
    private static final byte NEG_INT_TYPE      = (byte) 0x30;
    private static final byte FLOAT_TYPE        = (byte) 0x40;

    private static final byte DECIMAL_TYPE      = (byte) 0x50;
    private static final byte TIMESTAMP_TYPE    = (byte) 0x60;
    private static final byte SYMBOL_TYPE       = (byte) 0x70;
    private static final byte STRING_TYPE       = (byte) 0x80;

    private static final byte CLOB_TYPE         = (byte) 0x90;
    private static final byte BLOB_TYPE         = (byte) 0xA0;

    private static final byte DECIMAL_POS_ZERO               = (byte) 0x50;
    private static final byte DECIMAL_NEGATIVE_ZERO_MANTISSA = (byte) 0x80;

<span class="fc" id="L123">    private static final BigInteger BIG_INT_LONG_MAX_VALUE = BigInteger.valueOf(Long.MAX_VALUE);</span>
<span class="fc" id="L124">    private static final BigInteger BIG_INT_LONG_MIN_VALUE = BigInteger.valueOf(Long.MIN_VALUE);</span>

    private static final byte VARINT_NEG_ZERO   = (byte) 0xC0;

    // See IonRawBinaryWriter#writeString(String) for usage information.
    static final int SMALL_STRING_SIZE = 64;
    static final int MEDIUM_STRING_SIZE = 4 * 1024;

    // Reusable resources for encoding Strings as UTF-8 bytes
<span class="fc" id="L133">    final CharsetEncoder utf8Encoder = Charset.forName(&quot;UTF-8&quot;).newEncoder();</span>
<span class="fc" id="L134">    final ByteBuffer utf8EncodingBuffer = ByteBuffer.allocate((int) (MEDIUM_STRING_SIZE * utf8Encoder.maxBytesPerChar()));</span>
<span class="fc" id="L135">    final char[] charArray = new char[MEDIUM_STRING_SIZE];</span>
<span class="fc" id="L136">    final CharBuffer reusableCharBuffer = CharBuffer.wrap(charArray);</span>

    private static final byte[] makeTypedPreallocatedBytes(final int typeDesc, final int length)
    {
<span class="fc" id="L140">        final byte[] bytes = new byte[length];</span>
<span class="fc" id="L141">        bytes[0]          = (byte) typeDesc;</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (length &gt; 1)</span>
        {
<span class="fc" id="L144">            bytes[length - 1] = (byte) 0x80;</span>
        }
<span class="fc" id="L146">        return bytes;</span>
    }

    private static byte[][] makeContainerTypedPreallocatedTable(final int length) {
<span class="fc" id="L150">        final IonType[] types = IonType.values();</span>
<span class="fc" id="L151">        byte[][] extendedSizes = new byte[types.length][];</span>


<span class="fc" id="L154">        extendedSizes[LIST.ordinal()]   = makeTypedPreallocatedBytes(0xBE, length);</span>
<span class="fc" id="L155">        extendedSizes[SEXP.ordinal()]   = makeTypedPreallocatedBytes(0xCE, length);</span>
<span class="fc" id="L156">        extendedSizes[STRUCT.ordinal()] = makeTypedPreallocatedBytes(0xDE, length);</span>

<span class="fc" id="L158">        return extendedSizes;</span>
    }

    /**
     * Determines how container/container-like values should be padded
     */
<span class="fc" id="L164">    /*package*/ enum PreallocationMode</span>
    {
        /** Allocate no length.  (forces side patching) */
<span class="fc" id="L167">        PREALLOCATE_0(0x0000,   1)</span>
        {
            @Override
            /*package*/ void patchLength(final WriteBuffer buffer, final long position, final long lengthValue)
            {
<span class="nc" id="L172">                throw new IllegalStateException(&quot;Cannot patch in PREALLOCATE 0 mode&quot;);</span>
            }
        },

        /** Preallocate 1 byte of length. */
<span class="fc" id="L177">        PREALLOCATE_1(0x007F,   2)</span>
        {
            @Override
            /*package*/ void patchLength(final WriteBuffer buffer, long position, long lengthValue)
            {
<span class="fc" id="L182">                buffer.writeVarUIntDirect1At(position, lengthValue);</span>
<span class="fc" id="L183">            }</span>
        },

        /** Preallocate 2 bytes of length. */
<span class="fc" id="L187">        PREALLOCATE_2(0x3FFF,   3)</span>
        {
            @Override
            /*package*/ void patchLength(final WriteBuffer buffer, long position, long lengthValue)
            {
<span class="fc" id="L192">                buffer.writeVarUIntDirect2At(position, lengthValue);</span>
<span class="fc" id="L193">            }</span>
        }
        ;

        private final int       contentMaxLength;
        private final int       typedLength;
        private final byte[][]  containerTypedPreallocatedBytes;
        private final byte[]    annotationsTypedPreallocatedBytes;

        private PreallocationMode(final int contentMaxLength, final int typedLength)
<span class="fc" id="L203">        {</span>
<span class="fc" id="L204">            this.contentMaxLength = contentMaxLength;</span>
<span class="fc" id="L205">            this.typedLength = typedLength;</span>
<span class="fc" id="L206">            this.containerTypedPreallocatedBytes   = makeContainerTypedPreallocatedTable(typedLength);</span>
<span class="fc" id="L207">            this.annotationsTypedPreallocatedBytes = makeTypedPreallocatedBytes(0xEE, typedLength);</span>
<span class="fc" id="L208">        }</span>

        /*package*/ abstract void patchLength(final WriteBuffer buffer, final long position, final long length);

        /*package*/ static PreallocationMode withPadSize(final int pad)
        {
<span class="pc bpc" id="L214" title="3 of 4 branches missed.">            switch (pad)</span>
            {
                case 0:
<span class="fc" id="L217">                    return PreallocationMode.PREALLOCATE_0;</span>
                case 1:
<span class="nc" id="L219">                    return PreallocationMode.PREALLOCATE_1;</span>
                case 2:
<span class="nc" id="L221">                    return PreallocationMode.PREALLOCATE_2;</span>
            }
<span class="nc" id="L223">            throw new IllegalArgumentException(&quot;No such preallocation mode for: &quot; + pad);</span>
        }
    }

    private static final byte STRING_TYPE_EXTENDED_LENGTH       = (byte) 0x8E;
<span class="fc" id="L228">    private static final byte[] STRING_TYPED_PREALLOCATED_2     = makeTypedPreallocatedBytes(0x8E, 2);</span>
<span class="fc" id="L229">    private static final byte[] STRING_TYPED_PREALLOCATED_3     = makeTypedPreallocatedBytes(0x8E, 3);</span>

    /** Max supported annotation length specifier size supported. */
    private static final int MAX_ANNOTATION_LENGTH = 0x7F;

<span class="fc" id="L234">    private enum ContainerType</span>
    {
<span class="fc" id="L236">        SEQUENCE(true),</span>
<span class="fc" id="L237">        STRUCT(true),</span>
<span class="fc" id="L238">        VALUE(false),</span>
<span class="fc" id="L239">        ANNOTATION(false);</span>

        public final boolean allowedInStepOut;

        private ContainerType(final boolean allowedInStepOut)
<span class="fc" id="L244">        {</span>
<span class="fc" id="L245">            this.allowedInStepOut = allowedInStepOut;</span>
<span class="fc" id="L246">        }</span>
    }

    private static class ContainerInfo
    {
        /** Whether or not the container is a struct */
        public ContainerType type;
        /** The location of the pre-allocated size descriptor in the buffer. */
        public long position;
        /** The size of the current value. */
        public long length;
        /** The patchlist for this container. */
        public PatchList patches;

        public ContainerInfo()
<span class="fc" id="L261">        {</span>
<span class="fc" id="L262">            type = null;</span>
<span class="fc" id="L263">            position = -1;</span>
<span class="fc" id="L264">            length = -1;</span>
<span class="fc" id="L265">            patches = null;</span>
<span class="fc" id="L266">        }</span>

        public void appendPatch(final PatchPoint patch)
        {
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (patches == null)</span>
            {
<span class="fc" id="L272">                patches = new PatchList();</span>
            }
<span class="fc" id="L274">            patches.append(patch);</span>
<span class="fc" id="L275">        }</span>

        public void extendPatches(final PatchList newPatches)
        {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            if (patches == null)</span>
            {
<span class="nc" id="L281">                patches = newPatches;</span>
            }
            else
            {
<span class="fc" id="L285">                patches.extend(newPatches);</span>
            }
<span class="fc" id="L287">        }</span>

        public void initialize(final ContainerType type, final long offset) {
<span class="fc" id="L290">            this.type = type;</span>
<span class="fc" id="L291">            this.position = offset;</span>
<span class="fc" id="L292">            this.patches = null;</span>
<span class="fc" id="L293">            this.length = 0;</span>
<span class="fc" id="L294">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L299">            return &quot;(CI &quot; + type + &quot; pos:&quot; + position + &quot; len:&quot; + length + &quot;)&quot;;</span>
        }
    }

    private static class PatchPoint
    {
        /** position of the data being patched out. */
        public final long oldPosition;
        /** length of the data being patched out.*/
        public final int oldLength;
        /** position of the patch buffer where the length data is stored. */
        public final long patchPosition;
        /** length of the data to be patched in.*/
        public final int patchLength;

        public PatchPoint(final long oldPosition, final int oldLength, final long patchPosition, final int patchLength)
<span class="fc" id="L315">        {</span>
<span class="fc" id="L316">            this.oldPosition = oldPosition;</span>
<span class="fc" id="L317">            this.oldLength = oldLength;</span>
<span class="fc" id="L318">            this.patchPosition = patchPosition;</span>
<span class="fc" id="L319">            this.patchLength = patchLength;</span>
<span class="fc" id="L320">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L325">            return &quot;(PP old::(&quot; + oldPosition + &quot; &quot; + oldLength + &quot;) patch::(&quot; + patchPosition + &quot; &quot; + patchLength + &quot;)&quot;;</span>
        }
    }

    /**
     * Simple singly linked list node that we can use to construct the patch list in the
     * right order incrementally in recursive segments.
     */
    private static class PatchList implements Iterable&lt;PatchPoint&gt;
    {
        private static class Node {
            public final PatchPoint value;
            public Node next;

            public Node(final PatchPoint value)
<span class="fc" id="L340">            {</span>
<span class="fc" id="L341">                this.value = value;</span>
<span class="fc" id="L342">            }</span>
        }
        private Node head;
        private Node tail;

        public PatchList()
<span class="fc" id="L348">        {</span>
<span class="fc" id="L349">            head = null;</span>
<span class="fc" id="L350">            tail = null;</span>
<span class="fc" id="L351">        }</span>

        public boolean isEmpty()
        {
<span class="pc bpc" id="L355" title="1 of 4 branches missed.">            return head == null &amp;&amp; tail == null;</span>
        }

        public void clear()
        {
<span class="fc" id="L360">            head = null;</span>
<span class="fc" id="L361">            tail = null;</span>
<span class="fc" id="L362">        }</span>

        public void append(final PatchPoint patch)
        {
<span class="fc" id="L366">            final Node node = new Node(patch);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (head == null)</span>
            {
<span class="fc" id="L369">                head = node;</span>
<span class="fc" id="L370">                tail = node;</span>
            }
            else
            {
<span class="fc" id="L374">                tail.next = node;</span>
<span class="fc" id="L375">                tail = node;</span>
            }
<span class="fc" id="L377">        }</span>

        public void extend(final PatchList end)
        {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            if (end != null)</span>
            {
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                if (head == null)</span>
                {
<span class="nc bnc" id="L385" title="All 2 branches missed.">                    if (end.head != null)</span>
                    {
<span class="nc" id="L387">                        head = end.head;</span>
<span class="nc" id="L388">                        tail = end.tail;</span>
                    }
                }
                else
                {
<span class="fc" id="L393">                    tail.next = end.head;</span>
<span class="fc" id="L394">                    tail = end.tail;</span>
                }
            }
<span class="fc" id="L397">        }</span>

        public PatchPoint truncate(final long oldPosition)
        {
<span class="fc" id="L401">            Node prev = null;</span>
<span class="fc" id="L402">            Node curr = head;</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            while (curr != null)</span>
            {
<span class="fc" id="L405">                final PatchPoint patch = curr.value;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                if (patch.oldPosition &gt;= oldPosition)</span>
                {
<span class="fc" id="L408">                    tail = prev;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                    if (tail == null)</span>
                    {
<span class="fc" id="L411">                        head = null;</span>
                    }
                    else
                    {
<span class="fc" id="L415">                        tail.next = null;</span>
                    }
<span class="fc" id="L417">                    return patch;</span>
                }

<span class="fc" id="L420">                prev = curr;</span>
<span class="fc" id="L421">                curr = curr.next;</span>
<span class="fc" id="L422">            }</span>
<span class="fc" id="L423">            return null;</span>
        }

        public Iterator&lt;PatchPoint&gt; iterator()
        {
<span class="fc" id="L428">            return new Iterator&lt;PatchPoint&gt;()</span>
<span class="fc" id="L429">            {</span>
<span class="fc" id="L430">                Node curr = head;</span>

                public boolean hasNext()
                {
<span class="fc bfc" id="L434" title="All 2 branches covered.">                    return curr != null;</span>
                }

                public PatchPoint next()
                {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">                    if (!hasNext())</span>
                    {
<span class="nc" id="L441">                        throw new NoSuchElementException();</span>
                    }
<span class="fc" id="L443">                    final PatchPoint value = curr.value;</span>
<span class="fc" id="L444">                    curr = curr.next;</span>
<span class="fc" id="L445">                    return value;</span>
                }

                public void remove()
                {
<span class="nc" id="L450">                    throw new UnsupportedOperationException();</span>
                }
            };
        }

        @Override
        public String toString()
        {
<span class="nc" id="L458">            final StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L459">            buf.append(&quot;(PATCHES&quot;);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            for (final PatchPoint patch : this)</span>
            {
<span class="nc" id="L462">                buf.append(&quot; &quot;);</span>
<span class="nc" id="L463">                buf.append(patch);</span>
<span class="nc" id="L464">            }</span>
<span class="nc" id="L465">            buf.append(&quot;)&quot;);</span>
<span class="nc" id="L466">            return buf.toString();</span>
        }
    }

<span class="fc" id="L470">    /*package*/ enum StreamCloseMode</span>
    {
<span class="fc" id="L472">        NO_CLOSE,</span>
<span class="fc" id="L473">        CLOSE</span>
    }

<span class="fc" id="L476">    /*package*/ enum StreamFlushMode</span>
    {
<span class="fc" id="L478">        NO_FLUSH,</span>
<span class="fc" id="L479">        FLUSH</span>
    }

    /**
     * A stack whose elements are recycled. This can be useful when the stack needs to grow and shrink
     * frequently and has a predictable maximum depth.
     * @param &lt;T&gt; the type of elements stored.
     */
    private static final class RecyclingStack&lt;T&gt; {

        /**
         * Factory for new stack elements.
         * @param &lt;T&gt; the type of element.
         */
        public interface ElementFactory&lt;T&gt; {

            /**
             * @return a new instance.
             */
            T newElement();
        }

        private final List&lt;T&gt; elements;
        private final ElementFactory&lt;T&gt; elementFactory;
        private int currentIndex;
        private T top;

        /**
         * @param initialCapacity the initial capacity of the underlying collection.
         * @param elementFactory the factory used to create a new element on {@link #push()} when the stack has
         *                       not previously grown to the new depth.
         */
<span class="fc" id="L511">        public RecyclingStack(int initialCapacity, ElementFactory&lt;T&gt; elementFactory) {</span>
<span class="fc" id="L512">            elements = new ArrayList&lt;T&gt;(initialCapacity);</span>
<span class="fc" id="L513">            this.elementFactory = elementFactory;</span>
<span class="fc" id="L514">            currentIndex = -1;</span>
<span class="fc" id="L515">            top = null;</span>
<span class="fc" id="L516">        }</span>

        /**
         * Pushes an element onto the top of the stack, instantiating a new element only if the stack has not
         * previously grown to the new depth.
         * @return the element at the top of the stack after the push. This element must be initialized by the caller.
         */
        public T push() {
<span class="fc" id="L524">            currentIndex++;</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">            if (currentIndex &gt;= elements.size()) {</span>
<span class="fc" id="L526">                top = elementFactory.newElement();</span>
<span class="fc" id="L527">                elements.add(top);</span>
            }  else {
<span class="fc" id="L529">                top = elements.get(currentIndex);</span>
            }
<span class="fc" id="L531">            return top;</span>
        }

        /**
         * @return the element at the top of the stack, or null if the stack is empty.
         */
        public T peek() {
<span class="fc" id="L538">            return top;</span>
        }

        /**
         * Pops an element from the stack, retaining a reference to the element so that it can be reused the
         * next time the stack grows to the element's depth.
         * @return the element that was at the top of the stack before the pop, or null if the stack was empty.
         */
        public T pop() {
<span class="fc" id="L547">            T popped = top;</span>
<span class="fc" id="L548">            currentIndex--;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (currentIndex &gt;= 0) {</span>
<span class="fc" id="L550">                top = elements.get(currentIndex);</span>
            } else {
<span class="fc" id="L552">                top = null;</span>
<span class="fc" id="L553">                currentIndex = -1;</span>
            }
<span class="fc" id="L555">            return popped;</span>
        }

        /**
         * @return true if the stack is empty; otherwise, false.
         */
        public boolean isEmpty() {
<span class="fc bfc" id="L562" title="All 2 branches covered.">            return top == null;</span>
        }
    }

    private static final int SID_UNASSIGNED = -1;

    private final BlockAllocator                allocator;
    private final OutputStream                  out;
    private final StreamCloseMode               streamCloseMode;
    private final StreamFlushMode               streamFlushMode;
    private final PreallocationMode             preallocationMode;
    private final boolean                       isFloatBinary32Enabled;
    private final WriteBuffer                   buffer;
    private final WriteBuffer                   patchBuffer;
    private final PatchList                     patchPoints;
    private final RecyclingStack&lt;ContainerInfo&gt; containers;
    private int                                 depth;
    private boolean                             hasWrittenValuesSinceFinished;
    private boolean                             hasWrittenValuesSinceConstructed;

    private int                     currentFieldSid;
    private final List&lt;Integer&gt;     currentAnnotationSids;
    // XXX this is for managed detection of TLV that is a LST--this is easier to track here than at the managed level
    private boolean                     hasTopLevelSymbolTableAnnotation;

    private boolean                     closed;

    /*package*/ IonRawBinaryWriter(final BlockAllocatorProvider provider,
                                   final int blockSize,
                                   final OutputStream out,
                                   final WriteValueOptimization optimization,
                                   final StreamCloseMode streamCloseMode,
                                   final StreamFlushMode streamFlushMode,
                                   final PreallocationMode preallocationMode,
                                   final boolean isFloatBinary32Enabled)
                                   throws IOException
    {
<span class="fc" id="L599">        super(optimization);</span>

<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (out == null) { throw new NullPointerException(); }</span>

<span class="fc" id="L603">        this.allocator         = provider.vendAllocator(blockSize);</span>
<span class="fc" id="L604">        this.out               = out;</span>
<span class="fc" id="L605">        this.streamCloseMode   = streamCloseMode;</span>
<span class="fc" id="L606">        this.streamFlushMode   = streamFlushMode;</span>
<span class="fc" id="L607">        this.preallocationMode = preallocationMode;</span>
<span class="fc" id="L608">        this.isFloatBinary32Enabled = isFloatBinary32Enabled;</span>
<span class="fc" id="L609">        this.buffer            = new WriteBuffer(allocator);</span>
<span class="fc" id="L610">        this.patchBuffer       = new WriteBuffer(allocator);</span>
<span class="fc" id="L611">        this.patchPoints       = new PatchList();</span>
<span class="fc" id="L612">        this.containers        = new RecyclingStack&lt;ContainerInfo&gt;(</span>
            10,
<span class="fc" id="L614">            new RecyclingStack.ElementFactory&lt;ContainerInfo&gt;() {</span>
                public ContainerInfo newElement() {
<span class="fc" id="L616">                    return new ContainerInfo();</span>
                }
            }
        );
<span class="fc" id="L620">        this.depth                            = 0;</span>
<span class="fc" id="L621">        this.hasWrittenValuesSinceFinished    = false;</span>
<span class="fc" id="L622">        this.hasWrittenValuesSinceConstructed = false;</span>

<span class="fc" id="L624">        this.currentFieldSid                  = SID_UNASSIGNED;</span>
<span class="fc" id="L625">        this.currentAnnotationSids            = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L626">        this.hasTopLevelSymbolTableAnnotation = false;</span>

<span class="fc" id="L628">        this.closed = false;</span>
<span class="fc" id="L629">    }</span>

    /** Always returns {@link Symbols#systemSymbolTable()}. */
    public SymbolTable getSymbolTable()
    {
<span class="nc" id="L634">        return Symbols.systemSymbolTable();</span>
    }

    // Current Value Meta

    public void setFieldName(final String name)
    {
<span class="nc" id="L641">        throw new UnsupportedOperationException(&quot;Cannot set field name on a low-level binary writer via string&quot;);</span>
    }

    public void setFieldNameSymbol(final SymbolToken name)
    {
<span class="fc" id="L646">        setFieldNameSymbol(name.getSid());</span>
<span class="fc" id="L647">    }</span>

    public void setFieldNameSymbol(int sid)
    {
<span class="fc bfc" id="L651" title="All 2 branches covered.">        if (!isInStruct())</span>
        {
<span class="fc" id="L653">            throw new IonException(&quot;Cannot set field name outside of struct context&quot;);</span>
        }
<span class="fc" id="L655">        currentFieldSid = sid;</span>
<span class="fc" id="L656">    }</span>

    public void setTypeAnnotations(final String... annotations)
    {
<span class="nc" id="L660">        throw new UnsupportedOperationException(&quot;Cannot set annotations on a low-level binary writer via string&quot;);</span>
    }

    private void clearAnnotations()
    {
<span class="fc" id="L665">        currentAnnotationSids.clear();</span>
<span class="fc" id="L666">        hasTopLevelSymbolTableAnnotation = false;</span>
<span class="fc" id="L667">    }</span>

    public void setTypeAnnotationSymbols(final SymbolToken... annotations)
    {
<span class="fc" id="L671">        clearAnnotations();</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">        if (annotations != null)</span>
        {
<span class="fc bfc" id="L674" title="All 2 branches covered.">            for (final SymbolToken annotation : annotations)</span>
            {
<span class="fc" id="L676">                addTypeAnnotationSymbol(annotation.getSid());</span>
            }
        }
<span class="fc" id="L679">    }</span>

    public void setTypeAnnotationSymbols(int... sids)
    {
<span class="fc" id="L683">        clearAnnotations();</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if (sids != null)</span>
        {
<span class="fc bfc" id="L686" title="All 2 branches covered.">            for (final int sid : sids)</span>
            {
<span class="fc" id="L688">                addTypeAnnotationSymbol(sid);</span>
            }
        }
<span class="fc" id="L691">    }</span>

    public void addTypeAnnotation(final String annotation)
    {
<span class="nc" id="L695">        throw new UnsupportedOperationException(&quot;Cannot add annotations on a low-level binary writer via string&quot;);</span>
    }

    // Additional Current State Meta

    /*package*/ void addTypeAnnotationSymbol(final SymbolToken annotation)
    {
<span class="fc" id="L702">        addTypeAnnotationSymbol(annotation.getSid());</span>

<span class="fc" id="L704">    }</span>

    public void addTypeAnnotationSymbol(int sid)
    {
<span class="fc bfc" id="L708" title="All 4 branches covered.">        if (depth == 0 &amp;&amp; sid == ION_SYMBOL_TABLE_SID)</span>
        {
<span class="fc" id="L710">            hasTopLevelSymbolTableAnnotation = true;</span>
        }
<span class="fc" id="L712">        currentAnnotationSids.add(sid);</span>
<span class="fc" id="L713">    }</span>

    /*package*/ boolean hasAnnotations()
    {
<span class="fc bfc" id="L717" title="All 2 branches covered.">        return !currentAnnotationSids.isEmpty();</span>
    }

    /** Returns true if a value has been written since construction or {@link #finish()}. */
    /*package*/ boolean hasWrittenValuesSinceFinished()
    {
<span class="fc" id="L723">        return hasWrittenValuesSinceFinished;</span>
    }

    /** Returns true if a value has been written since the writer was constructed. */
    /*package*/ boolean hasWrittenValuesSinceConstructed()
    {
<span class="nc" id="L729">        return hasWrittenValuesSinceConstructed;</span>
    }

    /*package*/ boolean hasTopLevelSymbolTableAnnotation()
    {
<span class="fc" id="L734">        return hasTopLevelSymbolTableAnnotation;</span>
    }

    /*package*/ int getFieldId()
    {
<span class="fc" id="L739">        return currentFieldSid;</span>
    }

    // Compatibility with Implementation Writer Interface

    public IonCatalog getCatalog()
    {
<span class="nc" id="L746">        throw new UnsupportedOperationException();</span>
    }

    public boolean isFieldNameSet()
    {
<span class="fc bfc" id="L751" title="All 2 branches covered.">        return currentFieldSid &gt; SID_UNASSIGNED;</span>
    }

    public void writeIonVersionMarker() throws IOException
    {
<span class="fc" id="L756">        buffer.writeBytes(IVM);</span>
<span class="fc" id="L757">    }</span>

    public int getDepth()
    {
<span class="fc" id="L761">        return depth;</span>
    }

    // Low-Level Writing

    private void updateLength(long length)
    {
<span class="fc bfc" id="L768" title="All 2 branches covered.">        if (containers.isEmpty())</span>
        {
<span class="fc" id="L770">            return;</span>
        }

<span class="fc" id="L773">        containers.peek().length += length;</span>
<span class="fc" id="L774">    }</span>

    private void pushContainer(final ContainerType type)
    {
        // XXX we push before writing the type of container
<span class="fc" id="L779">        containers.push().initialize(type, buffer.position() + 1);</span>
<span class="fc" id="L780">    }</span>

    private void addPatchPoint(final long position, final int oldLength, final long value)
    {
        // record the size in a patch buffer
<span class="fc" id="L785">        final long patchPosition = patchBuffer.position();</span>
<span class="fc" id="L786">        final int patchLength = patchBuffer.writeVarUInt(value);</span>
<span class="fc" id="L787">        final PatchPoint patch = new PatchPoint(position, oldLength, patchPosition, patchLength);</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if (containers.isEmpty())</span>
        {
            // not nested, just append to the root list
<span class="fc" id="L791">            patchPoints.append(patch);</span>
        }
        else
        {
            // nested, apply it to the current container
<span class="fc" id="L796">            containers.peek().appendPatch(patch);</span>
        }
<span class="fc" id="L798">        updateLength(patchLength - oldLength);</span>
<span class="fc" id="L799">    }</span>

    private void extendPatchPoints(final PatchList patches)
    {
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (containers.isEmpty())</span>
        {
            // not nested, extend root list
<span class="fc" id="L806">            patchPoints.extend(patches);</span>
        }
        else
        {
            // nested, apply it to the current container
<span class="fc" id="L811">            containers.peek().extendPatches(patches);</span>
        }
<span class="fc" id="L813">    }</span>

    private ContainerInfo popContainer()
    {
<span class="fc" id="L817">        final ContainerInfo current = containers.pop();</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">        if (current == null)</span>
        {
<span class="nc" id="L820">            throw new IllegalStateException(&quot;Tried to pop container state without said container&quot;);</span>
        }

        // only patch for real containers and annotations -- we use VALUE for tracking only
<span class="fc" id="L824">        final long length = current.length;</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">        if (current.type != ContainerType.VALUE)</span>
        {
            // patch in the length
<span class="fc" id="L828">            final long position = current.position;</span>
<span class="fc bfc" id="L829" title="All 4 branches covered.">            if (current.length &lt;= preallocationMode.contentMaxLength &amp;&amp; preallocationMode != PreallocationMode.PREALLOCATE_0)</span>
            {
<span class="fc" id="L831">                preallocationMode.patchLength(buffer, position, length);</span>
            }
            else
            {
                // side patch
<span class="pc bpc" id="L836" title="1 of 4 branches missed.">                if (current.length &lt;= 0xD &amp;&amp; preallocationMode == PreallocationMode.PREALLOCATE_0)</span>
                {
                    // XXX if we're not using padding we can get here and optimize the length a little without side patching!
<span class="fc" id="L839">                    final long typePosition = position - 1;</span>
<span class="fc" id="L840">                    final long type = (buffer.getUInt8At(typePosition) &amp; 0xF0) | current.length;</span>
<span class="fc" id="L841">                    buffer.writeUInt8At(typePosition, type);</span>
<span class="fc" id="L842">                }</span>
                else
                {
<span class="fc" id="L845">                    addPatchPoint(position, preallocationMode.typedLength - 1, length);</span>
                }
            }
        }
<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (current.patches != null)</span>
        {
            // at this point, we've appended our patch points upward, lets make sure we get
            // our child patch points in
<span class="fc" id="L853">            extendPatchPoints(current.patches);</span>
        }

        // make sure to record length upward
<span class="fc" id="L857">        updateLength(length);</span>
<span class="fc" id="L858">        return current;</span>
    }

    private void writeVarUInt(final long value)
    {
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">        if (value &lt; 0)</span>
        {
<span class="nc" id="L865">            throw new IonException(&quot;Cannot write negative value as unsigned&quot;);</span>
        }
<span class="fc" id="L867">        final int len = buffer.writeVarUInt(value);</span>
<span class="fc" id="L868">        updateLength(len);</span>
<span class="fc" id="L869">    }</span>

    private void writeVarInt(final long value)
    {
<span class="fc" id="L873">        final int len = buffer.writeVarInt(value);</span>
<span class="fc" id="L874">        updateLength(len);</span>
<span class="fc" id="L875">    }</span>

    private static void checkSid(int sid)
    {
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (sid &lt; 0)</span>
        {
<span class="fc" id="L881">            throw new IllegalArgumentException(&quot;Invalid symbol with SID: &quot; + sid);</span>
        }
<span class="fc" id="L883">    }</span>

    /** prepare to write values with field name and annotations. */
    private void prepareValue()
    {
<span class="fc bfc" id="L888" title="All 4 branches covered.">        if (isInStruct() &amp;&amp; currentFieldSid &lt;= SID_UNASSIGNED)</span>
        {
<span class="fc" id="L890">            throw new IllegalStateException(&quot;IonWriter.setFieldName() must be called before writing a value into a struct.&quot;);</span>
        }
<span class="fc bfc" id="L892" title="All 2 branches covered.">        if (currentFieldSid &gt; SID_UNASSIGNED)</span>
        {
<span class="fc" id="L894">            checkSid(currentFieldSid);</span>
<span class="fc" id="L895">            writeVarUInt(currentFieldSid);</span>

            // clear out field name
<span class="fc" id="L898">            currentFieldSid = SID_UNASSIGNED;</span>
        }
<span class="fc bfc" id="L900" title="All 2 branches covered.">        if (!currentAnnotationSids.isEmpty())</span>
        {
            // we have to push a container context for annotations
<span class="fc" id="L903">            updateLength(preallocationMode.typedLength);</span>
<span class="fc" id="L904">            pushContainer(ContainerType.ANNOTATION);</span>
<span class="fc" id="L905">            buffer.writeBytes(preallocationMode.annotationsTypedPreallocatedBytes);</span>

<span class="fc" id="L907">            final long annotationsLengthPosition = buffer.position();</span>
<span class="fc" id="L908">            buffer.writeVarUInt(0L);</span>
<span class="fc" id="L909">            int annotationsLength = 0;</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">            for (final int symbol : currentAnnotationSids)</span>
            {
<span class="fc" id="L912">                checkSid(symbol);</span>
<span class="fc" id="L913">                final int symbolLength = buffer.writeVarUInt(symbol);</span>
<span class="fc" id="L914">                annotationsLength += symbolLength;</span>
<span class="fc" id="L915">            }</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">            if (annotationsLength &gt; MAX_ANNOTATION_LENGTH)</span>
            {
                // TODO deal with side patching if we want to support &gt; 32 4-byte symbols annotations... seems excessive
<span class="nc" id="L919">                throw new IonException(&quot;Annotations too large: &quot; + currentAnnotationSids);</span>
            }

            // update the annotations size
<span class="fc" id="L923">            updateLength(/*length specifier*/ 1 + annotationsLength);</span>
            // patch the annotations length
<span class="fc" id="L925">            buffer.writeVarUIntDirect1At(annotationsLengthPosition, annotationsLength);</span>

            // clear out annotations
<span class="fc" id="L928">            currentAnnotationSids.clear();</span>
<span class="fc" id="L929">            hasTopLevelSymbolTableAnnotation = false;</span>
        }
<span class="fc" id="L931">    }</span>

    /** Closes out annotations. */
    private void finishValue()
    {
<span class="fc bfc" id="L936" title="All 4 branches covered.">        if (!containers.isEmpty() &amp;&amp; containers.peek().type == ContainerType.ANNOTATION)</span>
        {
            // close out and patch the length
<span class="fc" id="L939">            popContainer();</span>
        }
<span class="fc" id="L941">        hasWrittenValuesSinceFinished = true;</span>
<span class="fc" id="L942">        hasWrittenValuesSinceConstructed = true;</span>
<span class="fc" id="L943">    }</span>

    // Container Manipulation

    public void stepIn(final IonType containerType) throws IOException
    {
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">        if (!isContainer(containerType))</span>
        {
<span class="nc" id="L951">            throw new IonException(&quot;Cannot step into &quot; + containerType);</span>
        }
<span class="fc" id="L953">        prepareValue();</span>
<span class="fc" id="L954">        updateLength(preallocationMode.typedLength);</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">        pushContainer(containerType == STRUCT ? ContainerType.STRUCT : ContainerType.SEQUENCE);</span>
<span class="fc" id="L956">        depth++;</span>
<span class="fc" id="L957">        buffer.writeBytes(preallocationMode.containerTypedPreallocatedBytes[containerType.ordinal()]);</span>
<span class="fc" id="L958">    }</span>

    public void stepOut() throws IOException
    {
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">        if (currentFieldSid &gt; SID_UNASSIGNED)</span>
        {
<span class="nc" id="L964">            throw new IonException(&quot;Cannot step out with field name set&quot;);</span>
        }
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">        if (!currentAnnotationSids.isEmpty())</span>
        {
<span class="nc" id="L968">            throw new IonException(&quot;Cannot step out with field name set&quot;);</span>
        }
<span class="pc bpc" id="L970" title="2 of 4 branches missed.">        if (containers.isEmpty() || !containers.peek().type.allowedInStepOut)</span>
        {
<span class="nc" id="L972">            throw new IonException(&quot;Cannot step out when not in container&quot;);</span>
        }
        // close out the container
<span class="fc" id="L975">        popContainer();</span>
<span class="fc" id="L976">        depth--;</span>
        // close out the annotations if any
<span class="fc" id="L978">        finishValue();</span>
<span class="fc" id="L979">    }</span>

    public boolean isInStruct()
    {
<span class="fc bfc" id="L983" title="All 4 branches covered.">        return !containers.isEmpty() &amp;&amp; containers.peek().type == ContainerType.STRUCT;</span>
    }

    // Write Value Methods

    public void writeNull() throws IOException
    {
<span class="fc" id="L990">        prepareValue();</span>
<span class="fc" id="L991">        updateLength(1);</span>
<span class="fc" id="L992">        buffer.writeByte(NULL_NULL);</span>
<span class="fc" id="L993">        finishValue();</span>
<span class="fc" id="L994">    }</span>

    public void writeNull(final IonType type) throws IOException
    {
<span class="fc" id="L998">        byte data = NULL_NULL;</span>
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">        if (type != null)</span>
        {
<span class="fc" id="L1001">            data = NULLS[type.ordinal()];</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">            if (data == 0)</span>
            {
<span class="nc" id="L1004">                throw new IllegalArgumentException(&quot;Cannot write a null for: &quot; + type);</span>
            }
        }

<span class="fc" id="L1008">        prepareValue();</span>
<span class="fc" id="L1009">        updateLength(1);</span>
<span class="fc" id="L1010">        buffer.writeByte(data);</span>
<span class="fc" id="L1011">        finishValue();</span>
<span class="fc" id="L1012">    }</span>

    public void writeBool(final boolean value) throws IOException
    {
<span class="fc" id="L1016">        prepareValue();</span>
<span class="fc" id="L1017">        updateLength(1);</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (value)</span>
        {
<span class="fc" id="L1020">            buffer.writeByte(BOOL_TRUE);</span>
        }
        else
        {
<span class="fc" id="L1024">            buffer.writeByte(BOOL_FALSE);</span>
        }
<span class="fc" id="L1026">        finishValue();</span>
<span class="fc" id="L1027">    }</span>

    /**
     * Writes a type descriptor followed by unsigned integer value.
     * Does not check for sign.
     * Note that this does not do {@link #prepareValue()} or {@link #finishValue()}.
     */
    private void writeTypedUInt(final int type, final long value)
    {
<span class="fc bfc" id="L1036" title="All 2 branches covered.">        if (value &lt;= 0xFFL)</span>
        {
<span class="fc" id="L1038">            updateLength(2);</span>
<span class="fc" id="L1039">            buffer.writeUInt8(type | 0x01);</span>
<span class="fc" id="L1040">            buffer.writeUInt8(value);</span>
        }
<span class="fc bfc" id="L1042" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFL)</span>
        {
<span class="fc" id="L1044">            updateLength(3);</span>
<span class="fc" id="L1045">            buffer.writeUInt8(type | 0x02);</span>
<span class="fc" id="L1046">            buffer.writeUInt16(value);</span>
        }
<span class="fc bfc" id="L1048" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFL)</span>
        {
<span class="fc" id="L1050">            updateLength(4);</span>
<span class="fc" id="L1051">            buffer.writeUInt8(type | 0x03);</span>
<span class="fc" id="L1052">            buffer.writeUInt24(value);</span>
        }
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFL)</span>
        {
<span class="fc" id="L1056">            updateLength(5);</span>
<span class="fc" id="L1057">            buffer.writeUInt8(type | 0x04);</span>
<span class="fc" id="L1058">            buffer.writeUInt32(value);</span>
        }
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFFFL)</span>
        {
<span class="fc" id="L1062">            updateLength(6);</span>
<span class="fc" id="L1063">            buffer.writeUInt8(type | 0x05);</span>
<span class="fc" id="L1064">            buffer.writeUInt40(value);</span>
        }
<span class="fc bfc" id="L1066" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFFFFFL)</span>
        {
<span class="fc" id="L1068">            updateLength(7);</span>
<span class="fc" id="L1069">            buffer.writeUInt8(type | 0x06);</span>
<span class="fc" id="L1070">            buffer.writeUInt48(value);</span>
        }
<span class="fc bfc" id="L1072" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFFFFFFFL)</span>
        {
<span class="fc" id="L1074">            updateLength(8);</span>
<span class="fc" id="L1075">            buffer.writeUInt8(type | 0x07);</span>
<span class="fc" id="L1076">            buffer.writeUInt56(value);</span>
        }
        else
        {
<span class="fc" id="L1080">            updateLength(9);</span>
<span class="fc" id="L1081">            buffer.writeUInt8(type | 0x08);</span>
<span class="fc" id="L1082">            buffer.writeUInt64(value);</span>
        }
<span class="fc" id="L1084">    }</span>

    public void writeInt(long value) throws IOException
    {
<span class="fc" id="L1088">        prepareValue();</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">        if (value == 0)</span>
        {
<span class="fc" id="L1091">            updateLength(1);</span>
<span class="fc" id="L1092">            buffer.writeByte(INT_ZERO);</span>
        }
        else
        {
<span class="fc" id="L1096">            int type = POS_INT_TYPE;</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">            if (value &lt; 0)</span>
            {
<span class="fc" id="L1099">                type = NEG_INT_TYPE;</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">                if (value == Long.MIN_VALUE)</span>
                {
                    // XXX special case for min_value which will not play nice with signed arithmetic and fit into the positive space
                    // XXX we keep 2's complement of Long.MIN_VALUE because it encodes to unsigned 2 ** 63 (0x8000000000000000L)
                    // XXX WriteBuffer.writeUInt64() never looks at sign
<span class="fc" id="L1105">                    updateLength(9);</span>
<span class="fc" id="L1106">                    buffer.writeUInt8(NEG_INT_TYPE | 0x8);</span>
<span class="fc" id="L1107">                    buffer.writeUInt64(value);</span>
                }
                else
                {
                    // get the magnitude, sign is already encoded
<span class="fc" id="L1112">                    value = -value;</span>
<span class="fc" id="L1113">                    writeTypedUInt(type, value);</span>
                }
            }
            else
            {
<span class="fc" id="L1118">                writeTypedUInt(type, value);</span>
            }
        }
<span class="fc" id="L1121">        finishValue();</span>
<span class="fc" id="L1122">    }</span>

    /** Write a raw byte array as some type. Note that this does not do {@link #prepareValue()}. */
    private void writeTypedBytes(final int type, final byte[] data, final int offset, final int length)
    {
<span class="fc" id="L1127">        int totalLength = 1 + length;</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        if (length &lt; 14)</span>
        {
<span class="fc" id="L1130">            buffer.writeUInt8(type | length);</span>
        }
        else
        {
            // need to specify length explicitly
<span class="fc" id="L1135">            buffer.writeUInt8(type | 0xE);</span>
<span class="fc" id="L1136">            final int sizeLength = buffer.writeVarUInt(length);</span>
<span class="fc" id="L1137">            totalLength += sizeLength;</span>
        }
<span class="fc" id="L1139">        updateLength(totalLength);</span>
<span class="fc" id="L1140">        buffer.writeBytes(data, offset, length);</span>
<span class="fc" id="L1141">    }</span>

    public void writeInt(BigInteger value) throws IOException
    {
<span class="fc bfc" id="L1145" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1147">            writeNull(IonType.INT);</span>
<span class="fc" id="L1148">            return;</span>
        }
<span class="fc bfc" id="L1150" title="All 4 branches covered.">        if (value.compareTo(BIG_INT_LONG_MIN_VALUE) &gt;= 0 &amp;&amp; value.compareTo(BIG_INT_LONG_MAX_VALUE) &lt;= 0)</span>
        {
            // for the small stuff, just write it as a signed int64
<span class="fc" id="L1153">            writeInt(value.longValue());</span>
<span class="fc" id="L1154">            return;</span>
        }

<span class="fc" id="L1157">        prepareValue();</span>

<span class="fc" id="L1159">        int type = POS_INT_TYPE;</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">        if(value.signum() &lt; 0)</span>
        {
<span class="fc" id="L1162">            type = NEG_INT_TYPE;</span>
<span class="fc" id="L1163">            value = value.negate();</span>
        }

        // generate big-endian representation of the positive value
<span class="fc" id="L1167">        final byte[] magnitude = value.toByteArray();</span>
<span class="fc" id="L1168">        writeTypedBytes(type, magnitude, 0, magnitude.length);</span>

<span class="fc" id="L1170">        finishValue();</span>
<span class="fc" id="L1171">    }</span>

    public void writeFloat(final double value) throws IOException
    {
<span class="fc" id="L1175">        prepareValue();</span>

<span class="fc bfc" id="L1177" title="All 4 branches covered.">        if (isFloatBinary32Enabled &amp;&amp; value == ((double) ((float) value))) {</span>
<span class="fc" id="L1178">            updateLength(5);</span>
<span class="fc" id="L1179">            buffer.writeUInt8(FLOAT_TYPE | 4);</span>
<span class="fc" id="L1180">            buffer.writeUInt32(floatToRawIntBits((float) value));</span>
        } else {
<span class="fc" id="L1182">            updateLength(9);</span>
<span class="fc" id="L1183">            buffer.writeUInt8(FLOAT_TYPE | 8);</span>
<span class="fc" id="L1184">            buffer.writeUInt64(doubleToRawLongBits(value));</span>
        }

<span class="fc" id="L1187">        finishValue();</span>
<span class="fc" id="L1188">    }</span>

    /** Encodes a decimal, updating the current container length context (which is probably a Decimal/Timestamp). */
    private void writeDecimalValue(final BigDecimal value)
    {
<span class="fc" id="L1193">        final boolean isNegZero = isNegativeZero(value);</span>
<span class="fc" id="L1194">        final int signum = value.signum();</span>
<span class="fc" id="L1195">        final int exponent = -value.scale();</span>

<span class="fc" id="L1197">        writeVarInt(exponent);</span>

<span class="fc" id="L1199">        final BigInteger mantissaBigInt = value.unscaledValue();</span>
<span class="fc bfc" id="L1200" title="All 4 branches covered.">        if (mantissaBigInt.compareTo(BIG_INT_LONG_MIN_VALUE) &gt;= 0 &amp;&amp; mantissaBigInt.compareTo(BIG_INT_LONG_MAX_VALUE) &lt;= 0)</span>
        {
            // we can fit into the long space
<span class="fc" id="L1203">            final long mantissa = mantissaBigInt.longValue();</span>
<span class="fc bfc" id="L1204" title="All 4 branches covered.">            if (signum == 0 &amp;&amp; !isNegZero)</span>
            {
                // positive zero does not need to be encoded
            }
<span class="fc bfc" id="L1208" title="All 2 branches covered.">            else if (isNegZero)</span>
            {
                // XXX special case for negative zero, we have to encode as a signed zero in the Int format
<span class="fc" id="L1211">                updateLength(1);</span>
<span class="fc" id="L1212">                buffer.writeByte(DECIMAL_NEGATIVE_ZERO_MANTISSA);</span>
            }
<span class="fc bfc" id="L1214" title="All 2 branches covered.">            else if (mantissa == Long.MIN_VALUE)</span>
            {
                // XXX special case for min value -- we need 64-bits to store the magnitude and we need a bit for sign
<span class="fc" id="L1217">                updateLength(9);</span>
<span class="fc" id="L1218">                buffer.writeUInt8(0x80);</span>
<span class="fc" id="L1219">                buffer.writeUInt64(mantissa);</span>
            }
<span class="fc bfc" id="L1221" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFFFFFFFF81L &amp;&amp; mantissa &lt;= 0x000000000000007FL)</span>
            {
<span class="fc" id="L1223">                updateLength(1);</span>
<span class="fc" id="L1224">                buffer.writeInt8(mantissa);</span>
            }
<span class="fc bfc" id="L1226" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFFFFFF8001L &amp;&amp; mantissa &lt;= 0x0000000000007FFFL)</span>
            {
<span class="fc" id="L1228">                updateLength(2);</span>
<span class="fc" id="L1229">                buffer.writeInt16(mantissa);</span>
            }
<span class="fc bfc" id="L1231" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFFFF800001L &amp;&amp; mantissa &lt;= 0x00000000007FFFFFL)</span>
            {
<span class="fc" id="L1233">                updateLength(3);</span>
<span class="fc" id="L1234">                buffer.writeInt24(mantissa);</span>
            }
<span class="fc bfc" id="L1236" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFF80000001L &amp;&amp; mantissa &lt;= 0x000000007FFFFFFFL)</span>
            {
<span class="fc" id="L1238">                updateLength(4);</span>
<span class="fc" id="L1239">                buffer.writeInt32(mantissa);</span>
            }
<span class="fc bfc" id="L1241" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFF8000000001L &amp;&amp; mantissa &lt;= 0x0000007FFFFFFFFFL)</span>
            {
<span class="fc" id="L1243">                updateLength(5);</span>
<span class="fc" id="L1244">                buffer.writeInt40(mantissa);</span>
            }
<span class="fc bfc" id="L1246" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFF800000000001L &amp;&amp; mantissa &lt;= 0x00007FFFFFFFFFFFL)</span>
            {
<span class="fc" id="L1248">                updateLength(6);</span>
<span class="fc" id="L1249">                buffer.writeInt48(mantissa);</span>
            }
<span class="fc bfc" id="L1251" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFF80000000000001L &amp;&amp; mantissa &lt;= 0x007FFFFFFFFFFFFFL)</span>
            {
<span class="fc" id="L1253">                updateLength(7);</span>
<span class="fc" id="L1254">                buffer.writeInt56(mantissa);</span>
            }
            else
            {
                // TODO consider being more space efficient for integers that can be written with 6/7 bytes.
<span class="fc" id="L1259">                updateLength(8);</span>
<span class="fc" id="L1260">                buffer.writeInt64(mantissa);</span>
            }
<span class="fc" id="L1262">        }</span>
        else
        {
<span class="fc bfc" id="L1265" title="All 2 branches covered.">            final BigInteger magnitude = signum &gt; 0 ? mantissaBigInt : mantissaBigInt.negate();</span>
<span class="fc" id="L1266">            final byte[] bits = magnitude.toByteArray();</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">            if (signum &lt; 0)</span>
            {
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">                if ((bits[0] &amp; 0x80) == 0)</span>
                {
<span class="fc" id="L1271">                    bits[0] |= 0x80;</span>
                }
                else
                {
                    // not enough space in the bits to store the negative sign
<span class="nc" id="L1276">                    updateLength(1);</span>
<span class="nc" id="L1277">                    buffer.writeUInt8(0x80);</span>
                }
            }
<span class="fc" id="L1280">            updateLength(bits.length);</span>
<span class="fc" id="L1281">            buffer.writeBytes(bits);</span>
        }
<span class="fc" id="L1283">    }</span>

    private void patchSingleByteTypedOptimisticValue(final byte type, final ContainerInfo info)
    {
<span class="fc bfc" id="L1287" title="All 2 branches covered.">        if (info.length &lt;= 0xD)</span>
        {
            // we fit -- overwrite the type byte
<span class="fc" id="L1290">            buffer.writeUInt8At(info.position - 1, type | info.length);</span>
        }
        else
        {
            // side patch
<span class="fc" id="L1295">            buffer.writeUInt8At(info.position - 1, type | 0xE);</span>
<span class="fc" id="L1296">            addPatchPoint(info.position, 0, info.length);</span>
        }
<span class="fc" id="L1298">    }</span>

    public void writeDecimal(final BigDecimal value) throws IOException
    {
<span class="fc bfc" id="L1302" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1304">            writeNull(IonType.DECIMAL);</span>
<span class="fc" id="L1305">            return;</span>
        }

<span class="fc" id="L1308">        prepareValue();</span>

<span class="fc bfc" id="L1310" title="All 6 branches covered.">        if (value.signum() == 0 &amp;&amp; value.scale() == 0 &amp;&amp; !isNegativeZero(value))</span>
        {
            // 0d0 can be written in one byte
<span class="fc" id="L1313">            updateLength(1);</span>
<span class="fc" id="L1314">            buffer.writeUInt8(DECIMAL_POS_ZERO);</span>
        }
        else
        {
            // optimistically try to fit decimal length in low nibble (most should)
<span class="fc" id="L1319">            updateLength(1);</span>
<span class="fc" id="L1320">            pushContainer(ContainerType.VALUE);</span>
<span class="fc" id="L1321">            buffer.writeByte(DECIMAL_TYPE);</span>
<span class="fc" id="L1322">            writeDecimalValue(value);</span>
<span class="fc" id="L1323">            final ContainerInfo info = popContainer();</span>
<span class="fc" id="L1324">            patchSingleByteTypedOptimisticValue(DECIMAL_TYPE, info);</span>
        }

<span class="fc" id="L1327">        finishValue();</span>
<span class="fc" id="L1328">    }</span>

    public void writeTimestamp(final Timestamp value) throws IOException
    {
<span class="fc bfc" id="L1332" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1334">            writeNull(IonType.TIMESTAMP);</span>
<span class="fc" id="L1335">            return;</span>
        }
<span class="fc" id="L1337">        prepareValue();</span>

        // optimistically try to fit a timestamp length in low nibble (most should)
<span class="fc" id="L1340">        updateLength(1);</span>
<span class="fc" id="L1341">        pushContainer(ContainerType.VALUE);</span>
<span class="fc" id="L1342">        buffer.writeByte(TIMESTAMP_TYPE);</span>

        // OFFSET
<span class="fc" id="L1345">        final Integer offset = value.getLocalOffset();</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        if (offset == null)</span>
        {
            // special case for unknown -00:00
<span class="fc" id="L1349">            updateLength(1);</span>
<span class="fc" id="L1350">            buffer.writeByte(VARINT_NEG_ZERO);</span>
        }
        else
        {
<span class="fc" id="L1354">            writeVarInt(offset.intValue());</span>
        }

        // YEAR
<span class="fc" id="L1358">        final int year = value.getZYear();</span>
<span class="fc" id="L1359">        writeVarUInt(year);</span>

        // XXX it is really convenient to rely on the ordinal
<span class="fc" id="L1362">        final int precision = value.getPrecision().ordinal();</span>

<span class="fc bfc" id="L1364" title="All 2 branches covered.">        if (precision &gt;= MONTH.ordinal())</span>
        {
<span class="fc" id="L1366">            final int month = value.getZMonth();</span>
<span class="fc" id="L1367">            writeVarUInt(month);</span>
        }
<span class="fc bfc" id="L1369" title="All 2 branches covered.">        if (precision &gt;= DAY.ordinal())</span>
        {
<span class="fc" id="L1371">            final int day = value.getZDay();</span>
<span class="fc" id="L1372">            writeVarUInt(day);</span>
        }
<span class="fc bfc" id="L1374" title="All 2 branches covered.">        if (precision &gt;= MINUTE.ordinal())</span>
        {
<span class="fc" id="L1376">            final int hour = value.getZHour();</span>
<span class="fc" id="L1377">            writeVarUInt(hour);</span>
<span class="fc" id="L1378">            final int minute = value.getZMinute();</span>
<span class="fc" id="L1379">            writeVarUInt(minute);</span>
        }
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        if (precision &gt;= SECOND.ordinal())</span>
        {
<span class="fc" id="L1383">            final int second = value.getZSecond();</span>
<span class="fc" id="L1384">            writeVarUInt(second);</span>
<span class="fc" id="L1385">            final BigDecimal fraction = value.getZFractionalSecond();</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">            if (fraction != null) {</span>
<span class="fc" id="L1387">                final BigInteger mantissaBigInt = fraction.unscaledValue();</span>
<span class="fc" id="L1388">                final int exponent = -fraction.scale();</span>
<span class="fc bfc" id="L1389" title="All 4 branches covered.">                if (!(mantissaBigInt.equals(BigInteger.ZERO) &amp;&amp; exponent &gt; -1)) {</span>
<span class="fc" id="L1390">                    writeDecimalValue(fraction);</span>
                }
            }
        }

<span class="fc" id="L1395">        final ContainerInfo info = popContainer();</span>
<span class="fc" id="L1396">        patchSingleByteTypedOptimisticValue(TIMESTAMP_TYPE, info);</span>

<span class="fc" id="L1398">        finishValue();</span>
<span class="fc" id="L1399">    }</span>

    public void writeSymbol(String content) throws IOException
    {
<span class="nc" id="L1403">        throw new UnsupportedOperationException(&quot;Symbol writing via string is not supported in low-level binary writer&quot;);</span>
    }

    public void writeSymbolToken(final SymbolToken content) throws IOException
    {
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        if (content == null)</span>
        {
<span class="fc" id="L1410">            writeNull(IonType.SYMBOL);</span>
<span class="fc" id="L1411">            return;</span>
        }
<span class="fc" id="L1413">        writeSymbolToken(content.getSid());</span>
<span class="fc" id="L1414">    }</span>

    boolean isIVM(int sid)
    {
        // When SID 2 occurs at the top level with no annotations, it has the
        // special properties of an IVM. Otherwise, it's considered a normal
        // symbol value.
        // TODO amzn/ion-java/issues/88 requires this behavior to be changed,
        // such that top-level SID 2 is treated as a symbol value, not an IVM.
<span class="fc bfc" id="L1423" title="All 6 branches covered.">        return depth == 0 &amp;&amp; sid == ION_1_0_SID &amp;&amp; !hasAnnotations();</span>
    }

    public void writeSymbolToken(int sid) throws IOException
    {
<span class="fc bfc" id="L1428" title="All 2 branches covered.">        if (isIVM(sid))</span>
        {
<span class="fc" id="L1430">            throw new IonException(&quot;Direct writing of IVM is not supported in low-level binary writer&quot;);</span>
        }
<span class="fc" id="L1432">        checkSid(sid);</span>
<span class="fc" id="L1433">        prepareValue();</span>
<span class="fc" id="L1434">        writeTypedUInt(SYMBOL_TYPE, sid);</span>
<span class="fc" id="L1435">        finishValue();</span>
<span class="fc" id="L1436">    }</span>

    public void writeString(final String value) throws IOException
    {
<span class="fc bfc" id="L1440" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1442">            writeNull(IonType.STRING);</span>
<span class="fc" id="L1443">            return;</span>
        }
<span class="fc" id="L1445">        prepareValue();</span>

        /*
         This method relies on the standard CharsetEncoder class to encode each String's UTF-16 char[] data into
         UTF-8 bytes. Strangely, CharsetEncoders cannot operate directly on instances of a String. The CharsetEncoder
         API requires all inputs and outputs to be specified as instances of java.nio.ByteBuffer and
         java.nio.CharBuffer, making some number of allocations mandatory. Specifically, for each encoding operation
         we need to have:

            1. An instance of a UTF-8 CharsetEncoder.
            2. A CharBuffer representation of the String's data.
            3. A ByteBuffer into which the CharsetEncoder may write UTF-8 bytes.

         To minimize the overhead involved, the IonRawBinaryWriter will reuse previously initialized resources wherever
         possible. However, because CharBuffer and ByteBuffer each have a fixed length, we can only reuse them for
         Strings that are small enough to fit. This creates two kinds of input String to encode: those that are small
         enough for us to reuse our buffers, and those which are not.

         Further benchmarking shows that there is also a third kind: Strings which are small enough to enable additional
         aggressive optimizations. The JIT can eliminate heap allocations for scalar arrays (e.g. byte[], char[])
         that have no more than than a configurable number of elements (default: 64), opting to place them on the stack
         instead. (This threshold be can be overridden with the -XX:EliminateAllocationArraySizeLimit=N JVM flag, but
         this is neither common nor recommended.) When encoding small strings, requesting new buffers will cause those
         buffers to be allocated on the stack instead of on the heap. And, because these buffers only exist for the
         duration of the encoding method call (i.e. they are neither returned from the method nor stored in a member
         field), the JIT is able to selectively eliminate costly superfluous steps like defensive array copying. For
         more details, see the JDK's documentation on Escape Analysis[1].

         The String#getBytes(Charset) method cannot be used for two reasons:

               1. It always allocates, so we cannot reuse any resources.
               2. If/when it encounters character data that cannot be encoded as UTF-8, it simply replaces that data
                 with a substitute character[2]. (Sometimes seen in applications as a '?'.) In order
                 to surface invalid data to the user, the method must be able to detect these events at encoding time.

            [1] https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis
            [2] https://en.wikipedia.org/wiki/Substitute_character
        */

        CharBuffer stringData;
        ByteBuffer encodingBuffer;

<span class="fc" id="L1487">        int length = value.length();</span>

        // While it is possible to encode the Ion string using a fixed-size encodingBuffer, we need to be able to
        // write the length of the complete UTF-8 string to the output stream before we write the string itself.
        // For simplicity, we reuse or create an encodingBuffer that is large enough to hold the full string.

        // In order to encode the input String, we need to pass it to CharsetEncoder as an implementation of CharBuffer.
        // Surprisingly, the intuitive way to achieve this (the CharBuffer#wrap(CharSequence) method) adds a large
        // amount of CPU overhead to the encoding process. Benchmarking shows that it's substantially faster
        // to use String#getChars(int, int, char[], int) to copy the String's backing array and then call
        // CharBuffer#wrap(char[]) on the copy.

<span class="fc bfc" id="L1499" title="All 4 branches covered.">        if (length &lt;= SMALL_STRING_SIZE || length &gt; MEDIUM_STRING_SIZE) {</span>
            // Small strings and large Strings both request fresh buffers.
<span class="fc" id="L1501">            encodingBuffer = ByteBuffer.allocate((int) (value.length() * utf8Encoder.maxBytesPerChar()));</span>
<span class="fc" id="L1502">            char[] chars = new char[value.length()];</span>
<span class="fc" id="L1503">            value.getChars(0, value.length(), chars, 0);</span>
<span class="fc" id="L1504">            stringData = CharBuffer.wrap(chars);</span>
<span class="fc" id="L1505">        } else {</span>
            // Medium-sized strings are encoded using our reusable buffers.
<span class="fc" id="L1507">            encodingBuffer = utf8EncodingBuffer;</span>
<span class="fc" id="L1508">            encodingBuffer.position(0);</span>
<span class="fc" id="L1509">            encodingBuffer.limit(encodingBuffer.capacity());</span>
<span class="fc" id="L1510">            stringData = reusableCharBuffer;</span>
<span class="fc" id="L1511">            value.getChars(0, value.length(), charArray, 0);</span>
<span class="fc" id="L1512">            reusableCharBuffer.position(0);</span>
<span class="fc" id="L1513">            reusableCharBuffer.limit(value.length());</span>
        }

        // Because encodingBuffer is guaranteed to be large enough to hold the encoded string, we can
        // perform the encoding in a single call to CharsetEncoder#encode(CharBuffer, ByteBuffer, boolean).
<span class="fc" id="L1518">        CoderResult coderResult = utf8Encoder.encode(stringData, encodingBuffer, true);</span>

        // 'Underflow' is the success state of a CoderResult.
<span class="fc bfc" id="L1521" title="All 2 branches covered.">        if (!coderResult.isUnderflow()) {</span>
<span class="fc" id="L1522">            throw new IllegalArgumentException(&quot;Could not encode string as UTF8 bytes: &quot; + value);</span>
        }
<span class="fc" id="L1524">        encodingBuffer.flip();</span>
<span class="fc" id="L1525">        int utf8Length = encodingBuffer.remaining();</span>

        // Write the type and length codes to the output stream.
<span class="fc" id="L1528">        long previousPosition = buffer.position();</span>
<span class="fc bfc" id="L1529" title="All 2 branches covered.">        if (utf8Length &lt;= 0xD) {</span>
<span class="fc" id="L1530">            buffer.writeUInt8(STRING_TYPE | utf8Length);</span>
        } else {
<span class="fc" id="L1532">            buffer.writeUInt8(STRING_TYPE | 0xE);</span>
<span class="fc" id="L1533">            buffer.writeVarUInt(utf8Length);</span>
        }

        // Write the encoded UTF-8 bytes to the output stream
<span class="fc" id="L1537">        buffer.writeBytes(encodingBuffer.array(), 0, utf8Length);</span>

<span class="fc" id="L1539">        long bytesWritten = buffer.position() - previousPosition;</span>
<span class="fc" id="L1540">        updateLength(bytesWritten);</span>

<span class="fc" id="L1542">        finishValue();</span>
<span class="fc" id="L1543">    }</span>

    public void writeClob(byte[] data) throws IOException
    {
<span class="fc bfc" id="L1547" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1549">            writeNull(IonType.CLOB);</span>
<span class="fc" id="L1550">            return;</span>
        }
<span class="fc" id="L1552">        writeClob(data, 0, data.length);</span>
<span class="fc" id="L1553">    }</span>

    public void writeClob(final byte[] data, final int offset, final int length) throws IOException
    {
<span class="fc bfc" id="L1557" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1559">            writeNull(IonType.CLOB);</span>
<span class="fc" id="L1560">            return;</span>
        }
<span class="fc" id="L1562">        prepareValue();</span>
<span class="fc" id="L1563">        writeTypedBytes(CLOB_TYPE, data, offset, length);</span>
<span class="fc" id="L1564">        finishValue();</span>
<span class="fc" id="L1565">    }</span>

    public void writeBlob(byte[] data) throws IOException
    {
<span class="fc bfc" id="L1569" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1571">            writeNull(IonType.BLOB);</span>
<span class="fc" id="L1572">            return;</span>
        }
<span class="fc" id="L1574">        writeBlob(data, 0, data.length);</span>
<span class="fc" id="L1575">    }</span>

    public void writeBlob(final byte[] data, final int offset, final int length) throws IOException
    {
<span class="fc bfc" id="L1579" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1581">            writeNull(IonType.BLOB);</span>
<span class="fc" id="L1582">            return;</span>
        }
<span class="fc" id="L1584">        prepareValue();</span>
<span class="fc" id="L1585">        writeTypedBytes(BLOB_TYPE, data, offset, length);</span>
<span class="fc" id="L1586">        finishValue();</span>
<span class="fc" id="L1587">    }</span>

    @Override
    public void writeString(byte[] data, int offset, int length) throws IOException
    {
<span class="fc bfc" id="L1592" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1594">            writeNull(IonType.STRING);</span>
<span class="fc" id="L1595">            return;</span>
        }
<span class="fc" id="L1597">        prepareValue();</span>
<span class="fc" id="L1598">        writeTypedBytes(STRING_TYPE, data, offset, length);</span>
<span class="fc" id="L1599">        finishValue();</span>
<span class="fc" id="L1600">    }</span>

    /**
     * Writes a raw value into the buffer, updating lengths appropriately.
     * &lt;p&gt;
     * The implication here is that the caller is dumping some valid Ion payload with the correct context.
     */
    public void writeBytes(byte[] data, int offset, int length) throws IOException
    {
<span class="fc" id="L1609">        prepareValue();</span>
<span class="fc" id="L1610">        updateLength(length);</span>
<span class="fc" id="L1611">        buffer.writeBytes(data, offset, length);</span>
<span class="fc" id="L1612">        finishValue();</span>
<span class="fc" id="L1613">    }</span>

    // Stream Manipulation/Terminators

    /*package*/ long position()
    {
<span class="fc" id="L1619">        return buffer.position();</span>
    }

    /*package*/ void truncate(long position)
    {
<span class="fc" id="L1624">        buffer.truncate(position);</span>
        // TODO decide if it is worth making this faster than O(N)
<span class="fc" id="L1626">        final PatchPoint patch = patchPoints.truncate(position);</span>
<span class="fc bfc" id="L1627" title="All 2 branches covered.">        if (patch != null)</span>
        {
<span class="fc" id="L1629">            patchBuffer.truncate(patch.patchPosition);</span>
        }
<span class="fc" id="L1631">    }</span>

<span class="nc" id="L1633">    public void flush() throws IOException {}</span>

    public void finish() throws IOException
    {
<span class="fc bfc" id="L1637" title="All 2 branches covered.">        if (closed)</span>
        {
<span class="fc" id="L1639">            return;</span>
        }
<span class="pc bpc" id="L1641" title="1 of 4 branches missed.">        if (!containers.isEmpty() || depth &gt; 0)</span>
        {
<span class="fc" id="L1643">            throw new IllegalStateException(&quot;Cannot finish within container: &quot; + containers);</span>
        }

<span class="fc bfc" id="L1646" title="All 2 branches covered.">        if (patchPoints.isEmpty())</span>
        {
            // nothing to patch--write 'em out!
<span class="fc" id="L1649">            buffer.writeTo(out);</span>
        }
        else
        {
<span class="fc" id="L1653">            long bufferPosition = 0;</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">            for (final PatchPoint patch : patchPoints)</span>
            {
                // write up to the thing to be patched
<span class="fc" id="L1657">                final long bufferLength = patch.oldPosition - bufferPosition;</span>
<span class="fc" id="L1658">                buffer.writeTo(out, bufferPosition, bufferLength);</span>

                // write out the patch
<span class="fc" id="L1661">                patchBuffer.writeTo(out, patch.patchPosition, patch.patchLength);</span>

                // skip over the preallocated varuint field
<span class="fc" id="L1664">                bufferPosition = patch.oldPosition;</span>
<span class="fc" id="L1665">                bufferPosition += patch.oldLength;</span>
<span class="fc" id="L1666">            }</span>
<span class="fc" id="L1667">            buffer.writeTo(out, bufferPosition, buffer.position() - bufferPosition);</span>
        }
<span class="fc" id="L1669">        patchPoints.clear();</span>
<span class="fc" id="L1670">        patchBuffer.reset();</span>
<span class="fc" id="L1671">        buffer.reset();</span>

<span class="fc bfc" id="L1673" title="All 2 branches covered.">        if (streamFlushMode == StreamFlushMode.FLUSH)</span>
        {
<span class="fc" id="L1675">            out.flush();</span>
        }

<span class="fc" id="L1678">        hasWrittenValuesSinceFinished = false;</span>
<span class="fc" id="L1679">    }</span>

    public void close() throws IOException
    {
<span class="fc bfc" id="L1683" title="All 2 branches covered.">        if (closed)</span>
        {
<span class="fc" id="L1685">            return;</span>
        }
        try
        {
            try
            {
<span class="fc" id="L1691">                finish();</span>
            }
<span class="fc" id="L1693">            catch (final IllegalStateException e)</span>
            {
                // callers don't expect this...
<span class="fc" id="L1696">            }</span>

            // release all of our blocks -- these should never throw
<span class="fc" id="L1699">            buffer.close();</span>
<span class="fc" id="L1700">            patchBuffer.close();</span>
<span class="fc" id="L1701">            allocator.close();</span>
        }
        finally
        {
<span class="fc" id="L1705">            closed = true;</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">            if (streamCloseMode == StreamCloseMode.CLOSE)</span>
            {
                // release the stream
<span class="fc" id="L1709">                out.close();</span>
            }
        }
<span class="fc" id="L1712">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>