<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonRawBinaryWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl.bin</a> &gt; <span class="el_source">IonRawBinaryWriter.java</span></div><h1>IonRawBinaryWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl.bin;

import static com.amazon.ion.Decimal.isNegativeZero;
import static com.amazon.ion.IonType.BLOB;
import static com.amazon.ion.IonType.BOOL;
import static com.amazon.ion.IonType.CLOB;
import static com.amazon.ion.IonType.DECIMAL;
import static com.amazon.ion.IonType.FLOAT;
import static com.amazon.ion.IonType.INT;
import static com.amazon.ion.IonType.LIST;
import static com.amazon.ion.IonType.NULL;
import static com.amazon.ion.IonType.SEXP;
import static com.amazon.ion.IonType.STRING;
import static com.amazon.ion.IonType.STRUCT;
import static com.amazon.ion.IonType.SYMBOL;
import static com.amazon.ion.IonType.TIMESTAMP;
import static com.amazon.ion.IonType.isContainer;
import static com.amazon.ion.SystemSymbols.ION_1_0_SID;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE_SID;
import static com.amazon.ion.Timestamp.Precision.DAY;
import static com.amazon.ion.Timestamp.Precision.MINUTE;
import static com.amazon.ion.Timestamp.Precision.MONTH;
import static com.amazon.ion.Timestamp.Precision.SECOND;
import static java.lang.Double.doubleToRawLongBits;
import static java.lang.Float.floatToRawIntBits;

import com.amazon.ion.IonCatalog;
import com.amazon.ion.IonException;
import com.amazon.ion.IonType;
import com.amazon.ion.IonWriter;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.Timestamp;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * Low-level binary {@link IonWriter} that understands encoding concerns but doesn't operate with any sense of symbol table management.
 */
@SuppressWarnings(&quot;deprecation&quot;)
/*package*/ final class IonRawBinaryWriter extends AbstractIonWriter implements _Private_IonRawWriter
{
    /** short-hand for array of bytes--useful for static definitions. */
    private static byte[] bytes(int... vals) {
<span class="fc" id="L66">        final byte[] octets = new byte[vals.length];</span>

<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (int i = 0; i &lt; vals.length; i++) {</span>
<span class="fc" id="L69">            octets[i] = (byte) vals[i];</span>
        }

<span class="fc" id="L72">        return octets;</span>
    }

<span class="fc" id="L75">    private static final byte[] IVM = bytes(0xE0, 0x01, 0x00, 0xEA);</span>

    private static final byte[] NULLS;
    static {
<span class="fc" id="L79">        final IonType[] types = IonType.values();</span>
<span class="fc" id="L80">        NULLS = new byte[types.length];</span>

<span class="fc" id="L82">        NULLS[NULL.ordinal()]           = (byte) 0x0F;</span>
<span class="fc" id="L83">        NULLS[BOOL.ordinal()]           = (byte) 0x1F;</span>
<span class="fc" id="L84">        NULLS[INT.ordinal()]            = (byte) 0x2F;</span>
<span class="fc" id="L85">        NULLS[FLOAT.ordinal()]          = (byte) 0x4F;</span>
<span class="fc" id="L86">        NULLS[DECIMAL.ordinal()]        = (byte) 0x5F;</span>
<span class="fc" id="L87">        NULLS[TIMESTAMP.ordinal()]      = (byte) 0x6F;</span>
<span class="fc" id="L88">        NULLS[SYMBOL.ordinal()]         = (byte) 0x7F;</span>
<span class="fc" id="L89">        NULLS[STRING.ordinal()]         = (byte) 0x8F;</span>
<span class="fc" id="L90">        NULLS[CLOB.ordinal()]           = (byte) 0x9F;</span>
<span class="fc" id="L91">        NULLS[BLOB.ordinal()]           = (byte) 0xAF;</span>
<span class="fc" id="L92">        NULLS[LIST.ordinal()]           = (byte) 0xBF;</span>
<span class="fc" id="L93">        NULLS[SEXP.ordinal()]           = (byte) 0xCF;</span>
<span class="fc" id="L94">        NULLS[STRUCT.ordinal()]         = (byte) 0xDF;</span>
    }
<span class="fc" id="L96">    private static final byte NULL_NULL = NULLS[NULL.ordinal()];</span>

    private static final byte BOOL_FALSE        = (byte) 0x10;
    private static final byte BOOL_TRUE         = (byte) 0x11;

    private static final byte INT_ZERO          = (byte) 0x20;

    private static final byte POS_INT_TYPE      = (byte) 0x20;
    private static final byte NEG_INT_TYPE      = (byte) 0x30;
    private static final byte FLOAT_TYPE        = (byte) 0x40;

    private static final byte DECIMAL_TYPE      = (byte) 0x50;
    private static final byte TIMESTAMP_TYPE    = (byte) 0x60;
    private static final byte SYMBOL_TYPE       = (byte) 0x70;
    private static final byte STRING_TYPE       = (byte) 0x80;

    private static final byte CLOB_TYPE         = (byte) 0x90;
    private static final byte BLOB_TYPE         = (byte) 0xA0;

    private static final byte DECIMAL_POS_ZERO               = (byte) 0x50;
    private static final byte DECIMAL_NEGATIVE_ZERO_MANTISSA = (byte) 0x80;

<span class="fc" id="L118">    private static final BigInteger BIG_INT_LONG_MAX_VALUE = BigInteger.valueOf(Long.MAX_VALUE);</span>
<span class="fc" id="L119">    private static final BigInteger BIG_INT_LONG_MIN_VALUE = BigInteger.valueOf(Long.MIN_VALUE);</span>

    private static final byte VARINT_NEG_ZERO   = (byte) 0xC0;

    private static final byte[] makeTypedPreallocatedBytes(final int typeDesc, final int length)
    {
<span class="fc" id="L125">        final byte[] bytes = new byte[length];</span>
<span class="fc" id="L126">        bytes[0]          = (byte) typeDesc;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (length &gt; 1)</span>
        {
<span class="fc" id="L129">            bytes[length - 1] = (byte) 0x80;</span>
        }
<span class="fc" id="L131">        return bytes;</span>
    }

    private static byte[][] makeContainerTypedPreallocatedTable(final int length) {
<span class="fc" id="L135">        final IonType[] types = IonType.values();</span>
<span class="fc" id="L136">        byte[][] extendedSizes = new byte[types.length][];</span>


<span class="fc" id="L139">        extendedSizes[LIST.ordinal()]   = makeTypedPreallocatedBytes(0xBE, length);</span>
<span class="fc" id="L140">        extendedSizes[SEXP.ordinal()]   = makeTypedPreallocatedBytes(0xCE, length);</span>
<span class="fc" id="L141">        extendedSizes[STRUCT.ordinal()] = makeTypedPreallocatedBytes(0xDE, length);</span>

<span class="fc" id="L143">        return extendedSizes;</span>
    }

    /**
     * Determines how container/container-like values should be padded
     */
<span class="fc" id="L149">    /*package*/ enum PreallocationMode</span>
    {
        /** Allocate no length.  (forces side patching) */
<span class="fc" id="L152">        PREALLOCATE_0(0x0000,   1)</span>
        {
            @Override
            /*package*/ void patchLength(final WriteBuffer buffer, final long position, final long lengthValue)
            {
<span class="nc" id="L157">                throw new IllegalStateException(&quot;Cannot patch in PREALLOCATE 0 mode&quot;);</span>
            }
        },

        /** Preallocate 1 byte of length. */
<span class="fc" id="L162">        PREALLOCATE_1(0x007F,   2)</span>
        {
            @Override
            /*package*/ void patchLength(final WriteBuffer buffer, long position, long lengthValue)
            {
<span class="fc" id="L167">                buffer.writeVarUIntDirect1At(position, lengthValue);</span>
<span class="fc" id="L168">            }</span>
        },

        /** Preallocate 2 bytes of length. */
<span class="fc" id="L172">        PREALLOCATE_2(0x3FFF,   3)</span>
        {
            @Override
            /*package*/ void patchLength(final WriteBuffer buffer, long position, long lengthValue)
            {
<span class="fc" id="L177">                buffer.writeVarUIntDirect2At(position, lengthValue);</span>
<span class="fc" id="L178">            }</span>
        }
        ;

        private final int       contentMaxLength;
        private final int       typedLength;
        private final byte[][]  containerTypedPreallocatedBytes;
        private final byte[]    annotationsTypedPreallocatedBytes;

        private PreallocationMode(final int contentMaxLength, final int typedLength)
<span class="fc" id="L188">        {</span>
<span class="fc" id="L189">            this.contentMaxLength = contentMaxLength;</span>
<span class="fc" id="L190">            this.typedLength = typedLength;</span>
<span class="fc" id="L191">            this.containerTypedPreallocatedBytes   = makeContainerTypedPreallocatedTable(typedLength);</span>
<span class="fc" id="L192">            this.annotationsTypedPreallocatedBytes = makeTypedPreallocatedBytes(0xEE, typedLength);</span>
<span class="fc" id="L193">        }</span>

        /*package*/ abstract void patchLength(final WriteBuffer buffer, final long position, final long length);

        /*package*/ static PreallocationMode withPadSize(final int pad)
        {
<span class="pc bpc" id="L199" title="3 of 4 branches missed.">            switch (pad)</span>
            {
                case 0:
<span class="fc" id="L202">                    return PreallocationMode.PREALLOCATE_0;</span>
                case 1:
<span class="nc" id="L204">                    return PreallocationMode.PREALLOCATE_1;</span>
                case 2:
<span class="nc" id="L206">                    return PreallocationMode.PREALLOCATE_2;</span>
            }
<span class="nc" id="L208">            throw new IllegalArgumentException(&quot;No such preallocation mode for: &quot; + pad);</span>
        }
    }

    private static final byte STRING_TYPE_EXTENDED_LENGTH       = (byte) 0x8E;
<span class="fc" id="L213">    private static final byte[] STRING_TYPED_PREALLOCATED_2     = makeTypedPreallocatedBytes(0x8E, 2);</span>
<span class="fc" id="L214">    private static final byte[] STRING_TYPED_PREALLOCATED_3     = makeTypedPreallocatedBytes(0x8E, 3);</span>

    /** Max supported annotation length specifier size supported. */
    private static final int MAX_ANNOTATION_LENGTH = 0x7F;

<span class="fc" id="L219">    private enum ContainerType</span>
    {
<span class="fc" id="L221">        SEQUENCE(true),</span>
<span class="fc" id="L222">        STRUCT(true),</span>
<span class="fc" id="L223">        VALUE(false),</span>
<span class="fc" id="L224">        ANNOTATION(false);</span>

        public final boolean allowedInStepOut;

        private ContainerType(final boolean allowedInStepOut)
<span class="fc" id="L229">        {</span>
<span class="fc" id="L230">            this.allowedInStepOut = allowedInStepOut;</span>
<span class="fc" id="L231">        }</span>
    }

    private static class ContainerInfo
    {
        /** Whether or not the container is a struct */
        public ContainerType type;
        /** The location of the pre-allocated size descriptor in the buffer. */
        public long position;
        /** The size of the current value. */
        public long length;
        /** The patchlist for this container. */
        public PatchList patches;

        public ContainerInfo()
<span class="fc" id="L246">        {</span>
<span class="fc" id="L247">            type = null;</span>
<span class="fc" id="L248">            position = -1;</span>
<span class="fc" id="L249">            length = -1;</span>
<span class="fc" id="L250">            patches = null;</span>
<span class="fc" id="L251">        }</span>

        public void appendPatch(final PatchPoint patch)
        {
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (patches == null)</span>
            {
<span class="fc" id="L257">                patches = new PatchList();</span>
            }
<span class="fc" id="L259">            patches.append(patch);</span>
<span class="fc" id="L260">        }</span>

        public void extendPatches(final PatchList newPatches)
        {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            if (patches == null)</span>
            {
<span class="nc" id="L266">                patches = newPatches;</span>
            }
            else
            {
<span class="fc" id="L270">                patches.extend(newPatches);</span>
            }
<span class="fc" id="L272">        }</span>

        public void initialize(final ContainerType type, final long offset) {
<span class="fc" id="L275">            this.type = type;</span>
<span class="fc" id="L276">            this.position = offset;</span>
<span class="fc" id="L277">            this.patches = null;</span>
<span class="fc" id="L278">            this.length = 0;</span>
<span class="fc" id="L279">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L284">            return &quot;(CI &quot; + type + &quot; pos:&quot; + position + &quot; len:&quot; + length + &quot;)&quot;;</span>
        }
    }

    private static class PatchPoint
    {
        /** position of the data being patched out. */
        public final long oldPosition;
        /** length of the data being patched out.*/
        public final int oldLength;
        /** position of the patch buffer where the length data is stored. */
        public final long patchPosition;
        /** length of the data to be patched in.*/
        public final int patchLength;

        public PatchPoint(final long oldPosition, final int oldLength, final long patchPosition, final int patchLength)
<span class="fc" id="L300">        {</span>
<span class="fc" id="L301">            this.oldPosition = oldPosition;</span>
<span class="fc" id="L302">            this.oldLength = oldLength;</span>
<span class="fc" id="L303">            this.patchPosition = patchPosition;</span>
<span class="fc" id="L304">            this.patchLength = patchLength;</span>
<span class="fc" id="L305">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L310">            return &quot;(PP old::(&quot; + oldPosition + &quot; &quot; + oldLength + &quot;) patch::(&quot; + patchPosition + &quot; &quot; + patchLength + &quot;)&quot;;</span>
        }
    }

    /**
     * Simple singly linked list node that we can use to construct the patch list in the
     * right order incrementally in recursive segments.
     */
    private static class PatchList implements Iterable&lt;PatchPoint&gt;
    {
        private static class Node {
            public final PatchPoint value;
            public Node next;

            public Node(final PatchPoint value)
<span class="fc" id="L325">            {</span>
<span class="fc" id="L326">                this.value = value;</span>
<span class="fc" id="L327">            }</span>
        }
        private Node head;
        private Node tail;

        public PatchList()
<span class="fc" id="L333">        {</span>
<span class="fc" id="L334">            head = null;</span>
<span class="fc" id="L335">            tail = null;</span>
<span class="fc" id="L336">        }</span>

        public boolean isEmpty()
        {
<span class="pc bpc" id="L340" title="1 of 4 branches missed.">            return head == null &amp;&amp; tail == null;</span>
        }

        public void clear()
        {
<span class="fc" id="L345">            head = null;</span>
<span class="fc" id="L346">            tail = null;</span>
<span class="fc" id="L347">        }</span>

        public void append(final PatchPoint patch)
        {
<span class="fc" id="L351">            final Node node = new Node(patch);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (head == null)</span>
            {
<span class="fc" id="L354">                head = node;</span>
<span class="fc" id="L355">                tail = node;</span>
            }
            else
            {
<span class="fc" id="L359">                tail.next = node;</span>
<span class="fc" id="L360">                tail = node;</span>
            }
<span class="fc" id="L362">        }</span>

        public void extend(final PatchList end)
        {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            if (end != null)</span>
            {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">                if (head == null)</span>
                {
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    if (end.head != null)</span>
                    {
<span class="nc" id="L372">                        head = end.head;</span>
<span class="nc" id="L373">                        tail = end.tail;</span>
                    }
                }
                else
                {
<span class="fc" id="L378">                    tail.next = end.head;</span>
<span class="fc" id="L379">                    tail = end.tail;</span>
                }
            }
<span class="fc" id="L382">        }</span>

        public PatchPoint truncate(final long oldPosition)
        {
<span class="fc" id="L386">            Node prev = null;</span>
<span class="fc" id="L387">            Node curr = head;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            while (curr != null)</span>
            {
<span class="fc" id="L390">                final PatchPoint patch = curr.value;</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                if (patch.oldPosition &gt;= oldPosition)</span>
                {
<span class="fc" id="L393">                    tail = prev;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                    if (tail == null)</span>
                    {
<span class="fc" id="L396">                        head = null;</span>
                    }
                    else
                    {
<span class="fc" id="L400">                        tail.next = null;</span>
                    }
<span class="fc" id="L402">                    return patch;</span>
                }

<span class="fc" id="L405">                prev = curr;</span>
<span class="fc" id="L406">                curr = curr.next;</span>
<span class="fc" id="L407">            }</span>
<span class="fc" id="L408">            return null;</span>
        }

        public Iterator&lt;PatchPoint&gt; iterator()
        {
<span class="fc" id="L413">            return new Iterator&lt;PatchPoint&gt;()</span>
<span class="fc" id="L414">            {</span>
<span class="fc" id="L415">                Node curr = head;</span>

                public boolean hasNext()
                {
<span class="fc bfc" id="L419" title="All 2 branches covered.">                    return curr != null;</span>
                }

                public PatchPoint next()
                {
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">                    if (!hasNext())</span>
                    {
<span class="nc" id="L426">                        throw new NoSuchElementException();</span>
                    }
<span class="fc" id="L428">                    final PatchPoint value = curr.value;</span>
<span class="fc" id="L429">                    curr = curr.next;</span>
<span class="fc" id="L430">                    return value;</span>
                }

                public void remove()
                {
<span class="nc" id="L435">                    throw new UnsupportedOperationException();</span>
                }
            };
        }

        @Override
        public String toString()
        {
<span class="nc" id="L443">            final StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L444">            buf.append(&quot;(PATCHES&quot;);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            for (final PatchPoint patch : this)</span>
            {
<span class="nc" id="L447">                buf.append(&quot; &quot;);</span>
<span class="nc" id="L448">                buf.append(patch);</span>
<span class="nc" id="L449">            }</span>
<span class="nc" id="L450">            buf.append(&quot;)&quot;);</span>
<span class="nc" id="L451">            return buf.toString();</span>
        }
    }

<span class="fc" id="L455">    /*package*/ enum StreamCloseMode</span>
    {
<span class="fc" id="L457">        NO_CLOSE,</span>
<span class="fc" id="L458">        CLOSE</span>
    }

<span class="fc" id="L461">    /*package*/ enum StreamFlushMode</span>
    {
<span class="fc" id="L463">        NO_FLUSH,</span>
<span class="fc" id="L464">        FLUSH</span>
    }

    /**
     * A stack whose elements are recycled. This can be useful when the stack needs to grow and shrink
     * frequently and has a predictable maximum depth.
     * @param &lt;T&gt; the type of elements stored.
     */
    private static final class RecyclingStack&lt;T&gt; {

        /**
         * Factory for new stack elements.
         * @param &lt;T&gt; the type of element.
         */
        public interface ElementFactory&lt;T&gt; {

            /**
             * @return a new instance.
             */
            T newElement();
        }

        private final List&lt;T&gt; elements;
        private final ElementFactory&lt;T&gt; elementFactory;
        private int currentIndex;
        private T top;

        /**
         * @param initialCapacity the initial capacity of the underlying collection.
         * @param elementFactory the factory used to create a new element on {@link #push()} when the stack has
         *                       not previously grown to the new depth.
         */
<span class="fc" id="L496">        public RecyclingStack(int initialCapacity, ElementFactory&lt;T&gt; elementFactory) {</span>
<span class="fc" id="L497">            elements = new ArrayList&lt;T&gt;(initialCapacity);</span>
<span class="fc" id="L498">            this.elementFactory = elementFactory;</span>
<span class="fc" id="L499">            currentIndex = -1;</span>
<span class="fc" id="L500">            top = null;</span>
<span class="fc" id="L501">        }</span>

        /**
         * Pushes an element onto the top of the stack, instantiating a new element only if the stack has not
         * previously grown to the new depth.
         * @return the element at the top of the stack after the push. This element must be initialized by the caller.
         */
        public T push() {
<span class="fc" id="L509">            currentIndex++;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">            if (currentIndex &gt;= elements.size()) {</span>
<span class="fc" id="L511">                top = elementFactory.newElement();</span>
<span class="fc" id="L512">                elements.add(top);</span>
            }  else {
<span class="fc" id="L514">                top = elements.get(currentIndex);</span>
            }
<span class="fc" id="L516">            return top;</span>
        }

        /**
         * @return the element at the top of the stack, or null if the stack is empty.
         */
        public T peek() {
<span class="fc" id="L523">            return top;</span>
        }

        /**
         * Pops an element from the stack, retaining a reference to the element so that it can be reused the
         * next time the stack grows to the element's depth.
         * @return the element that was at the top of the stack before the pop, or null if the stack was empty.
         */
        public T pop() {
<span class="fc" id="L532">            T popped = top;</span>
<span class="fc" id="L533">            currentIndex--;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">            if (currentIndex &gt;= 0) {</span>
<span class="fc" id="L535">                top = elements.get(currentIndex);</span>
            } else {
<span class="fc" id="L537">                top = null;</span>
<span class="fc" id="L538">                currentIndex = -1;</span>
            }
<span class="fc" id="L540">            return popped;</span>
        }

        /**
         * @return true if the stack is empty; otherwise, false.
         */
        public boolean isEmpty() {
<span class="fc bfc" id="L547" title="All 2 branches covered.">            return top == null;</span>
        }
    }

    private static final int SID_UNASSIGNED = -1;

    private final BlockAllocator                allocator;
    private final OutputStream                  out;
    private final StreamCloseMode               streamCloseMode;
    private final StreamFlushMode               streamFlushMode;
    private final PreallocationMode             preallocationMode;
    private final boolean                       isFloatBinary32Enabled;
    private final WriteBuffer                   buffer;
    private final WriteBuffer                   patchBuffer;
    private final PatchList                     patchPoints;
    private final RecyclingStack&lt;ContainerInfo&gt; containers;
    private int                                 depth;
    private boolean                             hasWrittenValuesSinceFinished;
    private boolean                             hasWrittenValuesSinceConstructed;

    private int                     currentFieldSid;
    private final List&lt;Integer&gt;     currentAnnotationSids;
    // XXX this is for managed detection of TLV that is a LST--this is easier to track here than at the managed level
    private boolean                     hasTopLevelSymbolTableAnnotation;

    private boolean                     closed;

    /*package*/ IonRawBinaryWriter(final BlockAllocatorProvider provider,
                                   final int blockSize,
                                   final OutputStream out,
                                   final WriteValueOptimization optimization,
                                   final StreamCloseMode streamCloseMode,
                                   final StreamFlushMode streamFlushMode,
                                   final PreallocationMode preallocationMode,
                                   final boolean isFloatBinary32Enabled)
                                   throws IOException
    {
<span class="fc" id="L584">        super(optimization);</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (out == null) { throw new NullPointerException(); }</span>

<span class="fc" id="L588">        this.allocator         = provider.vendAllocator(blockSize);</span>
<span class="fc" id="L589">        this.out               = out;</span>
<span class="fc" id="L590">        this.streamCloseMode   = streamCloseMode;</span>
<span class="fc" id="L591">        this.streamFlushMode   = streamFlushMode;</span>
<span class="fc" id="L592">        this.preallocationMode = preallocationMode;</span>
<span class="fc" id="L593">        this.isFloatBinary32Enabled = isFloatBinary32Enabled;</span>
<span class="fc" id="L594">        this.buffer            = new WriteBuffer(allocator);</span>
<span class="fc" id="L595">        this.patchBuffer       = new WriteBuffer(allocator);</span>
<span class="fc" id="L596">        this.patchPoints       = new PatchList();</span>
<span class="fc" id="L597">        this.containers        = new RecyclingStack&lt;ContainerInfo&gt;(</span>
            10,
<span class="fc" id="L599">            new RecyclingStack.ElementFactory&lt;ContainerInfo&gt;() {</span>
                @Override
                public ContainerInfo newElement() {
<span class="fc" id="L602">                    return new ContainerInfo();</span>
                }
            }
        );
<span class="fc" id="L606">        this.depth                            = 0;</span>
<span class="fc" id="L607">        this.hasWrittenValuesSinceFinished    = false;</span>
<span class="fc" id="L608">        this.hasWrittenValuesSinceConstructed = false;</span>

<span class="fc" id="L610">        this.currentFieldSid                  = SID_UNASSIGNED;</span>
<span class="fc" id="L611">        this.currentAnnotationSids            = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L612">        this.hasTopLevelSymbolTableAnnotation = false;</span>

<span class="fc" id="L614">        this.closed = false;</span>
<span class="fc" id="L615">    }</span>

    /** Always returns {@link Symbols#systemSymbolTable()}. */
    public SymbolTable getSymbolTable()
    {
<span class="nc" id="L620">        return Symbols.systemSymbolTable();</span>
    }

    // Current Value Meta

    public void setFieldName(final String name)
    {
<span class="nc" id="L627">        throw new UnsupportedOperationException(&quot;Cannot set field name on a low-level binary writer via string&quot;);</span>
    }

    public void setFieldNameSymbol(final SymbolToken name)
    {
<span class="fc" id="L632">        setFieldNameSymbol(name.getSid());</span>
<span class="fc" id="L633">    }</span>

    public void setFieldNameSymbol(int sid)
    {
<span class="fc bfc" id="L637" title="All 2 branches covered.">        if (!isInStruct())</span>
        {
<span class="fc" id="L639">            throw new IonException(&quot;Cannot set field name outside of struct context&quot;);</span>
        }
<span class="fc" id="L641">        currentFieldSid = sid;</span>
<span class="fc" id="L642">    }</span>

    public void setTypeAnnotations(final String... annotations)
    {
<span class="nc" id="L646">        throw new UnsupportedOperationException(&quot;Cannot set annotations on a low-level binary writer via string&quot;);</span>
    }

    private void clearAnnotations()
    {
<span class="fc" id="L651">        currentAnnotationSids.clear();</span>
<span class="fc" id="L652">        hasTopLevelSymbolTableAnnotation = false;</span>
<span class="fc" id="L653">    }</span>

    public void setTypeAnnotationSymbols(final SymbolToken... annotations)
    {
<span class="fc" id="L657">        clearAnnotations();</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">        if (annotations != null)</span>
        {
<span class="fc bfc" id="L660" title="All 2 branches covered.">            for (final SymbolToken annotation : annotations)</span>
            {
<span class="fc" id="L662">                addTypeAnnotationSymbol(annotation.getSid());</span>
            }
        }
<span class="fc" id="L665">    }</span>

    public void setTypeAnnotationSymbols(int... sids)
    {
<span class="fc" id="L669">        clearAnnotations();</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">        if (sids != null)</span>
        {
<span class="fc bfc" id="L672" title="All 2 branches covered.">            for (final int sid : sids)</span>
            {
<span class="fc" id="L674">                addTypeAnnotationSymbol(sid);</span>
            }
        }
<span class="fc" id="L677">    }</span>

    public void addTypeAnnotation(final String annotation)
    {
<span class="nc" id="L681">        throw new UnsupportedOperationException(&quot;Cannot add annotations on a low-level binary writer via string&quot;);</span>
    }

    // Additional Current State Meta

    /*package*/ void addTypeAnnotationSymbol(final SymbolToken annotation)
    {
<span class="fc" id="L688">        addTypeAnnotationSymbol(annotation.getSid());</span>

<span class="fc" id="L690">    }</span>

    public void addTypeAnnotationSymbol(int sid)
    {
<span class="fc bfc" id="L694" title="All 4 branches covered.">        if (depth == 0 &amp;&amp; sid == ION_SYMBOL_TABLE_SID)</span>
        {
<span class="fc" id="L696">            hasTopLevelSymbolTableAnnotation = true;</span>
        }
<span class="fc" id="L698">        currentAnnotationSids.add(sid);</span>
<span class="fc" id="L699">    }</span>

    /*package*/ boolean hasAnnotations()
    {
<span class="fc bfc" id="L703" title="All 2 branches covered.">        return !currentAnnotationSids.isEmpty();</span>
    }

    /** Returns true if a value has been written since construction or {@link #finish()}. */
    /*package*/ boolean hasWrittenValuesSinceFinished()
    {
<span class="fc" id="L709">        return hasWrittenValuesSinceFinished;</span>
    }

    /** Returns true if a value has been written since the writer was constructed. */
    /*package*/ boolean hasWrittenValuesSinceConstructed()
    {
<span class="nc" id="L715">        return hasWrittenValuesSinceConstructed;</span>
    }

    /*package*/ boolean hasTopLevelSymbolTableAnnotation()
    {
<span class="fc" id="L720">        return hasTopLevelSymbolTableAnnotation;</span>
    }

    /*package*/ int getFieldId()
    {
<span class="fc" id="L725">        return currentFieldSid;</span>
    }

    // Compatibility with Implementation Writer Interface

    public IonCatalog getCatalog()
    {
<span class="nc" id="L732">        throw new UnsupportedOperationException();</span>
    }

    public boolean isFieldNameSet()
    {
<span class="fc bfc" id="L737" title="All 2 branches covered.">        return currentFieldSid &gt; SID_UNASSIGNED;</span>
    }

    public void writeIonVersionMarker() throws IOException
    {
<span class="fc" id="L742">        buffer.writeBytes(IVM);</span>
<span class="fc" id="L743">    }</span>

    public int getDepth()
    {
<span class="fc" id="L747">        return depth;</span>
    }

    // Low-Level Writing

    private void updateLength(long length)
    {
<span class="fc bfc" id="L754" title="All 2 branches covered.">        if (containers.isEmpty())</span>
        {
<span class="fc" id="L756">            return;</span>
        }

<span class="fc" id="L759">        containers.peek().length += length;</span>
<span class="fc" id="L760">    }</span>

    private void pushContainer(final ContainerType type)
    {
        // XXX we push before writing the type of container
<span class="fc" id="L765">        containers.push().initialize(type, buffer.position() + 1);</span>
<span class="fc" id="L766">    }</span>

    private void addPatchPoint(final long position, final int oldLength, final long value)
    {
        // record the size in a patch buffer
<span class="fc" id="L771">        final long patchPosition = patchBuffer.position();</span>
<span class="fc" id="L772">        final int patchLength = patchBuffer.writeVarUInt(value);</span>
<span class="fc" id="L773">        final PatchPoint patch = new PatchPoint(position, oldLength, patchPosition, patchLength);</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">        if (containers.isEmpty())</span>
        {
            // not nested, just append to the root list
<span class="fc" id="L777">            patchPoints.append(patch);</span>
        }
        else
        {
            // nested, apply it to the current container
<span class="fc" id="L782">            containers.peek().appendPatch(patch);</span>
        }
<span class="fc" id="L784">        updateLength(patchLength - oldLength);</span>
<span class="fc" id="L785">    }</span>

    private void extendPatchPoints(final PatchList patches)
    {
<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (containers.isEmpty())</span>
        {
            // not nested, extend root list
<span class="fc" id="L792">            patchPoints.extend(patches);</span>
        }
        else
        {
            // nested, apply it to the current container
<span class="fc" id="L797">            containers.peek().extendPatches(patches);</span>
        }
<span class="fc" id="L799">    }</span>

    private ContainerInfo popContainer()
    {
<span class="fc" id="L803">        final ContainerInfo current = containers.pop();</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        if (current == null)</span>
        {
<span class="nc" id="L806">            throw new IllegalStateException(&quot;Tried to pop container state without said container&quot;);</span>
        }

        // only patch for real containers and annotations -- we use VALUE for tracking only
<span class="fc" id="L810">        final long length = current.length;</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (current.type != ContainerType.VALUE)</span>
        {
            // patch in the length
<span class="fc" id="L814">            final long position = current.position;</span>
<span class="fc bfc" id="L815" title="All 4 branches covered.">            if (current.length &lt;= preallocationMode.contentMaxLength &amp;&amp; preallocationMode != PreallocationMode.PREALLOCATE_0)</span>
            {
<span class="fc" id="L817">                preallocationMode.patchLength(buffer, position, length);</span>
            }
            else
            {
                // side patch
<span class="pc bpc" id="L822" title="1 of 4 branches missed.">                if (current.length &lt;= 0xD &amp;&amp; preallocationMode == PreallocationMode.PREALLOCATE_0)</span>
                {
                    // XXX if we're not using padding we can get here and optimize the length a little without side patching!
<span class="fc" id="L825">                    final long typePosition = position - 1;</span>
<span class="fc" id="L826">                    final long type = (buffer.getUInt8At(typePosition) &amp; 0xF0) | current.length;</span>
<span class="fc" id="L827">                    buffer.writeUInt8At(typePosition, type);</span>
<span class="fc" id="L828">                }</span>
                else
                {
<span class="fc" id="L831">                    addPatchPoint(position, preallocationMode.typedLength - 1, length);</span>
                }
            }
        }
<span class="fc bfc" id="L835" title="All 2 branches covered.">        if (current.patches != null)</span>
        {
            // at this point, we've appended our patch points upward, lets make sure we get
            // our child patch points in
<span class="fc" id="L839">            extendPatchPoints(current.patches);</span>
        }

        // make sure to record length upward
<span class="fc" id="L843">        updateLength(length);</span>
<span class="fc" id="L844">        return current;</span>
    }

    private void writeVarUInt(final long value)
    {
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">        if (value &lt; 0)</span>
        {
<span class="nc" id="L851">            throw new IonException(&quot;Cannot write negative value as unsigned&quot;);</span>
        }
<span class="fc" id="L853">        final int len = buffer.writeVarUInt(value);</span>
<span class="fc" id="L854">        updateLength(len);</span>
<span class="fc" id="L855">    }</span>

    private void writeVarInt(final long value)
    {
<span class="fc" id="L859">        final int len = buffer.writeVarInt(value);</span>
<span class="fc" id="L860">        updateLength(len);</span>
<span class="fc" id="L861">    }</span>

    private static void checkSid(int sid)
    {
<span class="fc bfc" id="L865" title="All 2 branches covered.">        if (sid &lt; 0)</span>
        {
<span class="fc" id="L867">            throw new IllegalArgumentException(&quot;Invalid symbol with SID: &quot; + sid);</span>
        }
<span class="fc" id="L869">    }</span>

    /** prepare to write values with field name and annotations. */
    private void prepareValue()
    {
<span class="fc bfc" id="L874" title="All 4 branches covered.">        if (isInStruct() &amp;&amp; currentFieldSid &lt;= SID_UNASSIGNED)</span>
        {
<span class="fc" id="L876">            throw new IllegalStateException(&quot;IonWriter.setFieldName() must be called before writing a value into a struct.&quot;);</span>
        }
<span class="fc bfc" id="L878" title="All 2 branches covered.">        if (currentFieldSid &gt; SID_UNASSIGNED)</span>
        {
<span class="fc" id="L880">            checkSid(currentFieldSid);</span>
<span class="fc" id="L881">            writeVarUInt(currentFieldSid);</span>

            // clear out field name
<span class="fc" id="L884">            currentFieldSid = SID_UNASSIGNED;</span>
        }
<span class="fc bfc" id="L886" title="All 2 branches covered.">        if (!currentAnnotationSids.isEmpty())</span>
        {
            // we have to push a container context for annotations
<span class="fc" id="L889">            updateLength(preallocationMode.typedLength);</span>
<span class="fc" id="L890">            pushContainer(ContainerType.ANNOTATION);</span>
<span class="fc" id="L891">            buffer.writeBytes(preallocationMode.annotationsTypedPreallocatedBytes);</span>

<span class="fc" id="L893">            final long annotationsLengthPosition = buffer.position();</span>
<span class="fc" id="L894">            buffer.writeVarUInt(0L);</span>
<span class="fc" id="L895">            int annotationsLength = 0;</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">            for (final int symbol : currentAnnotationSids)</span>
            {
<span class="fc" id="L898">                checkSid(symbol);</span>
<span class="fc" id="L899">                final int symbolLength = buffer.writeVarUInt(symbol);</span>
<span class="fc" id="L900">                annotationsLength += symbolLength;</span>
<span class="fc" id="L901">            }</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">            if (annotationsLength &gt; MAX_ANNOTATION_LENGTH)</span>
            {
                // TODO deal with side patching if we want to support &gt; 32 4-byte symbols annotations... seems excessive
<span class="nc" id="L905">                throw new IonException(&quot;Annotations too large: &quot; + currentAnnotationSids);</span>
            }

            // update the annotations size
<span class="fc" id="L909">            updateLength(/*length specifier*/ 1 + annotationsLength);</span>
            // patch the annotations length
<span class="fc" id="L911">            buffer.writeVarUIntDirect1At(annotationsLengthPosition, annotationsLength);</span>

            // clear out annotations
<span class="fc" id="L914">            currentAnnotationSids.clear();</span>
<span class="fc" id="L915">            hasTopLevelSymbolTableAnnotation = false;</span>
        }
<span class="fc" id="L917">    }</span>

    /** Closes out annotations. */
    private void finishValue()
    {
<span class="fc bfc" id="L922" title="All 4 branches covered.">        if (!containers.isEmpty() &amp;&amp; containers.peek().type == ContainerType.ANNOTATION)</span>
        {
            // close out and patch the length
<span class="fc" id="L925">            popContainer();</span>
        }
<span class="fc" id="L927">        hasWrittenValuesSinceFinished = true;</span>
<span class="fc" id="L928">        hasWrittenValuesSinceConstructed = true;</span>
<span class="fc" id="L929">    }</span>

    // Container Manipulation

    public void stepIn(final IonType containerType) throws IOException
    {
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">        if (!isContainer(containerType))</span>
        {
<span class="nc" id="L937">            throw new IonException(&quot;Cannot step into &quot; + containerType);</span>
        }
<span class="fc" id="L939">        prepareValue();</span>
<span class="fc" id="L940">        updateLength(preallocationMode.typedLength);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">        pushContainer(containerType == STRUCT ? ContainerType.STRUCT : ContainerType.SEQUENCE);</span>
<span class="fc" id="L942">        depth++;</span>
<span class="fc" id="L943">        buffer.writeBytes(preallocationMode.containerTypedPreallocatedBytes[containerType.ordinal()]);</span>
<span class="fc" id="L944">    }</span>

    public void stepOut() throws IOException
    {
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">        if (currentFieldSid &gt; SID_UNASSIGNED)</span>
        {
<span class="nc" id="L950">            throw new IonException(&quot;Cannot step out with field name set&quot;);</span>
        }
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">        if (!currentAnnotationSids.isEmpty())</span>
        {
<span class="nc" id="L954">            throw new IonException(&quot;Cannot step out with field name set&quot;);</span>
        }
<span class="pc bpc" id="L956" title="2 of 4 branches missed.">        if (containers.isEmpty() || !containers.peek().type.allowedInStepOut)</span>
        {
<span class="nc" id="L958">            throw new IonException(&quot;Cannot step out when not in container&quot;);</span>
        }
        // close out the container
<span class="fc" id="L961">        popContainer();</span>
<span class="fc" id="L962">        depth--;</span>
        // close out the annotations if any
<span class="fc" id="L964">        finishValue();</span>
<span class="fc" id="L965">    }</span>

    public boolean isInStruct()
    {
<span class="fc bfc" id="L969" title="All 4 branches covered.">        return !containers.isEmpty() &amp;&amp; containers.peek().type == ContainerType.STRUCT;</span>
    }

    // Write Value Methods

    public void writeNull() throws IOException
    {
<span class="fc" id="L976">        prepareValue();</span>
<span class="fc" id="L977">        updateLength(1);</span>
<span class="fc" id="L978">        buffer.writeByte(NULL_NULL);</span>
<span class="fc" id="L979">        finishValue();</span>
<span class="fc" id="L980">    }</span>

    public void writeNull(final IonType type) throws IOException
    {
<span class="fc" id="L984">        byte data = NULL_NULL;</span>
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">        if (type != null)</span>
        {
<span class="fc" id="L987">            data = NULLS[type.ordinal()];</span>
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">            if (data == 0)</span>
            {
<span class="nc" id="L990">                throw new IllegalArgumentException(&quot;Cannot write a null for: &quot; + type);</span>
            }
        }

<span class="fc" id="L994">        prepareValue();</span>
<span class="fc" id="L995">        updateLength(1);</span>
<span class="fc" id="L996">        buffer.writeByte(data);</span>
<span class="fc" id="L997">        finishValue();</span>
<span class="fc" id="L998">    }</span>

    public void writeBool(final boolean value) throws IOException
    {
<span class="fc" id="L1002">        prepareValue();</span>
<span class="fc" id="L1003">        updateLength(1);</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        if (value)</span>
        {
<span class="fc" id="L1006">            buffer.writeByte(BOOL_TRUE);</span>
        }
        else
        {
<span class="fc" id="L1010">            buffer.writeByte(BOOL_FALSE);</span>
        }
<span class="fc" id="L1012">        finishValue();</span>
<span class="fc" id="L1013">    }</span>

    /**
     * Writes a type descriptor followed by unsigned integer value.
     * Does not check for sign.
     * Note that this does not do {@link #prepareValue()} or {@link #finishValue()}.
     */
    private void writeTypedUInt(final int type, final long value)
    {
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        if (value &lt;= 0xFFL)</span>
        {
<span class="fc" id="L1024">            updateLength(2);</span>
<span class="fc" id="L1025">            buffer.writeUInt8(type | 0x01);</span>
<span class="fc" id="L1026">            buffer.writeUInt8(value);</span>
        }
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFL)</span>
        {
<span class="fc" id="L1030">            updateLength(3);</span>
<span class="fc" id="L1031">            buffer.writeUInt8(type | 0x02);</span>
<span class="fc" id="L1032">            buffer.writeUInt16(value);</span>
        }
<span class="fc bfc" id="L1034" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFL)</span>
        {
<span class="fc" id="L1036">            updateLength(4);</span>
<span class="fc" id="L1037">            buffer.writeUInt8(type | 0x03);</span>
<span class="fc" id="L1038">            buffer.writeUInt24(value);</span>
        }
<span class="fc bfc" id="L1040" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFL)</span>
        {
<span class="fc" id="L1042">            updateLength(5);</span>
<span class="fc" id="L1043">            buffer.writeUInt8(type | 0x04);</span>
<span class="fc" id="L1044">            buffer.writeUInt32(value);</span>
        }
<span class="fc bfc" id="L1046" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFFFL)</span>
        {
<span class="fc" id="L1048">            updateLength(6);</span>
<span class="fc" id="L1049">            buffer.writeUInt8(type | 0x05);</span>
<span class="fc" id="L1050">            buffer.writeUInt40(value);</span>
        }
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFFFFFL)</span>
        {
<span class="fc" id="L1054">            updateLength(7);</span>
<span class="fc" id="L1055">            buffer.writeUInt8(type | 0x06);</span>
<span class="fc" id="L1056">            buffer.writeUInt48(value);</span>
        }
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        else if (value &lt;= 0xFFFFFFFFFFFFFFL)</span>
        {
<span class="fc" id="L1060">            updateLength(8);</span>
<span class="fc" id="L1061">            buffer.writeUInt8(type | 0x07);</span>
<span class="fc" id="L1062">            buffer.writeUInt56(value);</span>
        }
        else
        {
<span class="fc" id="L1066">            updateLength(9);</span>
<span class="fc" id="L1067">            buffer.writeUInt8(type | 0x08);</span>
<span class="fc" id="L1068">            buffer.writeUInt64(value);</span>
        }
<span class="fc" id="L1070">    }</span>

    public void writeInt(long value) throws IOException
    {
<span class="fc" id="L1074">        prepareValue();</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">        if (value == 0)</span>
        {
<span class="fc" id="L1077">            updateLength(1);</span>
<span class="fc" id="L1078">            buffer.writeByte(INT_ZERO);</span>
        }
        else
        {
<span class="fc" id="L1082">            int type = POS_INT_TYPE;</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">            if (value &lt; 0)</span>
            {
<span class="fc" id="L1085">                type = NEG_INT_TYPE;</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">                if (value == Long.MIN_VALUE)</span>
                {
                    // XXX special case for min_value which will not play nice with signed arithmetic and fit into the positive space
                    // XXX we keep 2's complement of Long.MIN_VALUE because it encodes to unsigned 2 ** 63 (0x8000000000000000L)
                    // XXX WriteBuffer.writeUInt64() never looks at sign
<span class="fc" id="L1091">                    updateLength(9);</span>
<span class="fc" id="L1092">                    buffer.writeUInt8(NEG_INT_TYPE | 0x8);</span>
<span class="fc" id="L1093">                    buffer.writeUInt64(value);</span>
                }
                else
                {
                    // get the magnitude, sign is already encoded
<span class="fc" id="L1098">                    value = -value;</span>
<span class="fc" id="L1099">                    writeTypedUInt(type, value);</span>
                }
            }
            else
            {
<span class="fc" id="L1104">                writeTypedUInt(type, value);</span>
            }
        }
<span class="fc" id="L1107">        finishValue();</span>
<span class="fc" id="L1108">    }</span>

    /** Write a raw byte array as some type. Note that this does not do {@link #prepareValue()}. */
    private void writeTypedBytes(final int type, final byte[] data, final int offset, final int length)
    {
<span class="fc" id="L1113">        int totalLength = 1 + length;</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">        if (length &lt; 14)</span>
        {
<span class="fc" id="L1116">            buffer.writeUInt8(type | length);</span>
        }
        else
        {
            // need to specify length explicitly
<span class="fc" id="L1121">            buffer.writeUInt8(type | 0xE);</span>
<span class="fc" id="L1122">            final int sizeLength = buffer.writeVarUInt(length);</span>
<span class="fc" id="L1123">            totalLength += sizeLength;</span>
        }
<span class="fc" id="L1125">        updateLength(totalLength);</span>
<span class="fc" id="L1126">        buffer.writeBytes(data, offset, length);</span>
<span class="fc" id="L1127">    }</span>

    public void writeInt(BigInteger value) throws IOException
    {
<span class="fc bfc" id="L1131" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1133">            writeNull(IonType.INT);</span>
<span class="fc" id="L1134">            return;</span>
        }
<span class="fc bfc" id="L1136" title="All 4 branches covered.">        if (value.compareTo(BIG_INT_LONG_MIN_VALUE) &gt;= 0 &amp;&amp; value.compareTo(BIG_INT_LONG_MAX_VALUE) &lt;= 0)</span>
        {
            // for the small stuff, just write it as a signed int64
<span class="fc" id="L1139">            writeInt(value.longValue());</span>
<span class="fc" id="L1140">            return;</span>
        }

<span class="fc" id="L1143">        prepareValue();</span>

<span class="fc" id="L1145">        int type = POS_INT_TYPE;</span>
<span class="fc bfc" id="L1146" title="All 2 branches covered.">        if(value.signum() &lt; 0)</span>
        {
<span class="fc" id="L1148">            type = NEG_INT_TYPE;</span>
<span class="fc" id="L1149">            value = value.negate();</span>
        }

        // generate big-endian representation of the positive value
<span class="fc" id="L1153">        final byte[] magnitude = value.toByteArray();</span>
<span class="fc" id="L1154">        writeTypedBytes(type, magnitude, 0, magnitude.length);</span>

<span class="fc" id="L1156">        finishValue();</span>
<span class="fc" id="L1157">    }</span>

    public void writeFloat(final double value) throws IOException
    {
<span class="fc" id="L1161">        prepareValue();</span>

<span class="fc bfc" id="L1163" title="All 4 branches covered.">        if (isFloatBinary32Enabled &amp;&amp; value == ((double) ((float) value))) {</span>
<span class="fc" id="L1164">            updateLength(5);</span>
<span class="fc" id="L1165">            buffer.writeUInt8(FLOAT_TYPE | 4);</span>
<span class="fc" id="L1166">            buffer.writeUInt32(floatToRawIntBits((float) value));</span>
        } else {
<span class="fc" id="L1168">            updateLength(9);</span>
<span class="fc" id="L1169">            buffer.writeUInt8(FLOAT_TYPE | 8);</span>
<span class="fc" id="L1170">            buffer.writeUInt64(doubleToRawLongBits(value));</span>
        }

<span class="fc" id="L1173">        finishValue();</span>
<span class="fc" id="L1174">    }</span>

    /** Encodes a decimal, updating the current container length context (which is probably a Decimal/Timestamp). */
    private void writeDecimalValue(final BigDecimal value)
    {
<span class="fc" id="L1179">        final boolean isNegZero = isNegativeZero(value);</span>
<span class="fc" id="L1180">        final int signum = value.signum();</span>
<span class="fc" id="L1181">        final int exponent = -value.scale();</span>

<span class="fc" id="L1183">        writeVarInt(exponent);</span>

<span class="fc" id="L1185">        final BigInteger mantissaBigInt = value.unscaledValue();</span>
<span class="fc bfc" id="L1186" title="All 4 branches covered.">        if (mantissaBigInt.compareTo(BIG_INT_LONG_MIN_VALUE) &gt;= 0 &amp;&amp; mantissaBigInt.compareTo(BIG_INT_LONG_MAX_VALUE) &lt;= 0)</span>
        {
            // we can fit into the long space
<span class="fc" id="L1189">            final long mantissa = mantissaBigInt.longValue();</span>
<span class="fc bfc" id="L1190" title="All 4 branches covered.">            if (signum == 0 &amp;&amp; !isNegZero)</span>
            {
                // positive zero does not need to be encoded
            }
<span class="fc bfc" id="L1194" title="All 2 branches covered.">            else if (isNegZero)</span>
            {
                // XXX special case for negative zero, we have to encode as a signed zero in the Int format
<span class="fc" id="L1197">                updateLength(1);</span>
<span class="fc" id="L1198">                buffer.writeByte(DECIMAL_NEGATIVE_ZERO_MANTISSA);</span>
            }
<span class="fc bfc" id="L1200" title="All 2 branches covered.">            else if (mantissa == Long.MIN_VALUE)</span>
            {
                // XXX special case for min value -- we need 64-bits to store the magnitude and we need a bit for sign
<span class="fc" id="L1203">                updateLength(9);</span>
<span class="fc" id="L1204">                buffer.writeUInt8(0x80);</span>
<span class="fc" id="L1205">                buffer.writeUInt64(mantissa);</span>
            }
<span class="fc bfc" id="L1207" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFFFFFFFF81L &amp;&amp; mantissa &lt;= 0x000000000000007FL)</span>
            {
<span class="fc" id="L1209">                updateLength(1);</span>
<span class="fc" id="L1210">                buffer.writeInt8(mantissa);</span>
            }
<span class="fc bfc" id="L1212" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFFFFFF8001L &amp;&amp; mantissa &lt;= 0x0000000000007FFFL)</span>
            {
<span class="fc" id="L1214">                updateLength(2);</span>
<span class="fc" id="L1215">                buffer.writeInt16(mantissa);</span>
            }
<span class="fc bfc" id="L1217" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFFFF800001L &amp;&amp; mantissa &lt;= 0x00000000007FFFFFL)</span>
            {
<span class="fc" id="L1219">                updateLength(3);</span>
<span class="fc" id="L1220">                buffer.writeInt24(mantissa);</span>
            }
<span class="fc bfc" id="L1222" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFFFF80000001L &amp;&amp; mantissa &lt;= 0x000000007FFFFFFFL)</span>
            {
<span class="fc" id="L1224">                updateLength(4);</span>
<span class="fc" id="L1225">                buffer.writeInt32(mantissa);</span>
            }
<span class="fc bfc" id="L1227" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFFFF8000000001L &amp;&amp; mantissa &lt;= 0x0000007FFFFFFFFFL)</span>
            {
<span class="fc" id="L1229">                updateLength(5);</span>
<span class="fc" id="L1230">                buffer.writeInt40(mantissa);</span>
            }
<span class="fc bfc" id="L1232" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFFFF800000000001L &amp;&amp; mantissa &lt;= 0x00007FFFFFFFFFFFL)</span>
            {
<span class="fc" id="L1234">                updateLength(6);</span>
<span class="fc" id="L1235">                buffer.writeInt48(mantissa);</span>
            }
<span class="fc bfc" id="L1237" title="All 4 branches covered.">            else if (mantissa &gt;= 0xFF80000000000001L &amp;&amp; mantissa &lt;= 0x007FFFFFFFFFFFFFL)</span>
            {
<span class="fc" id="L1239">                updateLength(7);</span>
<span class="fc" id="L1240">                buffer.writeInt56(mantissa);</span>
            }
            else
            {
                // TODO consider being more space efficient for integers that can be written with 6/7 bytes.
<span class="fc" id="L1245">                updateLength(8);</span>
<span class="fc" id="L1246">                buffer.writeInt64(mantissa);</span>
            }
<span class="fc" id="L1248">        }</span>
        else
        {
<span class="fc bfc" id="L1251" title="All 2 branches covered.">            final BigInteger magnitude = signum &gt; 0 ? mantissaBigInt : mantissaBigInt.negate();</span>
<span class="fc" id="L1252">            final byte[] bits = magnitude.toByteArray();</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">            if (signum &lt; 0)</span>
            {
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">                if ((bits[0] &amp; 0x80) == 0)</span>
                {
<span class="fc" id="L1257">                    bits[0] |= 0x80;</span>
                }
                else
                {
                    // not enough space in the bits to store the negative sign
<span class="nc" id="L1262">                    updateLength(1);</span>
<span class="nc" id="L1263">                    buffer.writeUInt8(0x80);</span>
                }
            }
<span class="fc" id="L1266">            updateLength(bits.length);</span>
<span class="fc" id="L1267">            buffer.writeBytes(bits);</span>
        }
<span class="fc" id="L1269">    }</span>

    private void patchSingleByteTypedOptimisticValue(final byte type, final ContainerInfo info)
    {
<span class="fc bfc" id="L1273" title="All 2 branches covered.">        if (info.length &lt;= 0xD)</span>
        {
            // we fit -- overwrite the type byte
<span class="fc" id="L1276">            buffer.writeUInt8At(info.position - 1, type | info.length);</span>
        }
        else
        {
            // side patch
<span class="fc" id="L1281">            buffer.writeUInt8At(info.position - 1, type | 0xE);</span>
<span class="fc" id="L1282">            addPatchPoint(info.position, 0, info.length);</span>
        }
<span class="fc" id="L1284">    }</span>

    public void writeDecimal(final BigDecimal value) throws IOException
    {
<span class="fc bfc" id="L1288" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1290">            writeNull(IonType.DECIMAL);</span>
<span class="fc" id="L1291">            return;</span>
        }

<span class="fc" id="L1294">        prepareValue();</span>

<span class="fc bfc" id="L1296" title="All 6 branches covered.">        if (value.signum() == 0 &amp;&amp; value.scale() == 0 &amp;&amp; !isNegativeZero(value))</span>
        {
            // 0d0 can be written in one byte
<span class="fc" id="L1299">            updateLength(1);</span>
<span class="fc" id="L1300">            buffer.writeUInt8(DECIMAL_POS_ZERO);</span>
        }
        else
        {
            // optimistically try to fit decimal length in low nibble (most should)
<span class="fc" id="L1305">            updateLength(1);</span>
<span class="fc" id="L1306">            pushContainer(ContainerType.VALUE);</span>
<span class="fc" id="L1307">            buffer.writeByte(DECIMAL_TYPE);</span>
<span class="fc" id="L1308">            writeDecimalValue(value);</span>
<span class="fc" id="L1309">            final ContainerInfo info = popContainer();</span>
<span class="fc" id="L1310">            patchSingleByteTypedOptimisticValue(DECIMAL_TYPE, info);</span>
        }

<span class="fc" id="L1313">        finishValue();</span>
<span class="fc" id="L1314">    }</span>

    public void writeTimestamp(final Timestamp value) throws IOException
    {
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1320">            writeNull(IonType.TIMESTAMP);</span>
<span class="fc" id="L1321">            return;</span>
        }
<span class="fc" id="L1323">        prepareValue();</span>

        // optimistically try to fit a timestamp length in low nibble (most should)
<span class="fc" id="L1326">        updateLength(1);</span>
<span class="fc" id="L1327">        pushContainer(ContainerType.VALUE);</span>
<span class="fc" id="L1328">        buffer.writeByte(TIMESTAMP_TYPE);</span>

        // OFFSET
<span class="fc" id="L1331">        final Integer offset = value.getLocalOffset();</span>
<span class="fc bfc" id="L1332" title="All 2 branches covered.">        if (offset == null)</span>
        {
            // special case for unknown -00:00
<span class="fc" id="L1335">            updateLength(1);</span>
<span class="fc" id="L1336">            buffer.writeByte(VARINT_NEG_ZERO);</span>
        }
        else
        {
<span class="fc" id="L1340">            writeVarInt(offset.intValue());</span>
        }

        // YEAR
<span class="fc" id="L1344">        final int year = value.getZYear();</span>
<span class="fc" id="L1345">        writeVarUInt(year);</span>

        // XXX it is really convenient to rely on the ordinal
<span class="fc" id="L1348">        final int precision = value.getPrecision().ordinal();</span>

<span class="fc bfc" id="L1350" title="All 2 branches covered.">        if (precision &gt;= MONTH.ordinal())</span>
        {
<span class="fc" id="L1352">            final int month = value.getZMonth();</span>
<span class="fc" id="L1353">            writeVarUInt(month);</span>
        }
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        if (precision &gt;= DAY.ordinal())</span>
        {
<span class="fc" id="L1357">            final int day = value.getZDay();</span>
<span class="fc" id="L1358">            writeVarUInt(day);</span>
        }
<span class="fc bfc" id="L1360" title="All 2 branches covered.">        if (precision &gt;= MINUTE.ordinal())</span>
        {
<span class="fc" id="L1362">            final int hour = value.getZHour();</span>
<span class="fc" id="L1363">            writeVarUInt(hour);</span>
<span class="fc" id="L1364">            final int minute = value.getZMinute();</span>
<span class="fc" id="L1365">            writeVarUInt(minute);</span>
        }
<span class="fc bfc" id="L1367" title="All 2 branches covered.">        if (precision &gt;= SECOND.ordinal())</span>
        {
<span class="fc" id="L1369">            final int second = value.getZSecond();</span>
<span class="fc" id="L1370">            writeVarUInt(second);</span>
<span class="fc" id="L1371">            final BigDecimal fraction = value.getZFractionalSecond();</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">            if (fraction != null) {</span>
<span class="fc" id="L1373">                final BigInteger mantissaBigInt = fraction.unscaledValue();</span>
<span class="fc" id="L1374">                final int exponent = -fraction.scale();</span>
<span class="fc bfc" id="L1375" title="All 4 branches covered.">                if (!(mantissaBigInt.equals(BigInteger.ZERO) &amp;&amp; exponent &gt; -1)) {</span>
<span class="fc" id="L1376">                    writeDecimalValue(fraction);</span>
                }
            }
        }

<span class="fc" id="L1381">        final ContainerInfo info = popContainer();</span>
<span class="fc" id="L1382">        patchSingleByteTypedOptimisticValue(TIMESTAMP_TYPE, info);</span>

<span class="fc" id="L1384">        finishValue();</span>
<span class="fc" id="L1385">    }</span>

    public void writeSymbol(String content) throws IOException
    {
<span class="nc" id="L1389">        throw new UnsupportedOperationException(&quot;Symbol writing via string is not supported in low-level binary writer&quot;);</span>
    }

    public void writeSymbolToken(final SymbolToken content) throws IOException
    {
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        if (content == null)</span>
        {
<span class="fc" id="L1396">            writeNull(IonType.SYMBOL);</span>
<span class="fc" id="L1397">            return;</span>
        }
<span class="fc" id="L1399">        writeSymbolToken(content.getSid());</span>
<span class="fc" id="L1400">    }</span>

    boolean isIVM(int sid)
    {
        // When SID 2 occurs at the top level with no annotations, it has the
        // special properties of an IVM. Otherwise, it's considered a normal
        // symbol value.
        // TODO amzn/ion-java/issues/88 requires this behavior to be changed,
        // such that top-level SID 2 is treated as a symbol value, not an IVM.
<span class="fc bfc" id="L1409" title="All 6 branches covered.">        return depth == 0 &amp;&amp; sid == ION_1_0_SID &amp;&amp; !hasAnnotations();</span>
    }

    public void writeSymbolToken(int sid) throws IOException
    {
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        if (isIVM(sid))</span>
        {
<span class="fc" id="L1416">            throw new IonException(&quot;Direct writing of IVM is not supported in low-level binary writer&quot;);</span>
        }
<span class="fc" id="L1418">        checkSid(sid);</span>
<span class="fc" id="L1419">        prepareValue();</span>
<span class="fc" id="L1420">        writeTypedUInt(SYMBOL_TYPE, sid);</span>
<span class="fc" id="L1421">        finishValue();</span>
<span class="fc" id="L1422">    }</span>

    public void writeString(final String value) throws IOException
    {
<span class="fc bfc" id="L1426" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L1428">            writeNull(IonType.STRING);</span>
<span class="fc" id="L1429">            return;</span>
        }
<span class="fc" id="L1431">        prepareValue();</span>

        // assume the string is ASCII and round up the sizing -- we should revisit this for CJK heavy use cases
<span class="fc" id="L1434">        int estUtf8Length = value.length();</span>
<span class="fc" id="L1435">        int preallocatedLength = 1;</span>
<span class="fc" id="L1436">        final long lengthPosition = buffer.position() + 1;</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">        if (estUtf8Length &lt;= 0xD)</span>
        {
            // size fits in low nibble
<span class="fc" id="L1440">            estUtf8Length = 0xD;</span>
<span class="fc" id="L1441">            buffer.writeUInt8(STRING_TYPE);</span>
        }
        else
        {
<span class="fc bfc" id="L1445" title="All 2 branches covered.">            if (estUtf8Length &lt;= 0x7F)</span>
            {
<span class="fc" id="L1447">                estUtf8Length = 0x7F;</span>
<span class="fc" id="L1448">                preallocatedLength = 2;</span>
<span class="fc" id="L1449">                buffer.writeBytes(STRING_TYPED_PREALLOCATED_2);</span>
            }
            else
            {
<span class="fc" id="L1453">                estUtf8Length = 0x3FFF;</span>
<span class="fc" id="L1454">                preallocatedLength = 3;</span>
<span class="fc" id="L1455">                buffer.writeBytes(STRING_TYPED_PREALLOCATED_3);</span>
            }
            // TODO decide if it is worth preallocating for &gt; 16KB strings
        }
<span class="fc" id="L1459">        updateLength(preallocatedLength);</span>

        // actually encode the string
<span class="fc" id="L1462">        final int utf8Length = buffer.writeUTF8(value);</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">        if (utf8Length &lt;= estUtf8Length)</span>
        {
            // we fit!
<span class="fc bfc" id="L1466" title="All 2 branches covered.">            if (utf8Length &lt;= 0xD)</span>
            {
                // special case for patching the type byte itself with the length
<span class="fc" id="L1469">                buffer.writeUInt8At(lengthPosition - 1, STRING_TYPE | utf8Length);</span>
            }
<span class="fc bfc" id="L1471" title="All 2 branches covered.">            else if (utf8Length &lt;= 0x7F)</span>
            {
<span class="fc" id="L1473">                buffer.writeVarUIntDirect1At(lengthPosition, utf8Length);</span>
            }
            else
            {
<span class="fc" id="L1477">                buffer.writeVarUIntDirect2At(lengthPosition, utf8Length);</span>
            }
        }
        else
        {
            // side patch
<span class="fc bfc" id="L1483" title="All 2 branches covered.">            if (estUtf8Length == 0xD)</span>
            {
                // we need to patch the type with the extended length
<span class="fc" id="L1486">                buffer.writeUInt8At(lengthPosition - 1, STRING_TYPE_EXTENDED_LENGTH);</span>
            }
<span class="fc" id="L1488">            addPatchPoint(lengthPosition, preallocatedLength - 1, utf8Length);</span>
        }

<span class="fc" id="L1491">        updateLength(utf8Length);</span>

<span class="fc" id="L1493">        finishValue();</span>
<span class="fc" id="L1494">    }</span>

    public void writeClob(byte[] data) throws IOException
    {
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1500">            writeNull(IonType.CLOB);</span>
<span class="fc" id="L1501">            return;</span>
        }
<span class="fc" id="L1503">        writeClob(data, 0, data.length);</span>
<span class="fc" id="L1504">    }</span>

    public void writeClob(final byte[] data, final int offset, final int length) throws IOException
    {
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1510">            writeNull(IonType.CLOB);</span>
<span class="fc" id="L1511">            return;</span>
        }
<span class="fc" id="L1513">        prepareValue();</span>
<span class="fc" id="L1514">        writeTypedBytes(CLOB_TYPE, data, offset, length);</span>
<span class="fc" id="L1515">        finishValue();</span>
<span class="fc" id="L1516">    }</span>

    public void writeBlob(byte[] data) throws IOException
    {
<span class="fc bfc" id="L1520" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1522">            writeNull(IonType.BLOB);</span>
<span class="fc" id="L1523">            return;</span>
        }
<span class="fc" id="L1525">        writeBlob(data, 0, data.length);</span>
<span class="fc" id="L1526">    }</span>

    public void writeBlob(final byte[] data, final int offset, final int length) throws IOException
    {
<span class="fc bfc" id="L1530" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1532">            writeNull(IonType.BLOB);</span>
<span class="fc" id="L1533">            return;</span>
        }
<span class="fc" id="L1535">        prepareValue();</span>
<span class="fc" id="L1536">        writeTypedBytes(BLOB_TYPE, data, offset, length);</span>
<span class="fc" id="L1537">        finishValue();</span>
<span class="fc" id="L1538">    }</span>

    @Override
    public void writeString(byte[] data, int offset, int length) throws IOException
    {
<span class="fc bfc" id="L1543" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L1545">            writeNull(IonType.STRING);</span>
<span class="fc" id="L1546">            return;</span>
        }
<span class="fc" id="L1548">        prepareValue();</span>
<span class="fc" id="L1549">        writeTypedBytes(STRING_TYPE, data, offset, length);</span>
<span class="fc" id="L1550">        finishValue();</span>
<span class="fc" id="L1551">    }</span>

    /**
     * Writes a raw value into the buffer, updating lengths appropriately.
     * &lt;p&gt;
     * The implication here is that the caller is dumping some valid Ion payload with the correct context.
     */
    public void writeBytes(byte[] data, int offset, int length) throws IOException
    {
<span class="fc" id="L1560">        prepareValue();</span>
<span class="fc" id="L1561">        updateLength(length);</span>
<span class="fc" id="L1562">        buffer.writeBytes(data, offset, length);</span>
<span class="fc" id="L1563">        finishValue();</span>
<span class="fc" id="L1564">    }</span>

    // Stream Manipulation/Terminators

    /*package*/ long position()
    {
<span class="fc" id="L1570">        return buffer.position();</span>
    }

    /*package*/ void truncate(long position)
    {
<span class="fc" id="L1575">        buffer.truncate(position);</span>
        // TODO decide if it is worth making this faster than O(N)
<span class="fc" id="L1577">        final PatchPoint patch = patchPoints.truncate(position);</span>
<span class="fc bfc" id="L1578" title="All 2 branches covered.">        if (patch != null)</span>
        {
<span class="fc" id="L1580">            patchBuffer.truncate(patch.patchPosition);</span>
        }
<span class="fc" id="L1582">    }</span>

<span class="nc" id="L1584">    public void flush() throws IOException {}</span>

    public void finish() throws IOException
    {
<span class="fc bfc" id="L1588" title="All 2 branches covered.">        if (closed)</span>
        {
<span class="fc" id="L1590">            return;</span>
        }
<span class="pc bpc" id="L1592" title="1 of 4 branches missed.">        if (!containers.isEmpty() || depth &gt; 0)</span>
        {
<span class="fc" id="L1594">            throw new IllegalStateException(&quot;Cannot finish within container: &quot; + containers);</span>
        }

<span class="fc bfc" id="L1597" title="All 2 branches covered.">        if (patchPoints.isEmpty())</span>
        {
            // nothing to patch--write 'em out!
<span class="fc" id="L1600">            buffer.writeTo(out);</span>
        }
        else
        {
<span class="fc" id="L1604">            long bufferPosition = 0;</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">            for (final PatchPoint patch : patchPoints)</span>
            {
                // write up to the thing to be patched
<span class="fc" id="L1608">                final long bufferLength = patch.oldPosition - bufferPosition;</span>
<span class="fc" id="L1609">                buffer.writeTo(out, bufferPosition, bufferLength);</span>

                // write out the patch
<span class="fc" id="L1612">                patchBuffer.writeTo(out, patch.patchPosition, patch.patchLength);</span>

                // skip over the preallocated varuint field
<span class="fc" id="L1615">                bufferPosition = patch.oldPosition;</span>
<span class="fc" id="L1616">                bufferPosition += patch.oldLength;</span>
<span class="fc" id="L1617">            }</span>
<span class="fc" id="L1618">            buffer.writeTo(out, bufferPosition, buffer.position() - bufferPosition);</span>
        }
<span class="fc" id="L1620">        patchPoints.clear();</span>
<span class="fc" id="L1621">        patchBuffer.reset();</span>
<span class="fc" id="L1622">        buffer.reset();</span>

<span class="fc bfc" id="L1624" title="All 2 branches covered.">        if (streamFlushMode == StreamFlushMode.FLUSH)</span>
        {
<span class="fc" id="L1626">            out.flush();</span>
        }

<span class="fc" id="L1629">        hasWrittenValuesSinceFinished = false;</span>
<span class="fc" id="L1630">    }</span>

    public void close() throws IOException
    {
<span class="fc bfc" id="L1634" title="All 2 branches covered.">        if (closed)</span>
        {
<span class="fc" id="L1636">            return;</span>
        }
        try
        {
            try
            {
<span class="fc" id="L1642">                finish();</span>
            }
<span class="fc" id="L1644">            catch (final IllegalStateException e)</span>
            {
                // callers don't expect this...
<span class="fc" id="L1647">            }</span>

            // release all of our blocks -- these should never throw
<span class="fc" id="L1650">            buffer.close();</span>
<span class="fc" id="L1651">            patchBuffer.close();</span>
<span class="fc" id="L1652">            allocator.close();</span>
        }
        finally
        {
<span class="fc" id="L1656">            closed = true;</span>
<span class="fc bfc" id="L1657" title="All 2 branches covered.">            if (streamCloseMode == StreamCloseMode.CLOSE)</span>
            {
                // release the stream
<span class="fc" id="L1660">                out.close();</span>
            }
        }
<span class="fc" id="L1663">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>