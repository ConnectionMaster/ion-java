<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WriteBuffer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl.bin</a> &gt; <span class="el_source">WriteBuffer.java</span></div><h1>WriteBuffer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl.bin;

import java.io.Closeable;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * A facade over {@link Block} management and low-level Ion encoding concerns for the {@link IonRawBinaryWriter}.
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">/*package*/ final class WriteBuffer implements Closeable</span>
{
    private final BlockAllocator allocator;
    private final List&lt;Block&gt; blocks;
    private Block current;
    private int index;

    public WriteBuffer(final BlockAllocator allocator)
<span class="fc" id="L34">    {</span>
<span class="fc" id="L35">        this.allocator = allocator;</span>
<span class="fc" id="L36">        this.blocks = new ArrayList&lt;Block&gt;();</span>

        // initial seed of the first block
<span class="fc" id="L39">        allocateNewBlock();</span>

<span class="fc" id="L41">        this.index = 0;</span>
<span class="fc" id="L42">        this.current = blocks.get(0);</span>
<span class="fc" id="L43">    }</span>

    private void allocateNewBlock()
    {
<span class="fc" id="L47">        blocks.add(allocator.allocateBlock());</span>
<span class="fc" id="L48">    }</span>

    /** Returns the block index for the given position. */
    private int index(final long position)
    {
<span class="fc" id="L53">        return (int) (position / allocator.getBlockSize());</span>
    }

    /** Returns the offset within the block for a given position. */
    private int offset(final long position)
    {
<span class="fc" id="L59">        return (int) (position % allocator.getBlockSize());</span>
    }

    /** Resets the write buffer to empty. */
    public void reset()
    {
<span class="fc" id="L65">        close();</span>
<span class="fc" id="L66">        allocateNewBlock();</span>
<span class="fc" id="L67">        index = 0;</span>
<span class="fc" id="L68">        current = blocks.get(index);</span>
<span class="fc" id="L69">    }</span>

    public void close()
    {
        // free all the blocks
<span class="fc bfc" id="L74" title="All 2 branches covered.">        for (final Block block : blocks)</span>
        {
<span class="fc" id="L76">            block.close();</span>
<span class="fc" id="L77">        }</span>
<span class="fc" id="L78">        blocks.clear();</span>

        // note--we don't explicitly flag that we're closed for efficiency
<span class="fc" id="L81">    }</span>

    /** Resets the write buffer to a particular point. */
    public void truncate(final long position)
    {
<span class="fc" id="L86">        final int index = index(position);</span>
<span class="fc" id="L87">        final int offset = offset(position);</span>
<span class="fc" id="L88">        final Block block = blocks.get(index);</span>
<span class="fc" id="L89">        this.index = index;</span>
<span class="fc" id="L90">        block.limit = offset;</span>
<span class="fc" id="L91">        current = block;</span>
<span class="fc" id="L92">    }</span>

    /** Returns the amount of capacity left in the current block. */
    public int remaining()
    {
<span class="fc" id="L97">        return current.remaining();</span>
    }

    /** Returns the logical position in the current block. */
    public long position()
    {
<span class="fc" id="L103">        return (((long) index) * allocator.getBlockSize()) + current.limit;</span>
    }

    private static final int OCTET_MASK = 0xFF;

    /** Returns the octet at the logical position given. */
    public int getUInt8At(final long position)
    {
<span class="fc" id="L111">        final int index = index(position);</span>
<span class="fc" id="L112">        final int offset = offset(position);</span>
<span class="fc" id="L113">        final Block block = blocks.get(index);</span>
<span class="fc" id="L114">        return block.data[offset] &amp; OCTET_MASK;</span>
    }

    /** Writes a single octet to the buffer, expanding if necessary. */
    public void writeByte(final byte octet)
    {
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (remaining() &lt; 1)</span>
        {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">            if (index == blocks.size() - 1)</span>
            {
<span class="fc" id="L124">                allocateNewBlock();</span>
            }
<span class="fc" id="L126">            index++;</span>
<span class="fc" id="L127">            current = blocks.get(index);</span>
        }
<span class="fc" id="L129">        final Block block = current;</span>
<span class="fc" id="L130">        block.data[block.limit] = octet;</span>
<span class="fc" id="L131">        block.limit++;</span>
<span class="fc" id="L132">    }</span>

    // slow in the sense that we do all kind of block boundary checking
    private void writeBytesSlow(final byte[] bytes, int off, int len)
    {
<span class="fc bfc" id="L137" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L139">            final Block block = current;</span>
<span class="fc" id="L140">            final int amount = Math.min(len, block.remaining());</span>
<span class="fc" id="L141">            System.arraycopy(bytes, off, block.data, block.limit, amount);</span>
<span class="fc" id="L142">            block.limit += amount;</span>
<span class="fc" id="L143">            off += amount;</span>
<span class="fc" id="L144">            len -= amount;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (block.remaining() == 0)</span>
            {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                if (index == blocks.size() - 1)</span>
                {
<span class="fc" id="L149">                    allocateNewBlock();</span>
                }
<span class="fc" id="L151">                index++;</span>
<span class="fc" id="L152">                current = blocks.get(index);</span>
            }
<span class="fc" id="L154">        }</span>

<span class="fc" id="L156">    }</span>

    /** Writes an array of bytes to the buffer expanding if necessary. */
    public void writeBytes(final byte[] bytes, final int off, final int len)
    {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (len &gt; remaining())</span>
        {
<span class="fc" id="L163">            writeBytesSlow(bytes, off, len);</span>
<span class="fc" id="L164">            return;</span>
        }

<span class="fc" id="L167">        final Block block = current;</span>
<span class="fc" id="L168">        System.arraycopy(bytes, off, block.data, block.limit, len);</span>
<span class="fc" id="L169">        block.limit += len;</span>
<span class="fc" id="L170">    }</span>

    /** Writes an array of bytes to the buffer expanding if necessary, defaulting to the entire array. */
    public void writeBytes(byte[] bytes)
    {
<span class="fc" id="L175">        writeBytes(bytes, 0, bytes.length);</span>
<span class="fc" id="L176">    }</span>

    // UTF-8 character writing

    private static final char HIGH_SURROGATE_FIRST      = 0xD800;
    private static final char HIGH_SURROGATE_LAST       = 0xDBFF;
    private static final char LOW_SURROGATE_FIRST       = 0xDC00;
    private static final char LOW_SURROGATE_LAST        = 0xDFFF;
    private static final int  SURROGATE_BASE            = 0x10000;
    private static final int  BITS_PER_SURROGATE        = 10;

    private static final int  UTF8_FOLLOW_MASK          = 0x3F;

    private static final int  UTF8_FOLLOW_PREFIX_MASK   = 0x80;
    private static final int  UTF8_2_OCTET_PREFIX_MASK  = 0xC0;
    private static final int  UTF8_3_OCTET_PREFIX_MASK  = 0xE0;
    private static final int  UTF8_4_OCTET_PREFIX_MASK  = 0xF0;

    private static final int  UTF8_BITS_PER_FOLLOW_OCTET = 6;
    private static final int  UTF8_2_OCTET_SHIFT         = 1 * UTF8_BITS_PER_FOLLOW_OCTET;
    private static final int  UTF8_3_OCTET_SHIFT         = 2 * UTF8_BITS_PER_FOLLOW_OCTET;
    private static final int  UTF8_4_OCTET_SHIFT         = 3 * UTF8_BITS_PER_FOLLOW_OCTET;

    private static final int UTF8_2_OCTET_MIN_VALUE = 1 &lt;&lt; 7;
    private static final int UTF8_3_OCTET_MIN_VALUE = 1 &lt;&lt; (5 + (1 * UTF8_BITS_PER_FOLLOW_OCTET));


    // slow in the sense that we deal with any kind of UTF-8 sequence and block boundaries
    private int writeUTF8Slow(final CharSequence chars, int off, int len)
    {
<span class="fc" id="L206">        int octets = 0;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L209">            final char ch = chars.charAt(off);</span>
<span class="pc bpc" id="L210" title="1 of 4 branches missed.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="fc" id="L212">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + (int) ch);</span>
            }
<span class="pc bpc" id="L214" title="1 of 4 branches missed.">            if ((ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST))</span>
            {
                // we need to look ahead in this case
<span class="fc" id="L217">                off++;</span>
<span class="fc" id="L218">                len--;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                if (len == 0)</span>
                {
<span class="fc" id="L221">                    throw new IllegalArgumentException(&quot;Unpaired low surrogate at end of character sequence: &quot; + ch);</span>
                }

<span class="fc" id="L224">                final int ch2 = chars.charAt(off);</span>
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">                if (ch2 &lt; LOW_SURROGATE_FIRST || ch2 &gt; LOW_SURROGATE_LAST)</span>
                {
<span class="fc" id="L227">                    throw new IllegalArgumentException(&quot;Low surrogate with unpaired high surrogate: &quot; + ch + &quot; + &quot; + ch2);</span>
                }

                // at this point we have a high and low surrogate
<span class="fc" id="L231">                final int codepoint = (((ch - HIGH_SURROGATE_FIRST) &lt;&lt; BITS_PER_SURROGATE) | (ch2 - LOW_SURROGATE_FIRST)) + SURROGATE_BASE;</span>
<span class="fc" id="L232">                writeByte((byte) (UTF8_4_OCTET_PREFIX_MASK | ( codepoint &gt;&gt; UTF8_4_OCTET_SHIFT)                    ));</span>
<span class="fc" id="L233">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ((codepoint &gt;&gt; UTF8_3_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L234">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ((codepoint &gt;&gt; UTF8_2_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L235">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ( codepoint                        &amp; UTF8_FOLLOW_MASK)));</span>

<span class="fc" id="L237">                octets += 4;</span>
<span class="fc" id="L238">            }</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            else if (ch &lt; UTF8_2_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L241">                writeByte((byte) ch);</span>
<span class="fc" id="L242">                octets++;</span>
            }
<span class="fc bfc" id="L244" title="All 2 branches covered.">            else if (ch &lt; UTF8_3_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L246">                writeByte((byte) (UTF8_2_OCTET_PREFIX_MASK | (ch &gt;&gt; UTF8_2_OCTET_SHIFT)                    ));</span>
<span class="fc" id="L247">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | (ch                        &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L248">                octets += 2;</span>
            }
            else
            {
<span class="fc" id="L252">                writeByte((byte) (UTF8_3_OCTET_PREFIX_MASK | ( ch &gt;&gt; UTF8_3_OCTET_SHIFT)                    ));</span>
<span class="fc" id="L253">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ((ch &gt;&gt; UTF8_2_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L254">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ( ch                        &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L255">                octets += 3;</span>
            }
<span class="fc" id="L257">            off++;</span>
<span class="fc" id="L258">            len--;</span>
<span class="fc" id="L259">        }</span>
<span class="fc" id="L260">        return octets;</span>
    }

    private int writeUTF8UpTo3Byte(final CharSequence chars, int off, int len)
    {
        // fast path if we fit in the block assuming optimistically for all three-byte
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if ((len * 3) &gt; remaining())</span>
        {
<span class="nc" id="L268">            return writeUTF8Slow(chars, off, len);</span>
        }

<span class="fc" id="L271">        final Block block = current;</span>
<span class="fc" id="L272">        int limit = block.limit;</span>
<span class="fc" id="L273">        int octets = 0;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L276">            final char ch = chars.charAt(off);</span>
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="nc" id="L279">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + ch);</span>
            }
<span class="fc bfc" id="L281" title="All 4 branches covered.">            if ((ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST))</span>
            {
                // we lost the 3-byte bet
<span class="fc" id="L284">                break;</span>
            }

<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (ch &lt; UTF8_2_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L289">                block.data[limit++] = (byte) ch;</span>
<span class="fc" id="L290">                octets++;</span>
            }
<span class="fc bfc" id="L292" title="All 2 branches covered.">            else if (ch &lt; UTF8_3_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L294">                block.data[limit++] = (byte) (UTF8_2_OCTET_PREFIX_MASK | (ch &gt;&gt; UTF8_2_OCTET_SHIFT)                    );</span>
<span class="fc" id="L295">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | (ch                        &amp; UTF8_FOLLOW_MASK));</span>
<span class="fc" id="L296">                octets += 2;</span>
            }
            else
            {
<span class="fc" id="L300">                block.data[limit++] = (byte) (UTF8_3_OCTET_PREFIX_MASK | ( ch &gt;&gt; UTF8_3_OCTET_SHIFT)                    );</span>
<span class="fc" id="L301">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | ((ch &gt;&gt; UTF8_2_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK));</span>
<span class="fc" id="L302">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | ( ch                        &amp; UTF8_FOLLOW_MASK));</span>
<span class="fc" id="L303">                octets += 3;</span>
            }
<span class="fc" id="L305">            off++;</span>
<span class="fc" id="L306">            len--;</span>
<span class="fc" id="L307">        }</span>
<span class="fc" id="L308">        block.limit = limit;</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (len &gt; 0)</span>
        {
            // just defer to 'slow' writing for non-BMP characters
<span class="nc" id="L313">            return octets + writeUTF8Slow(chars, off, len);</span>
        }
<span class="fc" id="L315">        return octets;</span>
    }

    private int writeUTF8UpTo2Byte(final CharSequence chars, int off, int len)
    {
        // fast path if we fit in the block assuming optimistically for all two-byte
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if ((len * 2) &gt; remaining())</span>
        {
<span class="fc" id="L323">            return writeUTF8Slow(chars, off, len);</span>
        }

<span class="fc" id="L326">        final Block block = current;</span>
<span class="fc" id="L327">        int limit = block.limit;</span>
<span class="fc" id="L328">        char ch = '\0';</span>
<span class="fc" id="L329">        int octets = 0;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L332">            ch = chars.charAt(off);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            if (ch &gt;= UTF8_3_OCTET_MIN_VALUE)</span>
            {
                // we lost the 2-byte bet
<span class="fc" id="L336">                break;</span>
            }

<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (ch &lt; UTF8_2_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L341">                block.data[limit++] = (byte) ch;</span>
<span class="fc" id="L342">                octets++;</span>
            }
            else
            {
<span class="fc" id="L346">                block.data[limit++] = (byte) (UTF8_2_OCTET_PREFIX_MASK | (ch &gt;&gt; UTF8_2_OCTET_SHIFT)                    );</span>
<span class="fc" id="L347">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | (ch                        &amp; UTF8_FOLLOW_MASK));</span>
<span class="fc" id="L348">                octets += 2;</span>
            }
<span class="fc" id="L350">            off++;</span>
<span class="fc" id="L351">            len--;</span>
        }
<span class="fc" id="L353">        block.limit = limit;</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (len &gt; 0)</span>
        {
<span class="pc bpc" id="L357" title="3 of 4 branches missed.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="nc" id="L359">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + ch);</span>
            }
<span class="pc bpc" id="L361" title="1 of 4 branches missed.">            if (ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST)</span>
            {
                // just defer to 'slow' writing for non-BMP characters
<span class="fc" id="L364">                return octets + writeUTF8Slow(chars, off, len);</span>
            }

            // we must be a three byte BMP character
<span class="fc" id="L368">            return octets + writeUTF8UpTo3Byte(chars, off, len);</span>
        }
<span class="fc" id="L370">        return octets;</span>
    }

    /** Returns the number of octets written. */
    public int writeUTF8(final CharSequence chars, int off, int len)
    {
        // fast path if we fit in the block assuming optimistically for all ASCII
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (len &gt; remaining())</span>
        {
<span class="fc" id="L379">            return writeUTF8Slow(chars, off, len);</span>
        }
<span class="fc" id="L381">        final Block block = current;</span>
<span class="fc" id="L382">        int limit = block.limit;</span>
<span class="fc" id="L383">        char ch = '\0';</span>
<span class="fc" id="L384">        int octets = 0;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L387">            ch = chars.charAt(off);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (ch &gt;= UTF8_2_OCTET_MIN_VALUE)</span>
            {
                // we lost the ASCII bet
<span class="fc" id="L391">                break;</span>
            }

<span class="fc" id="L394">            block.data[limit++] = (byte) ch;</span>
<span class="fc" id="L395">            octets++;</span>
<span class="fc" id="L396">            off++;</span>
<span class="fc" id="L397">            len--;</span>
        }
<span class="fc" id="L399">        block.limit = limit;</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (len &gt; 0)</span>
        {
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (ch &lt; UTF8_3_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L405">                return octets + writeUTF8UpTo2Byte(chars, off, len);</span>
            }
<span class="fc bfc" id="L407" title="All 4 branches covered.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="fc" id="L409">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + ch);</span>
            }
<span class="fc bfc" id="L411" title="All 4 branches covered.">            if (ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST)</span>
            {
                // just defer to 'slow' writing for non-BMP characters
<span class="fc" id="L414">                return octets + writeUTF8Slow(chars, off, len);</span>
            }

            // we must be a three byte BMP character
<span class="fc" id="L418">            return octets + writeUTF8UpTo3Byte(chars, off, len);</span>
        }
<span class="fc" id="L420">        return octets;</span>
    }

    /** Returns the number of octets written. */
    public int writeUTF8(final CharSequence chars)
    {
<span class="fc" id="L426">        return writeUTF8(chars, 0, chars.length());</span>
    }

    // unsigned fixed integer writes -- does not check sign/bounds

    private static final int UINT_2_OCTET_SHIFT = 8 * 1;
    private static final int UINT_3_OCTET_SHIFT = 8 * 2;
    private static final int UINT_4_OCTET_SHIFT = 8 * 3;
    private static final int UINT_5_OCTET_SHIFT = 8 * 4;
    private static final int UINT_6_OCTET_SHIFT = 8 * 5;
    private static final int UINT_7_OCTET_SHIFT = 8 * 6;
    private static final int UINT_8_OCTET_SHIFT = 8 * 7;


    public void writeUInt8(long value)
    {
<span class="fc" id="L442">        writeByte((byte) value);</span>
<span class="fc" id="L443">    }</span>

    private void writeUInt16Slow(long value)
    {
<span class="fc" id="L447">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L448">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L449">    }</span>

    public void writeUInt16(long value)
    {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (remaining() &lt; 2)</span>
        {
<span class="fc" id="L455">            writeUInt16Slow(value);</span>
<span class="fc" id="L456">            return;</span>
        }

<span class="fc" id="L459">        final Block block = current;</span>
<span class="fc" id="L460">        final byte[] data = block.data;</span>
<span class="fc" id="L461">        int limit = block.limit;</span>
<span class="fc" id="L462">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L463">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L464">        block.limit = limit;</span>
<span class="fc" id="L465">    }</span>

    private void writeUInt24Slow(long value)
    {
<span class="fc" id="L469">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L470">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L471">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L472">    }</span>

    public void writeUInt24(long value)
    {
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (remaining() &lt; 3)</span>
        {
<span class="fc" id="L478">            writeUInt24Slow(value);</span>
<span class="fc" id="L479">            return;</span>
        }

<span class="fc" id="L482">        final Block block = current;</span>
<span class="fc" id="L483">        final byte[] data = block.data;</span>
<span class="fc" id="L484">        int limit = block.limit;</span>
<span class="fc" id="L485">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L486">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L487">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L488">        block.limit = limit;</span>
<span class="fc" id="L489">    }</span>

    private void writeUInt32Slow(long value)
    {
<span class="fc" id="L493">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L494">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L495">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L496">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L497">    }</span>

    public void writeUInt32(long value)
    {
<span class="fc bfc" id="L501" title="All 2 branches covered.">        if (remaining() &lt; 4)</span>
        {
<span class="fc" id="L503">            writeUInt32Slow(value);</span>
<span class="fc" id="L504">            return;</span>
        }

<span class="fc" id="L507">        final Block block = current;</span>
<span class="fc" id="L508">        final byte[] data = block.data;</span>
<span class="fc" id="L509">        int limit = block.limit;</span>
<span class="fc" id="L510">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L511">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L512">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L513">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L514">        block.limit = limit;</span>
<span class="fc" id="L515">    }</span>

    private void writeUInt40Slow(long value)
    {
<span class="fc" id="L519">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L520">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L521">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L522">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L523">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L524">    }</span>

    public void writeUInt40(long value)
    {
<span class="fc bfc" id="L528" title="All 2 branches covered.">        if (remaining() &lt; 5)</span>
        {
<span class="fc" id="L530">            writeUInt40Slow(value);</span>
<span class="fc" id="L531">            return;</span>
        }

<span class="fc" id="L534">        final Block block = current;</span>
<span class="fc" id="L535">        final byte[] data = block.data;</span>
<span class="fc" id="L536">        int limit = block.limit;</span>
<span class="fc" id="L537">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L538">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L539">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L540">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L541">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L542">        block.limit = limit;</span>
<span class="fc" id="L543">    }</span>

    private void writeUInt48Slow(long value)
    {
<span class="fc" id="L547">        writeByte((byte) (value &gt;&gt; UINT_6_OCTET_SHIFT));</span>
<span class="fc" id="L548">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L549">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L550">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L551">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L552">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L553">    }</span>

    public void writeUInt48(long value)
    {
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (remaining() &lt; 6)</span>
        {
<span class="fc" id="L559">            writeUInt48Slow(value);</span>
<span class="fc" id="L560">            return;</span>
        }

<span class="fc" id="L563">        final Block block = current;</span>
<span class="fc" id="L564">        final byte[] data = block.data;</span>
<span class="fc" id="L565">        int limit = block.limit;</span>
<span class="fc" id="L566">        data[limit++] = (byte) (value &gt;&gt; UINT_6_OCTET_SHIFT);</span>
<span class="fc" id="L567">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L568">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L569">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L570">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L571">        data[limit++] = (byte) ( value                     );</span>
<span class="fc" id="L572">        block.limit = limit;</span>
<span class="fc" id="L573">    }</span>

    private void writeUInt56Slow(long value)
    {
<span class="fc" id="L577">        writeByte((byte) (value &gt;&gt; UINT_7_OCTET_SHIFT));</span>
<span class="fc" id="L578">        writeByte((byte) (value &gt;&gt; UINT_6_OCTET_SHIFT));</span>
<span class="fc" id="L579">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L580">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L581">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L582">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L583">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L584">    }</span>

    public void writeUInt56(long value)
    {
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (remaining() &lt; 7)</span>
        {
<span class="fc" id="L590">            writeUInt56Slow(value);</span>
<span class="fc" id="L591">            return;</span>
        }

<span class="fc" id="L594">        final Block block = current;</span>
<span class="fc" id="L595">        final byte[] data = block.data;</span>
<span class="fc" id="L596">        int limit = block.limit;</span>
<span class="fc" id="L597">        data[limit++] = (byte) (value &gt;&gt; UINT_7_OCTET_SHIFT);</span>
<span class="fc" id="L598">        data[limit++] = (byte) (value &gt;&gt; UINT_6_OCTET_SHIFT);</span>
<span class="fc" id="L599">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L600">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L601">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L602">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L603">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L604">        block.limit = limit;</span>
<span class="fc" id="L605">    }</span>

    private void writeUInt64Slow(long value)
    {
<span class="fc" id="L609">        writeByte((byte) (value &gt;&gt; UINT_8_OCTET_SHIFT));</span>
<span class="fc" id="L610">        writeByte((byte) (value &gt;&gt; UINT_7_OCTET_SHIFT));</span>
<span class="fc" id="L611">        writeByte((byte) (value &gt;&gt; UINT_6_OCTET_SHIFT));</span>
<span class="fc" id="L612">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L613">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L614">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L615">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L616">        writeByte((byte) ( value                     ));</span>
<span class="fc" id="L617">    }</span>

    public void writeUInt64(long value)
    {
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (remaining() &lt; 8)</span>
        {
<span class="fc" id="L623">            writeUInt64Slow(value);</span>
<span class="fc" id="L624">            return;</span>
        }

<span class="fc" id="L627">        final Block block = current;</span>
<span class="fc" id="L628">        final byte[] data = block.data;</span>
<span class="fc" id="L629">        int limit = block.limit;</span>
<span class="fc" id="L630">        data[limit++] = (byte) (value &gt;&gt; UINT_8_OCTET_SHIFT);</span>
<span class="fc" id="L631">        data[limit++] = (byte) (value &gt;&gt; UINT_7_OCTET_SHIFT);</span>
<span class="fc" id="L632">        data[limit++] = (byte) (value &gt;&gt; UINT_6_OCTET_SHIFT);</span>
<span class="fc" id="L633">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L634">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L635">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L636">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L637">        data[limit++] = (byte) ( value                      );</span>
<span class="fc" id="L638">        block.limit = limit;</span>


<span class="fc" id="L641">    }</span>

    // signed fixed integer writes - does not check bounds (especially important for IntX.MIN_VALUE).

    private static final long INT8_SIGN_MASK  = 1L &lt;&lt; ((8 * 1) - 1);
    private static final long INT16_SIGN_MASK = 1L &lt;&lt; ((8 * 2) - 1);
    private static final long INT24_SIGN_MASK = 1L &lt;&lt; ((8 * 3) - 1);
    private static final long INT32_SIGN_MASK = 1L &lt;&lt; ((8 * 4) - 1);
    private static final long INT40_SIGN_MASK = 1L &lt;&lt; ((8 * 5) - 1);
    private static final long INT48_SIGN_MASK = 1L &lt;&lt; ((8 * 6) - 1);
    private static final long INT56_SIGN_MASK = 1L &lt;&lt; ((8 * 7) - 1);
    private static final long INT64_SIGN_MASK = 1L &lt;&lt; ((8 * 8) - 1);

    public void writeInt8(long value)
    {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L658">            value = (-value) | INT8_SIGN_MASK;</span>
        }
<span class="fc" id="L660">        writeUInt8(value);</span>
<span class="fc" id="L661">    }</span>


    public void writeInt16(long value)
    {
<span class="fc bfc" id="L666" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L668">            value = (-value) | INT16_SIGN_MASK;</span>
        }
<span class="fc" id="L670">        writeUInt16(value);</span>
<span class="fc" id="L671">    }</span>

    public void writeInt24(long value)
    {
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L677">            value = (-value) | INT24_SIGN_MASK;</span>
        }
<span class="fc" id="L679">        writeUInt24(value);</span>
<span class="fc" id="L680">    }</span>


    public void writeInt32(long value)
    {
<span class="fc bfc" id="L685" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L687">            value = (-value) | INT32_SIGN_MASK;</span>
        }
<span class="fc" id="L689">        writeUInt32(value);</span>
<span class="fc" id="L690">    }</span>


    public void writeInt40(long value)
    {
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L697">            value = (-value) | INT40_SIGN_MASK;</span>
        }
<span class="fc" id="L699">        writeUInt40(value);</span>
<span class="fc" id="L700">    }</span>


    public void writeInt48(long value)
    {
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L707">            value = (-value) | INT48_SIGN_MASK;</span>
        }
<span class="fc" id="L709">        writeUInt48(value);</span>
<span class="fc" id="L710">    }</span>


    public void writeInt56(long value)
    {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L717">            value = (-value) | INT56_SIGN_MASK;</span>
        }
<span class="fc" id="L719">        writeUInt56(value);</span>
<span class="fc" id="L720">    }</span>


    public void writeInt64(long value)
    {
<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L727">            value = (-value) | INT64_SIGN_MASK;</span>
        }
<span class="fc" id="L729">        writeUInt64(value);</span>
<span class="fc" id="L730">    }</span>

    // variable length integer writing

    private static final long VAR_INT_BITS_PER_OCTET = 7;
    private static final long VAR_INT_MASK = 0x7F;

    private static final long VAR_UINT_9_OCTET_SHIFT = (8 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_9_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_9_OCTET_SHIFT);

    private static final long VAR_UINT_8_OCTET_SHIFT = (7 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_8_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_8_OCTET_SHIFT);

    private static final long VAR_UINT_7_OCTET_SHIFT = (6 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_7_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_7_OCTET_SHIFT);

    private static final long VAR_UINT_6_OCTET_SHIFT = (5 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_6_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_6_OCTET_SHIFT);

    private static final long VAR_UINT_5_OCTET_SHIFT = (4 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_5_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_5_OCTET_SHIFT);

    private static final long VAR_UINT_4_OCTET_SHIFT = (3 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_4_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_4_OCTET_SHIFT);

    private static final long VAR_UINT_3_OCTET_SHIFT = (2 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_3_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_3_OCTET_SHIFT);

    private static final long VAR_UINT_2_OCTET_SHIFT = (1 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_2_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_2_OCTET_SHIFT);

    private static final long VAR_INT_FINAL_OCTET_SIGNAL_MASK = 0x80;

    private int writeVarUIntSlow(final long value)
    {
<span class="fc" id="L765">        int size = 1;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_9_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L768">            writeUInt8((value &gt;&gt; VAR_UINT_9_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L769">            size++;</span>
        }
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_8_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L773">            writeUInt8((value &gt;&gt; VAR_UINT_8_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L774">            size++;</span>
        }
<span class="fc bfc" id="L776" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_7_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L778">            writeUInt8((value &gt;&gt; VAR_UINT_7_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L779">            size++;</span>
        }
<span class="fc bfc" id="L781" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_6_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L783">            writeUInt8((value &gt;&gt; VAR_UINT_6_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L784">            size++;</span>
        }
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_5_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L788">            writeUInt8((value &gt;&gt; VAR_UINT_5_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L789">            size++;</span>
        }
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_4_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L793">            writeUInt8((value &gt;&gt; VAR_UINT_4_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L794">            size++;</span>
        }
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_3_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L798">            writeUInt8((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L799">            size++;</span>
        }
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">        if (value &gt;= VAR_UINT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L803">            writeUInt8((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L804">            size++;</span>
        }
<span class="fc" id="L806">        writeUInt8((value &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L807">        return size;</span>
    }

    private int writeVarUIntDirect2(final long value)
    {
<span class="fc" id="L812">        final Block block = current;</span>
<span class="fc" id="L813">        final byte[] data = block.data;</span>
<span class="fc" id="L814">        int limit = block.limit;</span>
<span class="fc" id="L815">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L816">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L818">        block.limit = limit;</span>
<span class="fc" id="L819">        return 2;</span>
    }

    private int writeVarUIntDirect3(final long value)
    {
<span class="fc" id="L824">        final Block block = current;</span>
<span class="fc" id="L825">        final byte[] data = block.data;</span>
<span class="fc" id="L826">        int limit = block.limit;</span>
<span class="fc" id="L827">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L828">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L829">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L831">        block.limit = limit;</span>
<span class="fc" id="L832">        return 3;</span>
    }

    private int writeVarUIntDirect4(final long value)
    {
<span class="fc" id="L837">        final Block block = current;</span>
<span class="fc" id="L838">        final byte[] data = block.data;</span>
<span class="fc" id="L839">        int limit = block.limit;</span>
<span class="fc" id="L840">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_4_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L841">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L842">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L843">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L845">        block.limit = limit;</span>
<span class="fc" id="L846">        return 4;</span>
    }

    private int writeVarUIntDirect5(final long value)
    {
<span class="fc" id="L851">        final Block block = current;</span>
<span class="fc" id="L852">        final byte[] data = block.data;</span>
<span class="fc" id="L853">        int limit = block.limit;</span>
<span class="fc" id="L854">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_5_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L855">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_4_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L856">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L857">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L858">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L860">        block.limit = limit;</span>
<span class="fc" id="L861">        return 5;</span>
    }

    public int writeVarUInt(final long value)
    {
<span class="fc bfc" id="L866" title="All 2 branches covered.">        if (value &lt; VAR_UINT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L868">            writeUInt8((value &amp; 0x7F) | 0x80);</span>
<span class="fc" id="L869">            return 1;</span>
        }
<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (value &lt; VAR_UINT_3_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L873" title="All 2 branches covered.">            if (remaining() &lt; 2)</span>
            {
<span class="fc" id="L875">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L877">            return writeVarUIntDirect2(value);</span>
        }
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (value &lt; VAR_UINT_4_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L881" title="All 2 branches covered.">            if (remaining() &lt; 3)</span>
            {
<span class="fc" id="L883">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L885">            return writeVarUIntDirect3(value);</span>
        }
<span class="fc bfc" id="L887" title="All 2 branches covered.">        if (value &lt; VAR_UINT_5_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L889" title="All 2 branches covered.">            if (remaining() &lt; 4)</span>
            {
<span class="fc" id="L891">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L893">            return writeVarUIntDirect4(value);</span>
        }
<span class="fc bfc" id="L895" title="All 2 branches covered.">        if (value &lt; VAR_UINT_6_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L897" title="All 2 branches covered.">            if (remaining() &lt; 5)</span>
            {
<span class="fc" id="L899">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L901">            return writeVarUIntDirect5(value);</span>

        }
        // TODO determine if it is worth doing the fast path beyond 2**35 - 1

        // we give up--go to the 'slow' path
<span class="fc" id="L907">        return writeVarUIntSlow(value);</span>
    }

    private static final long VAR_INT_SIGNED_OCTET_MASK = 0x3F;
    private static final long VAR_INT_SIGNBIT_ON_MASK   = 0x40L;
    private static final long VAR_INT_SIGNBIT_OFF_MASK  = 0x00L;

    // note that the highest order bit for signed 64-bit values cannot fit in 9 bytes with the sign
    private static final long VAR_INT_10_OCTET_SHIFT = 62;

    private static final long VAR_INT_10_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_INT_10_OCTET_SHIFT);
    private static final long VAR_INT_9_OCTET_MIN_VALUE  = (VAR_UINT_9_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_8_OCTET_MIN_VALUE  = (VAR_UINT_8_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_7_OCTET_MIN_VALUE  = (VAR_UINT_7_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_6_OCTET_MIN_VALUE  = (VAR_UINT_6_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_5_OCTET_MIN_VALUE  = (VAR_UINT_5_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_4_OCTET_MIN_VALUE  = (VAR_UINT_4_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_3_OCTET_MIN_VALUE  = (VAR_UINT_3_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_2_OCTET_MIN_VALUE  = (VAR_UINT_2_OCTET_MIN_VALUE &gt;&gt; 1);

    private int writeVarIntSlow(final long magnitude, final long signMask)
    {
<span class="fc" id="L929">        int size = 1;</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_10_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L932">            writeUInt8(((magnitude &gt;&gt; VAR_INT_10_OCTET_SHIFT) &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask);</span>
<span class="fc" id="L933">            size++;</span>
        }
<span class="fc bfc" id="L935" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_9_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L937">            final long bits = (magnitude &gt;&gt; VAR_UINT_9_OCTET_SHIFT);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L939">            size++;</span>
        }
<span class="fc bfc" id="L941" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_8_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L943">            final long bits = (magnitude &gt;&gt; VAR_UINT_8_OCTET_SHIFT);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L945">            size++;</span>
        }
<span class="fc bfc" id="L947" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_7_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L949">            final long bits = (magnitude &gt;&gt; VAR_UINT_7_OCTET_SHIFT);</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L951">            size++;</span>
        }
<span class="fc bfc" id="L953" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_6_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L955">            final long bits = (magnitude &gt;&gt; VAR_UINT_6_OCTET_SHIFT);</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L957">            size++;</span>
        }
<span class="fc bfc" id="L959" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_5_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L961">            final long bits = (magnitude &gt;&gt; VAR_UINT_5_OCTET_SHIFT);</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L963">            size++;</span>
        }
<span class="fc bfc" id="L965" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_4_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L967">            final long bits = (magnitude &gt;&gt; VAR_UINT_4_OCTET_SHIFT);</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L969">            size++;</span>
        }
<span class="fc bfc" id="L971" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_3_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L973">            final long bits = (magnitude &gt;&gt; VAR_UINT_3_OCTET_SHIFT);</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L975">            size++;</span>
        }
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">        if (magnitude &gt;= VAR_INT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L979">            final long bits = (magnitude &gt;&gt; VAR_UINT_2_OCTET_SHIFT);</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L981">            size++;</span>
        }
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        writeUInt8((size == 1 ? ((magnitude &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (magnitude &amp; VAR_INT_MASK)) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L985">        return size;</span>
    }

    private static final long VAR_INT_BITS_PER_SIGNED_OCTET = 6;
    private static final long VAR_SINT_2_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (1 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_SINT_3_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (2 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_SINT_4_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (3 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_SINT_5_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (4 * VAR_INT_BITS_PER_OCTET);

    public int writeVarInt(long value)
    {
<span class="pc bpc" id="L996" title="2 of 4 branches missed.">        assert value != Long.MIN_VALUE;</span>

<span class="fc bfc" id="L998" title="All 2 branches covered.">        final long signMask = value &lt; 0 ? VAR_INT_SIGNBIT_ON_MASK : VAR_INT_SIGNBIT_OFF_MASK;</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">        final long magnitude = value &lt; 0 ? -value : value;</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">        if (magnitude &lt; VAR_INT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1002">            writeUInt8((magnitude &amp; VAR_INT_SIGNED_OCTET_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK | signMask);</span>
<span class="fc" id="L1003">            return 1;</span>
        }
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        final long signBit = value &lt; 0 ? 1 : 0;</span>
<span class="fc" id="L1006">        final int remaining = remaining();</span>
<span class="fc bfc" id="L1007" title="All 4 branches covered.">        if (magnitude &lt; VAR_INT_3_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 2)</span>
        {
<span class="fc" id="L1009">            return writeVarUIntDirect2(magnitude | (signBit &lt;&lt; VAR_SINT_2_OCTET_SHIFT));</span>
        }
<span class="fc bfc" id="L1011" title="All 4 branches covered.">        else if (magnitude &lt; VAR_INT_4_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 3)</span>
        {
<span class="fc" id="L1013">            return writeVarUIntDirect3(magnitude | (signBit &lt;&lt; VAR_SINT_3_OCTET_SHIFT));</span>
        }
<span class="fc bfc" id="L1015" title="All 4 branches covered.">        else if (magnitude &lt; VAR_INT_5_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 4)</span>
        {
<span class="fc" id="L1017">            return writeVarUIntDirect4(magnitude | (signBit &lt;&lt; VAR_SINT_4_OCTET_SHIFT));</span>
        }
<span class="fc bfc" id="L1019" title="All 4 branches covered.">        else if (magnitude &lt; VAR_INT_6_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 5)</span>
        {
<span class="fc" id="L1021">            return writeVarUIntDirect5(magnitude | (signBit &lt;&lt; VAR_SINT_5_OCTET_SHIFT));</span>
        }
        // TODO determine if it is worth doing the fast path beyond 2**34 - 1

        // we give up--go to the slow path
<span class="fc" id="L1026">        return writeVarIntSlow(magnitude, signMask);</span>
    }

    // write variable integer of specific size at a specified position -- no bounds checking, will not expand the buffer

    public void writeVarUIntDirect1At(final long position, final long value)
    {
<span class="fc" id="L1033">        writeUInt8At(position, (value &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L1034">    }</span>

    private void writeVarUIntDirect2StraddlingAt(final int index, final int offset, final long value)
    {
        // XXX we're stradling a block
<span class="fc" id="L1039">        final Block block1 = blocks.get(index);</span>
<span class="fc" id="L1040">        block1.data[offset] = (byte) ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L1041">        final Block block2 = blocks.get(index + 1);</span>
<span class="fc" id="L1042">        block2.data[0]      = (byte) ((value                            &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L1043">    }</span>

    public void writeVarUIntDirect2At(long position, long value)
    {
<span class="fc" id="L1047">        final int index = index(position);</span>
<span class="fc" id="L1048">        final int offset = offset(position);</span>

<span class="fc bfc" id="L1050" title="All 2 branches covered.">        if (offset + 2 &gt; allocator.getBlockSize())</span>
        {
<span class="fc" id="L1052">            writeVarUIntDirect2StraddlingAt(index, offset, value);</span>
<span class="fc" id="L1053">            return;</span>
        }

<span class="fc" id="L1056">        final Block block = blocks.get(index);</span>
<span class="fc" id="L1057">        block.data[offset    ] = (byte) ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L1058">        block.data[offset + 1] = (byte) ((value                            &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L1059">    }</span>

    public void writeUInt8At(final long position, final long value)
    {
<span class="fc" id="L1063">        final int index = index(position);</span>
<span class="fc" id="L1064">        final int offset = offset(position);</span>

        // XXX we'll never overrun a block unless we're given a position past our block array
<span class="fc" id="L1067">        final Block block = blocks.get(index);</span>
<span class="fc" id="L1068">        block.data[offset] = (byte) value;</span>
<span class="fc" id="L1069">    }</span>

    /** Write the entire buffer to output stream. */
    public void writeTo(final OutputStream out) throws IOException
    {
<span class="fc bfc" id="L1074" title="All 2 branches covered.">        for (int i = 0; i &lt;= index; i++)</span>
        {
<span class="fc" id="L1076">	    Block block = blocks.get(i);</span>
<span class="fc" id="L1077">	    out.write(block.data, 0, block.limit);</span>
        }
<span class="fc" id="L1079">    }</span>

    /** Write a specific segment of data from the buffer to a stream. */
    public void writeTo(final OutputStream out, long position, long length) throws IOException
    {
<span class="fc bfc" id="L1084" title="All 2 branches covered.">        while (length &gt; 0)</span>
        {
<span class="fc" id="L1086">            final int index = index(position);</span>
<span class="fc" id="L1087">            final int offset = offset(position);</span>
<span class="fc" id="L1088">            final Block block = blocks.get(index);</span>
<span class="fc" id="L1089">            final int amount = (int) Math.min(block.data.length - offset, length);</span>
<span class="fc" id="L1090">            out.write(block.data, offset, amount);</span>

<span class="fc" id="L1092">            position += amount;</span>
<span class="fc" id="L1093">            length -= amount;</span>
<span class="fc" id="L1094">        }</span>
<span class="fc" id="L1095">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>