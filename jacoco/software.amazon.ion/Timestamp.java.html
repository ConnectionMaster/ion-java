<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Timestamp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion</a> &gt; <span class="el_source">Timestamp.java</span></div><h1>Timestamp.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion;

import static software.amazon.ion.impl.PrivateUtils.safeEquals;
import static software.amazon.ion.util.IonTextUtils.printCodePointAsString;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import software.amazon.ion.impl.PrivateUtils;
import software.amazon.ion.util.IonTextUtils;

/**
 * An immutable representation of a point in time. Ion defines a simple
 * representation of time based on Coordinated Universal Time (UTC).
 * In practice the use of time could be more accurately described as
 * UTC-SLS (UTC Smoothed Leap Seconds) as there is no representation for the
 * leap second discontinuities that UTC has added.
 * &lt;p&gt;
 * Timestamps preserve precision, meaning the fields that are included, and the
 * significant digits of any fractional second.  Only common break
 * points in the values are supported.  Any unspecified fields are handled
 * as the start of the new year/month/day.
 *
 *
 * &lt;h3&gt;Equality and Comparison&lt;/h3&gt;
 *
 * As with {@link IonValue} classes, the {@link #equals equals} methods on this class
 * perform a strict equivalence that observes the precision and local offset
 * of each timestamp.
 * This means that it's possible to have two {@link Timestamp} instances that
 * represent the same point in time but are not {@code equals}.
 * &lt;p&gt;
 * On the other hand, the {@link #compareTo} methods perform point in time
 * comparison, ignoring precision and local offset.
 * Thus the &lt;em&gt;natural comparison method&lt;/em&gt; of this class is &lt;em&gt;not
 * consistent with equals&lt;/em&gt;. See the documentation of {@link Comparable} for
 * further discussion.
 * &lt;p&gt;
 * To illustrate this distinction, consider the following timestamps. None are
 * {@link #equals} to each other, but any pair will return a zero result from
 * {@link #compareTo}.
 * &lt;ul&gt;
 *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.000Z} &lt;em&gt;etc.&lt;/em&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 *
 * &lt;h4&gt;Date Arithmetic and Leap Years&lt;/h4&gt;
 * Date arithmetic is performed according to the logic provided by
 * {@link Calendar#add(int, int)}. When constructed by {@link Timestamp#forCalendar(Calendar)}
 * the new Timestamp and any other Timestamps that spawn from it (e.g. through
 * {@link #clone()}, {@link #addDay(int)}, etc.) will use the given Calendar's date arithmetic
 * rules, including its rules for determining leap years. When constructed without a
 * Calendar, a default GregorianCalendar (as constructed by
 * &lt;code&gt;new GregorianCalendar(TimeZone.getTimeZone(&quot;UTC&quot;))&lt;/code&gt; will be used.
 *
 * @see #equals(Timestamp)
 * @see #compareTo(Timestamp)
 */
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">public final class Timestamp</span>
    implements Comparable&lt;Timestamp&gt;, Cloneable
{
    private static final boolean APPLY_OFFSET_YES = true;
    private static final boolean APPLY_OFFSET_NO = false;

    private static final int NO_MONTH = 0;
    private static final int NO_DAY = 0;
    private static final int NO_HOURS = 0;
    private static final int NO_MINUTES = 0;
    private static final int NO_SECONDS = 0;
<span class="fc" id="L95">    private static final BigDecimal NO_FRACTIONAL_SECONDS = null;</span>

    /**
     * Unknown local offset from UTC.
     */
<span class="fc" id="L100">    public static final Integer UNKNOWN_OFFSET = null;</span>

    /**
     * Local offset of zero hours from UTC.
     */
<span class="fc" id="L105">    public static final Integer UTC_OFFSET = Integer.valueOf(0);</span>

    private static final int FLAG_YEAR      = 0x01;
    private static final int FLAG_MONTH     = 0x02;
    private static final int FLAG_DAY       = 0x04;
    private static final int FLAG_MINUTE    = 0x08;
    private static final int FLAG_SECOND    = 0x10;

    /**
     * The precision of the Timestamp.
     */
<span class="fc" id="L116">    public static enum Precision {</span>
<span class="fc" id="L117">        YEAR    (FLAG_YEAR),</span>
<span class="fc" id="L118">        MONTH   (FLAG_YEAR | FLAG_MONTH),</span>
<span class="fc" id="L119">        DAY     (FLAG_YEAR | FLAG_MONTH | FLAG_DAY),</span>
        // HOUR is not a supported precision per https://www.w3.org/TR/NOTE-datetime
<span class="fc" id="L121">        MINUTE  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE),</span>
<span class="fc" id="L122">        SECOND  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE | FLAG_SECOND);</span>

        /** Bit flags for the precision. */
        private final int flags;

        private Precision(int flags)
<span class="fc" id="L128">        {</span>
<span class="fc" id="L129">            this.flags = flags;</span>
<span class="fc" id="L130">        }</span>

        private boolean alwaysUnknownOffset()
        {
<span class="fc bfc" id="L134" title="All 2 branches covered.">            return this.ordinal() &lt;= DAY.ordinal();</span>
        }

        public boolean includes(Precision isIncluded)
        {
<span class="pc bpc" id="L139" title="1 of 6 branches missed.">            switch (isIncluded)</span>
            {
<span class="fc bfc" id="L141" title="All 2 branches covered.">                case SECOND:    return (flags &amp; FLAG_SECOND)   != 0;</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">                case MINUTE:    return (flags &amp; FLAG_MINUTE)   != 0;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                case DAY:       return (flags &amp; FLAG_DAY)      != 0;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">                case MONTH:     return (flags &amp; FLAG_MONTH)    != 0;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">                case YEAR:      return (flags &amp; FLAG_YEAR)     != 0;</span>
                default:        break;
            }
<span class="nc" id="L148">            throw new IllegalStateException(&quot;unrecognized precision&quot; + isIncluded);</span>
        }
    }

<span class="fc" id="L152">    private static final int HASH_SIGNATURE =</span>
<span class="fc" id="L153">        &quot;INTERNAL TIMESTAMP&quot;.hashCode();</span>

    /**
     * The precision of the Timestamp. The fractional seconds component is
     * defined by a BigDecimal.
     * &lt;p&gt;
     * During construction of all Timestamps, they will have a
     * date value (i.e. Year, Month, Day) but with reduced precision they may
     * exclude any time values that are more precise than the precision that is
     * being defined.
     */
    private Precision   _precision;

    /**
     * Calendar to hold the Timestamp's year, month, day, hour, minute, second, and calendar system. Fractional
     * seconds are left to {@link #_fraction}, while local offset is left to {@link #_offset}.
     */
    private final Calendar _calendar;

    /**
     * Fractional seconds. Must be within range [0, 1).
     */
    private BigDecimal  _fraction;

    /**
     * Minutes offset from UTC; zero means UTC proper,
     * &lt;code&gt;null&lt;/code&gt; means that the offset is unknown.
     */
    private Integer     _offset;

    // Minimum millis under the calendar system provided by the default GregorianCalendar implementation.
<span class="fc" id="L184">    private static final long MINIMUM_TIMESTAMP_IN_MILLIS = Timestamp.valueOf(&quot;0001-01-01T00:00:00.000Z&quot;).getMillis();</span>
<span class="fc" id="L185">    static final BigDecimal MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(MINIMUM_TIMESTAMP_IN_MILLIS);</span>

    // 10000T in millis, upper bound exclusive, under the calendar system provided by the default GregorianCalendar implementation.
<span class="fc" id="L188">    private static final long UPPER_BOUND_TIMESTAMP_IN_MILLIS = Timestamp.valueOf(&quot;9999-12-31T23:59:59.999-00:00&quot;).getMillis() + 1;</span>
<span class="fc" id="L189">    static final BigDecimal UPPER_BOUND_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(UPPER_BOUND_TIMESTAMP_IN_MILLIS);</span>

    /**
     * Applies the local time zone offset from UTC to the applicable time field
     * values. Depending on the local time zone offset, adjustments
     * (i.e. rollover) will be made to the calendar's year, day, hour, and minute
     * values.
     *
     * @param offset the local offset, in minutes from UTC.
     */
    private void apply_offset(int offset)
    {
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (offset == 0) return;</span>
<span class="pc bpc" id="L202" title="2 of 4 branches missed.">        if (offset &lt; -24*60 || offset &gt; 24*60) {</span>
<span class="nc" id="L203">            throw new IllegalArgumentException(&quot;bad offset &quot; + offset);</span>
        }
        // To convert _to_ UTC you must SUBTRACT the local offset
<span class="fc" id="L206">        offset = -offset;</span>
<span class="fc" id="L207">        int hour_offset = offset / 60;</span>
<span class="fc" id="L208">        int min_offset = offset - (hour_offset * 60);</span>
        // First, clear the offsets that are already set. Otherwise, the 'add' calls will add them in, which will
        // result in a double add.
<span class="fc" id="L211">        _calendar.clear(Calendar.ZONE_OFFSET);</span>
<span class="fc" id="L212">        _calendar.clear(Calendar.DST_OFFSET);</span>
<span class="fc" id="L213">        _calendar.add(Calendar.MINUTE, min_offset);</span>
<span class="fc" id="L214">        _calendar.add(Calendar.HOUR_OF_DAY, hour_offset);</span>
<span class="fc" id="L215">    }</span>

    /**
     * Create a Calendar from a number of milliseconds and the given local offset.
     * @param millis a number of epoch milliseconds.
     * @param localOffset a local offset in minutes.
     * @return a new Calendar.
     */
    private static Calendar calendarFromMillis(long millis, Integer localOffset) {
<span class="fc" id="L224">        Calendar calendar = new GregorianCalendar(PrivateUtils.UTC);</span>
<span class="fc" id="L225">        calendar.clear();</span>
<span class="fc" id="L226">        calendar.setTimeInMillis(millis);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (localOffset != null) {</span>
<span class="fc" id="L228">            calendar.set(Calendar.ZONE_OFFSET, localOffset * 60 * 1000);</span>
        }
<span class="fc" id="L230">        return calendar;</span>
    }

    /**
     * Copies data from a {@link Calendar} into this timestamp.
     * Must only be called during construction due to timestamp immutabliity.
     *
     * @param setLocalOffset if true and the given calendar has its ZONE_OFFSET set, sets the timestamp's _offset field.
     * @param applyLocalOffset if true and _offset has been set to a known offset, applies the local offset to the
     *                         timestamp's fields to convert them from local time to UTC. This should be false whenever
     *                         the given calendar is already in UTC (such as when it was constructed from millis).
     *
     * @throws IllegalArgumentException if the calendar has no fields set.
     */
    private void setFieldsFromCalendar(Precision precision,
                                       boolean setLocalOffset,
                                       boolean applyLocalOffset)
    {
<span class="fc" id="L248">        _precision = precision;</span>
<span class="fc" id="L249">        _offset = UNKNOWN_OFFSET;</span>
<span class="fc" id="L250">        boolean calendarHasMilliseconds = _calendar.isSet(Calendar.MILLISECOND);</span>

<span class="fc bfc" id="L252" title="All 3 branches covered.">        switch (this._precision) {</span>
            case SECOND:
<span class="fc bfc" id="L254" title="All 2 branches covered.">                if (calendarHasMilliseconds) {</span>
<span class="fc" id="L255">                    BigDecimal millis = BigDecimal.valueOf(_calendar.get(Calendar.MILLISECOND));</span>
<span class="fc" id="L256">                    this._fraction = millis.movePointLeft(3); // convert to fraction</span>
<span class="fc" id="L257">                    checkFraction(precision, this._fraction);</span>
                }
            case MINUTE:
            {
<span class="fc" id="L261">                int offset = _calendar.get(Calendar.ZONE_OFFSET);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                if (setLocalOffset)</span>
                {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                    if (_calendar.isSet(Calendar.DST_OFFSET)) {</span>
<span class="fc" id="L265">                        offset += _calendar.get(Calendar.DST_OFFSET);</span>
                    }
                    // convert ms to minutes
<span class="fc" id="L268">                    _offset = offset / (1000*60);</span>
                }
            }
            case DAY:
            case MONTH:
            case YEAR:
        }

<span class="fc bfc" id="L276" title="All 4 branches covered.">        if (_offset != UNKNOWN_OFFSET &amp;&amp; applyLocalOffset) {</span>
            // Transform our members from local time to Zulu
<span class="fc" id="L278">            this.apply_offset(_offset);</span>
        }
        // fractional seconds are ONLY tracked by the _fraction field.
<span class="fc" id="L281">        _calendar.clear(Calendar.MILLISECOND);</span>
<span class="fc" id="L282">        checkCalendarYear(_calendar);</span>
<span class="fc" id="L283">    }</span>

    /**
     * Creates a new Timestamp, precise to the year, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    private Timestamp(int zyear)
    {
<span class="fc" id="L292">        this(Precision.YEAR, zyear, NO_MONTH, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L293">    }</span>

    /**
     * Creates a new Timestamp, precise to the month, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    private Timestamp(int zyear, int zmonth)
    {
<span class="fc" id="L302">        this(Precision.MONTH, zyear, zmonth, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L303">    }</span>

    /**
     * Creates a new Timestamp, precise to the day, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     */
    @Deprecated
    private Timestamp(int zyear, int zmonth, int zday)
    {
<span class="fc" id="L313">        this(Precision.DAY, zyear, zmonth, zday, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L314">    }</span>


    /**
     * Creates a new Timestamp, precise to the minute, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     */
    @Deprecated
    private Timestamp(int year, int month, int day,
                     int hour, int minute,
                     Integer offset)
    {
<span class="fc" id="L334">        this(Precision.MINUTE, year, month, day, hour, minute, NO_SECONDS, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L335">    }</span>

    /**
     * Creates a new Timestamp, precise to the second, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     */
    @Deprecated
    private Timestamp(int year, int month, int day,
                     int hour, int minute, int second,
                     Integer offset)
    {
<span class="fc" id="L354">        this(Precision.SECOND, year, month, day, hour, minute, second, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L355">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     *
     * @param frac must be &gt;= 0 and &lt; 1
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @see #createFromUtcFields(Precision, int, int, int, int, int, int, BigDecimal, Integer)
     */
    private Timestamp(Precision p, int zyear, int zmonth, int zday,
                      int zhour, int zminute, int zsecond, BigDecimal frac,
                      Integer offset, boolean shouldApplyOffset)
<span class="fc" id="L378">    {</span>
<span class="fc" id="L379">        _calendar = new GregorianCalendar(PrivateUtils.UTC);</span>
<span class="fc" id="L380">        _calendar.clear();</span>
<span class="fc" id="L381">        boolean dayPrecision = false;</span>

<span class="pc bpc" id="L383" title="1 of 6 branches missed.">        switch (p) {</span>
        default:
<span class="nc" id="L385">            throw new IllegalArgumentException(&quot;invalid Precision passed to constructor&quot;);</span>
        case SECOND:
<span class="fc bfc" id="L387" title="All 4 branches covered.">            if (frac == null || frac.equals(BigDecimal.ZERO))</span>
            {
<span class="fc" id="L389">                _fraction = null;</span>
            }
            else
            {
<span class="fc" id="L393">                _fraction = frac.abs();</span>
            }
<span class="fc" id="L395">            _calendar.set(Calendar.SECOND, checkAndCastSecond(zsecond));</span>
        case MINUTE:
<span class="fc" id="L397">            _calendar.set(Calendar.MINUTE, checkAndCastMinute(zminute));</span>
<span class="fc" id="L398">            _calendar.set(Calendar.HOUR_OF_DAY, checkAndCastHour(zhour));</span>
<span class="fc" id="L399">            _offset = offset;      // offset must be null for years/months/days</span>
        case DAY:
<span class="fc" id="L401">             dayPrecision = true;</span>
        case MONTH:
<span class="fc" id="L403">            _calendar.set(Calendar.MONTH, checkAndCastMonth(zmonth) - 1);</span>
        case YEAR:
<span class="fc" id="L405">            _calendar.set(Calendar.YEAR, checkAndCastYear(zyear));</span>
        }

<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (dayPrecision)</span>
        {
<span class="fc" id="L410">            checkCalendarDay(zday);</span>
<span class="fc" id="L411">            _calendar.set(Calendar.DAY_OF_MONTH, zday);</span>
        }

<span class="fc" id="L414">        _precision = checkFraction(p, _fraction);</span>

<span class="fc bfc" id="L416" title="All 4 branches covered.">        if (shouldApplyOffset &amp;&amp; offset != null) {</span>
<span class="fc" id="L417">            apply_offset(offset);</span>
        }
<span class="fc" id="L419">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * As such, if the given {@code offset} is non-null or zero, the resulting
     * Timestamp will have time values that &lt;em&gt;DO NOT&lt;/em&gt; match the time
     * parameters. A default {@link GregorianCalendar} will be used to
     * perform any arithmetic operations on the resulting Timestamp. This
     * method also has a behavior of precision &quot;narrowing&quot;, detailed in the
     * sub-section below.
     *
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values (in its local time) respectively:
     *&lt;pre&gt;
     * createFromUtcFields(Precision.FRACTION, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;null&lt;/b&gt;)    will return 2012-02-03T04:05:06.007-00:00 (match)
     * createFromUtcFields(Precision.FRACTION, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;0&lt;/b&gt;)       will return 2012-02-03T04:05:06.007+00:00 (match)
     * createFromUtcFields(Precision.FRACTION, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;480&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;12&lt;/b&gt;:05:06.007&lt;b&gt;+08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.FRACTION, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-480&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;20&lt;/b&gt;:05:06.007&lt;b&gt;-08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.FRACTION, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;720&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;+12:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.FRACTION, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-720&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;-12:00&lt;/b&gt; (do not match)
     *&lt;/pre&gt;
     * Note: All of these resulting Timestamps have the similar value (in UTC) 2012-02-03T04:05:06.007Z.
     *
     * &lt;h3&gt;Precision &quot;Narrowing&quot;&lt;/h3&gt;
     *
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values respectively:
     *&lt;pre&gt;
     * createFromUtcFields(&lt;b&gt;Precision.YEAR&lt;/b&gt;    , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012T
     * createFromUtcFields(&lt;b&gt;Precision.MONTH&lt;/b&gt;   , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02T
     * createFromUtcFields(&lt;b&gt;Precision.DAY&lt;/b&gt;     , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T
     * createFromUtcFields(&lt;b&gt;Precision.MINUTE&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05Z
     * createFromUtcFields(&lt;b&gt;Precision.SECOND&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05:06Z
     * createFromUtcFields(&lt;b&gt;Precision.FRACTION&lt;/b&gt;, 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05:06.007Z
     *&lt;/pre&gt;
     *
     * @param p the desired timestamp precision. The result may have a
     * different precision if the input data isn't precise enough.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     * @deprecated This is an internal API that is subject to change without notice.
     */
    @Deprecated
    public static Timestamp
    createFromUtcFields(Precision p, int zyear, int zmonth, int zday,
                        int zhour, int zminute, int zsecond, BigDecimal frac,
                        Integer offset)
    {
<span class="fc" id="L479">        return new Timestamp(p, zyear, zmonth, zday,</span>
                             zhour, zminute, zsecond, frac,
                             offset, APPLY_OFFSET_NO);
    }

    /**
     * Creates a new Timestamp from a {@link Calendar}, preserving the
     * {@link Calendar}'s precision and local offset from UTC.
     * &lt;p&gt;
     * The most precise calendar field of {@code cal} will be used to determine
     * the precision of the resulting Timestamp.
     *
     * For example, the calendar field will have a Timestamp precision accordingly:
     * &lt;ul&gt;
     *   &lt;li&gt;{@link Calendar#YEAR} - year precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MONTH} - month precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#DAY_OF_MONTH} - day precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#HOUR_OF_DAY} or {@link Calendar#MINUTE} - minute precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#SECOND} - second precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MILLISECOND} - fractional second precision&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @throws IllegalArgumentException
     *          if {@code cal} has no appropriate calendar fields set.
     */
    @Deprecated
    private Timestamp(Calendar cal)
<span class="fc" id="L506">    {</span>
        Precision precision;

<span class="fc bfc" id="L509" title="All 4 branches covered.">        if (cal.isSet(Calendar.MILLISECOND) || cal.isSet(Calendar.SECOND)) {</span>
<span class="fc" id="L510">            precision = Precision.SECOND;</span>
        }
<span class="pc bpc" id="L512" title="1 of 4 branches missed.">        else if (cal.isSet(Calendar.HOUR_OF_DAY) || cal.isSet(Calendar.MINUTE)) {</span>
<span class="fc" id="L513">            precision = Precision.MINUTE;</span>
        }
<span class="fc bfc" id="L515" title="All 2 branches covered.">        else if (cal.isSet(Calendar.DAY_OF_MONTH)) {</span>
<span class="fc" id="L516">            precision = Precision.DAY;</span>
        }
<span class="fc bfc" id="L518" title="All 2 branches covered.">        else if (cal.isSet(Calendar.MONTH)) {</span>
<span class="fc" id="L519">            precision = Precision.MONTH;</span>
        }
<span class="fc bfc" id="L521" title="All 2 branches covered.">        else if (cal.isSet(Calendar.YEAR)) {</span>
<span class="fc" id="L522">            precision = Precision.YEAR;</span>
        }
        else {
<span class="fc" id="L525">            throw new IllegalArgumentException(&quot;Calendar has no fields set&quot;);</span>
        }
<span class="fc" id="L527">        _calendar = (Calendar) cal.clone();</span>
<span class="fc" id="L528">        setFieldsFromCalendar(precision, true, APPLY_OFFSET_YES);</span>
<span class="fc" id="L529">    }</span>


    private Timestamp(Calendar cal, Precision precision, BigDecimal fraction,
                      Integer offset)
<span class="fc" id="L534">    {</span>
<span class="fc" id="L535">        this._calendar = cal;</span>
<span class="fc" id="L536">        setFieldsFromCalendar(precision, false, APPLY_OFFSET_NO);</span>
<span class="fc" id="L537">        _fraction = fraction;</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (offset != null)</span>
        {
<span class="fc" id="L540">            _offset = offset;</span>
        }
<span class="fc" id="L542">    }</span>

    private static void throwTimestampOutOfRangeError(Number millis) {
<span class="fc" id="L545">        throw new IllegalArgumentException(&quot;millis: &quot; + millis + &quot; is outside of valid the range: from &quot;</span>
                + MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL
                + &quot; (0001T)&quot;
                + &quot;, inclusive, to &quot;
                + UPPER_BOUND_TIMESTAMP_IN_MILLIS_DECIMAL
                + &quot; (10000T)&quot;
                + &quot; , exclusive&quot;);
    }

    private Timestamp(BigDecimal millis, Precision precision, Integer localOffset)
<span class="fc" id="L555">    {</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (millis == null) throw new NullPointerException(&quot;millis is null&quot;);</span>

        // check bounds to avoid hanging when calling longValue() on decimals with large positive exponents,
        // e.g. 1e10000000
<span class="fc bfc" id="L560" title="All 2 branches covered.">        if(millis.compareTo(MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL) &lt; 0 ||</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                UPPER_BOUND_TIMESTAMP_IN_MILLIS_DECIMAL.compareTo(millis) &lt;= 0) {</span>
<span class="nc" id="L562">            throwTimestampOutOfRangeError(millis);</span>
        }

        // quick handle integral zero
<span class="fc bfc" id="L566" title="All 2 branches covered.">        long ms = isIntegralZero(millis) ? 0 : millis.longValue();</span>

<span class="fc" id="L568">        _calendar = calendarFromMillis(ms, localOffset);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        setFieldsFromCalendar(precision, localOffset != null, APPLY_OFFSET_NO);</span>

        // The given BigDecimal may contain greater than milliseconds precision, which is the maximum precision that
        // a Calendar can handle. Set the _fraction here so that extra precision (if any) is not lost.
        // However, don't set the fraction if the given BigDecimal does not have precision at least to the tenth of
        // a second.
<span class="pc bpc" id="L575" title="1 of 4 branches missed.">        if (precision.includes(Precision.SECOND) &amp;&amp; millis.scale() &gt; -3) {</span>
<span class="fc" id="L576">            BigDecimal secs = millis.movePointLeft(3);</span>
<span class="fc" id="L577">            BigDecimal secsDown = fastRoundZeroFloor(secs);</span>
<span class="fc" id="L578">            _fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L579">        } else {</span>
<span class="fc" id="L580">            _fraction = null;</span>
        }
<span class="fc" id="L582">        checkFraction(precision, _fraction);</span>
<span class="fc" id="L583">    }</span>


    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds (including any fractional
     * milliseconds) from the epoch, with a given local offset.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the second if {@code millis}
     * doesn't contain information that is more granular than seconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;132541995e4 (132541995 &amp;times; 10&lt;sup&gt;4&lt;/sup&gt;)&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30Z},
     * precise to the second.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second if
     * {@code millis} contains information that is at least granular to
     * milliseconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;1325419950555&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30.555Z},
     * precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     */
    @Deprecated
    private Timestamp(BigDecimal millis, Integer localOffset)
    {
<span class="fc" id="L621">        this(millis, Precision.SECOND, localOffset);</span>
<span class="fc" id="L622">    }</span>

    private BigDecimal fastRoundZeroFloor(final BigDecimal decimal) {
<span class="fc bfc" id="L625" title="All 2 branches covered.">        BigDecimal fastValue = decimal.signum() &lt; 0 ? BigDecimal.ONE.negate() : BigDecimal.ZERO;</span>

<span class="fc bfc" id="L627" title="All 2 branches covered.">        return isIntegralZero(decimal) ? fastValue : decimal.setScale(0, RoundingMode.FLOOR);</span>
    }

    private boolean isIntegralZero(final BigDecimal decimal) {
        // zero || no low-order bits || &lt; 1.0
<span class="fc bfc" id="L632" title="All 2 branches covered.">        return  decimal.signum() == 0</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">            || decimal.scale() &lt; -63</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            || (decimal.precision() - decimal.scale() &lt;= 0);</span>
    }

    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds from the epoch, with a given local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds from the epoch (1970-01-01T00:00:00.000Z)
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     */
    @Deprecated
    private Timestamp(long millis, Integer localOffset)
<span class="fc" id="L651">    {</span>
<span class="fc bfc" id="L652" title="All 4 branches covered.">        if(millis &lt; MINIMUM_TIMESTAMP_IN_MILLIS || millis &gt;= UPPER_BOUND_TIMESTAMP_IN_MILLIS) {</span>
<span class="nc" id="L653">            throwTimestampOutOfRangeError(millis);</span>
        }
<span class="fc" id="L655">        this._calendar = calendarFromMillis(millis, localOffset);</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">        setFieldsFromCalendar(Precision.SECOND, localOffset != null, APPLY_OFFSET_NO);</span>
<span class="fc" id="L657">    }</span>


    private static IllegalArgumentException fail(CharSequence input, String reason)
    {
<span class="fc" id="L662">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L663">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + reason</span>
                                            + &quot;: &quot; + input);
    }

    private static IllegalArgumentException fail(CharSequence input)
    {
<span class="fc" id="L669">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L670">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + input);</span>
    }

    static final String NULL_TIMESTAMP_IMAGE = &quot;null.timestamp&quot;;
<span class="fc" id="L674">    static final int    LEN_OF_NULL_IMAGE    = NULL_TIMESTAMP_IMAGE.length();</span>
    static final int    END_OF_YEAR          =  4;  // 1234T
    static final int    END_OF_MONTH         =  7;  // 1234-67T
    static final int    END_OF_DAY           = 10;  // 1234-67-90T
    static final int    END_OF_MINUTES       = 16;
    static final int    END_OF_SECONDS       = 19;


    /**
     * Returns a new Timestamp that represents the point in time, precision
     * and local offset defined in Ion format by the {@link CharSequence}.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     *
     * @param ionFormattedTimestamp
     *          a sequence of characters that is the Ion representation of a
     *          Timestamp
     *
     * @throws IllegalArgumentException
     *          if the {@code CharSequence} is an invalid Ion representation
     *          of a Timestamp;
     *          or if the {@code CharSequence} has excess characters which
     *          are not one of the following valid thirteen numeric-stop
     *          characters (escaped accordingly for readability):
     *          &lt;code&gt;{}[](),\&quot;\'\ \t\n\r}&lt;/code&gt;
     *
     * @return
     *          {@code null} if the {@code CharSequence} is &quot;null.timestamp&quot;
     *
     * @see &lt;a href=&quot;http://amzn.github.io/ion-docs/spec.html#timestamp&quot;&gt;Ion Timestamp Page&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;W3C Note on Date and Time Formats&lt;/a&gt;
     */
    public static Timestamp valueOf(CharSequence ionFormattedTimestamp)
    {
<span class="fc" id="L708">        final CharSequence in = ionFormattedTimestamp;</span>
        int pos;

<span class="fc" id="L711">        final int length = in.length();</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        if (length == 0)</span>
        {
<span class="nc" id="L714">            throw fail(in);</span>
        }

        // check for 'null.timestamp'
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (in.charAt(0) == 'n') {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">            if (length &gt;= LEN_OF_NULL_IMAGE</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">                &amp;&amp; NULL_TIMESTAMP_IMAGE.contentEquals(in.subSequence(0, LEN_OF_NULL_IMAGE)))</span>
            {
<span class="fc bfc" id="L722" title="All 2 branches covered.">                if (length &gt; LEN_OF_NULL_IMAGE) {</span>
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">                    if (!isValidFollowChar(in.charAt(LEN_OF_NULL_IMAGE))) {</span>
<span class="fc" id="L724">                        throw fail(in);</span>
                    }
                }
<span class="fc" id="L727">                return null;</span>
            }
<span class="fc" id="L729">            throw fail(in);</span>
        }

<span class="fc" id="L732">        int year  = 1;</span>
<span class="fc" id="L733">        int month = 1;</span>
<span class="fc" id="L734">        int day   = 1;</span>
<span class="fc" id="L735">        int hour  = 0;</span>
<span class="fc" id="L736">        int minute = 0;</span>
<span class="fc" id="L737">        int seconds = 0;</span>
<span class="fc" id="L738">        BigDecimal fraction = null;</span>
        Precision precision;

        // fake label to turn goto's into a break so Java is happy :) enjoy
        do {
            // otherwise we expect yyyy-mm-ddThh:mm:ss.ssss+hh:mm
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">            if (length &lt; END_OF_YEAR + 1) {  // +1 for the &quot;T&quot;</span>
<span class="nc" id="L745">                throw fail(in, &quot;year is too short (must be at least yyyyT)&quot;);</span>
            }
<span class="fc" id="L747">            pos = END_OF_YEAR;</span>
<span class="fc" id="L748">            precision = Precision.YEAR;</span>
<span class="fc" id="L749">            year  = read_digits(in, 0, 4, -1, &quot;year&quot;);</span>

<span class="fc" id="L751">            char c = in.charAt(END_OF_YEAR);</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L754">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between year and month, found &quot;
<span class="fc" id="L756">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L758" title="All 2 branches covered.">            if (length &lt; END_OF_MONTH + 1) {  // +1 for the &quot;T&quot;</span>
<span class="fc" id="L759">                throw fail(in, &quot;month is too short (must be yyyy-mmT)&quot;);</span>
            }
<span class="fc" id="L761">            pos = END_OF_MONTH;</span>
<span class="fc" id="L762">            precision = Precision.MONTH;</span>
<span class="fc" id="L763">            month = read_digits(in, END_OF_YEAR + 1, 2, -1,  &quot;month&quot;);</span>

<span class="fc" id="L765">            c = in.charAt(END_OF_MONTH);</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L768">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between month and day, found &quot;
<span class="fc" id="L770">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L772" title="All 2 branches covered.">            if (length &lt; END_OF_DAY) {</span>
<span class="fc" id="L773">                throw fail(in, &quot;too short for yyyy-mm-dd&quot;);</span>
            }
<span class="fc" id="L775">            pos = END_OF_DAY;</span>
<span class="fc" id="L776">            precision = Precision.DAY;</span>
<span class="fc" id="L777">            day   = read_digits(in, END_OF_MONTH + 1, 2, -1, &quot;day&quot;);</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">            if (length == END_OF_DAY) break;</span>
<span class="fc" id="L779">            c = in.charAt(END_OF_DAY);</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">            if (c != 'T') {</span>
<span class="fc" id="L781">                throw fail(in,</span>
                           &quot;expected \&quot;T\&quot; after day, found &quot;
<span class="fc" id="L783">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L785" title="All 2 branches covered.">            if (length == END_OF_DAY + 1) break;</span>

            // now lets see if we have a time value
<span class="fc bfc" id="L788" title="All 2 branches covered.">            if (length &lt; END_OF_MINUTES) {</span>
<span class="fc" id="L789">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm&quot;);</span>
            }
<span class="fc" id="L791">            hour   = read_digits(in, 11, 2, ':', &quot;hour&quot;);</span>
<span class="fc" id="L792">            minute = read_digits(in, 14, 2, -1, &quot;minutes&quot;);</span>
<span class="fc" id="L793">            pos = END_OF_MINUTES;</span>
<span class="fc" id="L794">            precision = Precision.MINUTE;</span>

            // we may have seconds
<span class="fc bfc" id="L797" title="All 4 branches covered.">            if (length &lt;= END_OF_MINUTES || in.charAt(END_OF_MINUTES) != ':')</span>
            {
<span class="fc" id="L799">                break;</span>
            }
<span class="fc bfc" id="L801" title="All 2 branches covered.">            if (length &lt; END_OF_SECONDS) {</span>
<span class="fc" id="L802">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm:ss&quot;);</span>
            }
<span class="fc" id="L804">            seconds = read_digits(in, 17, 2, -1, &quot;seconds&quot;);</span>
<span class="fc" id="L805">            pos = END_OF_SECONDS;</span>
<span class="fc" id="L806">            precision = Precision.SECOND;</span>

<span class="fc bfc" id="L808" title="All 4 branches covered.">            if (length &lt;= END_OF_SECONDS || in.charAt(END_OF_SECONDS) != '.')</span>
            {
<span class="fc" id="L810">                break;</span>
            }
<span class="fc" id="L812">            precision = Precision.SECOND;</span>
<span class="fc" id="L813">            pos = END_OF_SECONDS + 1;</span>
<span class="fc bfc" id="L814" title="All 4 branches covered.">            while (length &gt; pos &amp;&amp; Character.isDigit(in.charAt(pos))) {</span>
<span class="fc" id="L815">                pos++;</span>
            }
<span class="fc bfc" id="L817" title="All 2 branches covered.">            if (pos &lt;= END_OF_SECONDS + 1) {</span>
<span class="fc" id="L818">                throw fail(in,</span>
                           &quot;must have at least one digit after decimal point&quot;);
            }
<span class="fc" id="L821">            fraction = new BigDecimal(in.subSequence(19, pos).toString());</span>
        } while (false);

        Integer offset;

        // now see if they included a timezone offset
<span class="fc bfc" id="L827" title="All 2 branches covered.">        char timezone_start = pos &lt; length ? in.charAt(pos) : '\n';</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">        if (timezone_start == 'Z') {</span>
<span class="fc" id="L829">            offset = 0;</span>
<span class="fc" id="L830">            pos++;</span>
        }
<span class="fc bfc" id="L832" title="All 4 branches covered.">        else if (timezone_start == '+' || timezone_start == '-')</span>
        {
<span class="fc bfc" id="L834" title="All 2 branches covered.">            if (length &lt; pos + 5) {</span>
<span class="fc" id="L835">                throw fail(in, &quot;local offset too short&quot;);</span>
            }
            // +/- hh:mm
<span class="fc" id="L838">            pos++;</span>
<span class="fc" id="L839">            int tzdHours = read_digits(in, pos, 2, ':', &quot;local offset hours&quot;);</span>
<span class="pc bpc" id="L840" title="1 of 4 branches missed.">            if (tzdHours &lt; 0 || tzdHours &gt; 23) {</span>
<span class="fc" id="L841">                throw fail(in,</span>
                           &quot;local offset hours must be between 0 and 23 inclusive&quot;);
            }
<span class="fc" id="L844">            pos += 3;</span>

<span class="fc" id="L846">            int tzdMinutes = read_digits(in, pos, 2, -1, &quot;local offset minutes&quot;);</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">            if (tzdMinutes &gt; 59) {</span>
<span class="fc" id="L848">                throw fail(in,</span>
                           &quot;local offset minutes must be between 0 and 59 inclusive&quot;);
            }
<span class="fc" id="L851">            pos += 2;</span>

<span class="fc" id="L853">            int temp = tzdHours * 60 + tzdMinutes;</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (timezone_start == '-') {</span>
<span class="fc" id="L855">                temp = -temp;</span>
            }
<span class="fc bfc" id="L857" title="All 4 branches covered.">            if (temp == 0 &amp;&amp; timezone_start == '-') {</span>
                // int doesn't do negative zero very elegantly
<span class="fc" id="L859">                offset = null;</span>
            }
            else {
<span class="fc" id="L862">                offset = temp;</span>
            }
<span class="fc" id="L864">        }</span>
        else {
<span class="fc bfc" id="L866" title="All 2 branches covered.">            switch (precision) {</span>
                case YEAR:
                case MONTH:
                case DAY:
<span class="fc" id="L870">                    break;</span>
                default:
<span class="fc" id="L872">                    throw fail(in, &quot;missing local offset&quot;);</span>
            }
<span class="fc" id="L874">            offset = null;</span>
        }
<span class="pc bpc" id="L876" title="1 of 4 branches missed.">        if (length &gt; (pos + 1) &amp;&amp; !isValidFollowChar(in.charAt(pos + 1)))</span>
        {
<span class="fc" id="L878">            throw fail(in, &quot;invalid excess characters&quot;);</span>
        }

<span class="fc" id="L881">        Timestamp ts =</span>
            new Timestamp(precision, year, month, day,
                          hour, minute, seconds, fraction, offset, APPLY_OFFSET_YES);
<span class="fc" id="L884">        return ts;</span>
    }

    private static int read_digits(CharSequence in, int start, int length,
                                   int terminator, String field)
    {
<span class="fc" id="L890">        int ii, value = 0;</span>
<span class="fc" id="L891">        int end = start + length;</span>

<span class="fc bfc" id="L893" title="All 2 branches covered.">        if (in.length() &lt; end) {</span>
<span class="fc" id="L894">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits&quot;);
        }

<span class="fc bfc" id="L898" title="All 2 branches covered.">        for (ii=start; ii&lt;end; ii++) {</span>
<span class="fc" id="L899">            char c = in.charAt(ii);</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">            if (!Character.isDigit(c)) {</span>
                // FIXME this will give incorrect message if c is a surrogate
<span class="fc" id="L902">                throw fail(in,</span>
                           field + &quot; has non-digit character &quot;
<span class="fc" id="L904">                               + printCodePointAsString(c));</span>
            }
<span class="fc" id="L906">            value *= 10;</span>
<span class="fc" id="L907">            value += c - '0';</span>
        }

        // Check the terminator if requested.
<span class="fc bfc" id="L911" title="All 2 branches covered.">        if (terminator != -1) {</span>
<span class="pc bpc" id="L912" title="1 of 4 branches missed.">            if (ii &gt;= in.length() || in.charAt(ii) != terminator) {</span>
<span class="fc" id="L913">                throw fail(in,</span>
                           field + &quot; should end with &quot;
<span class="fc" id="L915">                               + printCodePointAsString(terminator));</span>
            }
        }
        // Otherwise make sure we don't have too many digits.
<span class="fc bfc" id="L919" title="All 4 branches covered.">        else if (ii &lt; in.length() &amp;&amp; Character.isDigit(in.charAt(ii))) {</span>
<span class="fc" id="L920">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits but has more&quot;);
        }

<span class="fc" id="L924">        return value;</span>
    }

    private static boolean isValidFollowChar(char c) {
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        switch (c) {</span>
        default:
<span class="fc" id="L930">            return false;</span>
        case '{':
        case '}':
        case '[':
        case ']':
        case '(':
        case ')':
        case ',':
        case '\&quot;':
        case '\'':
        case '\\':
        case '\t':
        case '\n':
        case '\r':
<span class="nc" id="L944">            return true;</span>
        }
    }

    /**
     * Creates a copy of this Timestamp. The resulting Timestamp will
     * represent the same point in time, have the same precision and local
     * offset, and use the same calendar system for date arithmetic.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public Timestamp clone()
    {
<span class="fc" id="L958">        return new Timestamp((Calendar) _calendar.clone(), _precision, _fraction, _offset);</span>
    }

    /**
     * Applies the local offset from UTC to each of the applicable time field
     * values and returns the new Timestamp. In short, this makes the Timestamp
     * represent local time.
     *
     * @return a new Timestamp in its local time
     */
    private Timestamp make_localtime()
    {
<span class="fc bfc" id="L970" title="All 2 branches covered.">        int offset = _offset != null</span>
<span class="fc" id="L971">            ? _offset.intValue()</span>
<span class="fc" id="L972">            : 0;</span>

<span class="fc" id="L974">        Timestamp localtime = clone();</span>
        // explicitly apply the local offset to the time field values
<span class="fc" id="L976">        localtime.apply_offset(-offset);</span>

<span class="pc bpc" id="L978" title="2 of 4 branches missed.">        assert localtime._offset == _offset;</span>

<span class="fc" id="L980">        return localtime;</span>
    }

    /**
     * Returns a Timestamp, precise to the year, with unknown local offset.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    public static Timestamp forYear(int yearZ)
    {
<span class="fc" id="L992">        return new Timestamp(yearZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the month, with unknown local offset.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    public static Timestamp forMonth(int yearZ, int monthZ)
    {
<span class="fc" id="L1004">        return new Timestamp(yearZ, monthZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the day, with unknown local offset.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     *
     */
    public static Timestamp forDay(int yearZ, int monthZ, int dayZ)
    {
<span class="fc" id="L1017">        return new Timestamp(yearZ, monthZ, dayZ);</span>
    }


    /**
     * Returns a Timestamp, precise to the minute, with a given local
     * offset. A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forMinute(int year, int month, int day,
                                      int hour, int minute,
                                      Integer offset)
    {
<span class="fc" id="L1039">        return new Timestamp(year, month, day, hour, minute, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, int second,
                                      Integer offset)
    {
<span class="fc" id="L1061">        return new Timestamp(year, month, day, hour, minute, second, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss.sss+-oo:oo}, where {@code oo:oo} represents
     * the hour and minutes of the local offset from UTC.
     *
     * @param second must be at least zero and less than 60.
     * Must not be null.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, BigDecimal second,
                                      Integer offset)
    {
        // Tease apart the whole and fractional seconds.
        // Storing them separately is silly.
<span class="fc" id="L1088">        int s = second.intValue();</span>
<span class="fc" id="L1089">        BigDecimal frac = second.subtract(BigDecimal.valueOf(s));</span>
<span class="fc" id="L1090">        return new Timestamp(Precision.SECOND, year, month, day, hour, minute, s, frac, offset, APPLY_OFFSET_YES);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is
     * {@code millis} milliseconds from the epoch, with a given local offset.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * &lt;strong&gt;NOTE:&lt;/strong&gt; this means that providing a number of milliseconds
     * that was produced using a different calendar system may result in a Timestamp
     * that represents a different point in time than the one that originally
     * produced the milliseconds. In this case, {@link #forCalendar(Calendar)} should
     * be used instead.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @param millis
     * the number of milliseconds from the epoch (1970-01-01T00:00:00.000Z).
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     */
    public static Timestamp forMillis(long millis, Integer localOffset)
    {
<span class="fc" id="L1117">        return new Timestamp(millis, localOffset);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is
     * {@code millis} milliseconds (including any fractional
     * milliseconds) from the epoch, with a given local offset.
     * A default {@link GregorianCalendar} will be used to perform any
     * arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * &lt;strong&gt;NOTE:&lt;/strong&gt; this means that providing a number of milliseconds
     * that was produced using a different calendar system may result in a Timestamp
     * that represents a different point in time than the one that originally
     * produced the milliseconds. In this case, {@link #forCalendar(Calendar)} should
     * be used instead.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the second if {@code millis}
     * doesn't contain information that is more granular than seconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;132541995e4 (132541995 &amp;times; 10&lt;sup&gt;4&lt;/sup&gt;)&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30Z},
     * precise to the second.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second if
     * {@code millis} contains information that is at least granular to
     * milliseconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;1325419950555&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30.555Z},
     * precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     *
     */
    public static Timestamp forMillis(BigDecimal millis, Integer localOffset)
    {
<span class="fc" id="L1163">        return new Timestamp(millis, localOffset);</span>
    }


    /**
     * Converts a {@link Calendar} to a Timestamp, preserving the calendar's
     * time zone as the equivalent local offset when it has at least minutes
     * precision. The given Calendar will be used to perform any arithmetic
     * operations on the resulting Timestamp.
     *
     * @return a Timestamp instance, with precision determined by the smallest
     *   field set in the {@code Calendar};
     *   or {@code null} if {@code calendar} is {@code null}
     *
     */
    public static Timestamp forCalendar(Calendar calendar)
    {
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">        if (calendar == null) return null;</span>
<span class="fc" id="L1181">        return new Timestamp(calendar);</span>
    }


    /**
     * Converts a {@link Date} to a Timestamp in UTC representing the same
     * point in time. A default {@link GregorianCalendar} will be used to perform
     * any arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the millisecond;
     *          {@code null} if {@code date} is {@code null}
     *
     */
    public static Timestamp forDateZ(Date date)
    {
<span class="fc bfc" id="L1199" title="All 2 branches covered.">        if (date == null) return null;</span>
<span class="fc" id="L1200">        long millis = date.getTime();</span>
<span class="fc" id="L1201">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts a {@link java.sql.Timestamp} to a Timestamp in UTC representing
     * the same point in time. A default {@link GregorianCalendar} will be used to perform
     * any arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the nanosecond.
     *
     * @param sqlTimestamp assumed to have nanoseconds precision
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the
     *          nanosecond
     *          {@code null} if {@code sqlTimestamp} is {@code null}
     *
     */
    public static Timestamp forSqlTimestampZ(java.sql.Timestamp sqlTimestamp)
    {
<span class="fc bfc" id="L1222" title="All 2 branches covered.">        if (sqlTimestamp == null) return null;</span>

<span class="fc" id="L1224">        long millis = sqlTimestamp.getTime();</span>
<span class="fc" id="L1225">        Timestamp ts = new Timestamp(millis, UTC_OFFSET);</span>
<span class="fc" id="L1226">        int nanos = sqlTimestamp.getNanos();</span>
<span class="fc" id="L1227">        BigDecimal frac = BigDecimal.valueOf(nanos).movePointLeft(9);</span>
<span class="fc" id="L1228">        ts._fraction = frac;</span>
<span class="fc" id="L1229">        return ts;</span>
    }


    /**
     * Returns a Timestamp representing the current time (based on the JVM
     * clock), with an unknown local offset. A default {@link GregorianCalendar}
     * will be used to perform any arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance representing the current time.
     */
    public static Timestamp now()
    {
<span class="nc" id="L1245">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1246">        return new Timestamp(millis, UNKNOWN_OFFSET);</span>
    }

    /**
     * Returns a Timestamp in UTC representing the current time (based on the
     * the JVM clock). A default {@link GregorianCalendar} will be used to perform
     * any arithmetic operations on the resulting Timestamp.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, representing the current
     *          time.
     *
     */
    public static Timestamp nowZ()
    {
<span class="nc" id="L1263">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1264">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts the value of this Timestamp into a {@link Date},
     * representing the time in UTC.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     * &lt;p&gt;
     * Because {@link Date} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Date} instance, in UTC
     */
    public Date dateValue()
    {
<span class="fc" id="L1282">        long millis = getMillis();</span>
<span class="fc" id="L1283">        return new Date(millis);</span>
    }

    /**
     * Converts the value of this Timestamp as a {@link Calendar}, in its
     * local time. The resulting Calendar will have its fields set up to
     * this Timestamp's precision. The maximum fractional precision supported
     * by Calendar is milliseconds; any additional precision will be truncated.
     * &lt;p&gt;
     * Because {@link Calendar} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Calendar} instance, in its local time.
     *
     */
    public Calendar calendarValue()
    {
<span class="fc" id="L1300">        Calendar cal = (Calendar) _calendar.clone();</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">        if (_precision.includes(Precision.SECOND)) {</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">            if (this._fraction != null)</span>
            {
<span class="fc" id="L1304">                int fractionalMillis = this._fraction.movePointRight(3).intValue();</span>
<span class="fc" id="L1305">                cal.set(Calendar.MILLISECOND, fractionalMillis);</span>
            }
        }
<span class="fc bfc" id="L1308" title="All 6 branches covered.">        if (_precision.includes(Precision.MINUTE) &amp;&amp; _offset != null &amp;&amp; _offset != 0)</span>
        {
<span class="fc" id="L1310">            int offsetMillis = _offset * 60 * 1000;</span>
<span class="fc" id="L1311">            cal.add(Calendar.MILLISECOND, offsetMillis);</span>
<span class="fc" id="L1312">            cal.set(Calendar.ZONE_OFFSET, offsetMillis);</span>
        }
<span class="fc bfc" id="L1314" title="All 2 branches covered.">        if (!_precision.includes(Precision.SECOND)) {</span>
<span class="fc" id="L1315">            cal.clear(Calendar.SECOND);</span>
        }
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        if (_fraction == null) {</span>
<span class="fc" id="L1318">            cal.clear(Calendar.MILLISECOND);</span>
        }
<span class="fc" id="L1320">        return cal;</span>
    }


    /**
     * Returns a number representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional milliseconds)
     * from the epoch, using this Timestamp's configured Calendar.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    public long getMillis()
    {
<span class="fc" id="L1338">        long millis = _calendar.getTimeInMillis();</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">        if (this._fraction != null) {</span>
<span class="fc" id="L1340">            BigDecimal fracAsDecimal = this._fraction.movePointRight(3);</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">            int frac = isIntegralZero(fracAsDecimal) ? 0 : fracAsDecimal.intValue();</span>
<span class="fc" id="L1342">            millis += frac;</span>
        }
<span class="fc" id="L1344">        return millis;</span>

    }

    /**
     * Returns a BigDecimal representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional milliseconds)
     * from the epoch, using this Timestamp's configured Calendar.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    public BigDecimal getDecimalMillis()
    {
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">        switch (this._precision) {</span>
        case YEAR:
        case MONTH:
        case DAY:
        case MINUTE:
        case SECOND:
<span class="fc" id="L1368">            long millis = _calendar.getTimeInMillis();</span>
<span class="fc" id="L1369">            BigDecimal dec = BigDecimal.valueOf(millis);</span>
<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">            if (_fraction != null) {</span>
<span class="fc" id="L1371">                dec = dec.add(this._fraction.movePointRight(3));</span>
            }
<span class="fc" id="L1373">            return dec;</span>
        }
<span class="nc" id="L1375">        throw new IllegalArgumentException();</span>
    }


    /**
     * Returns the precision of this Timestamp.
     */
    public Precision getPrecision()
    {
<span class="fc" id="L1384">        return this._precision;</span>
    }

    /**
     * Returns the offset of this Timestamp, measured in minutes, for the local
     * timezone in UTC.
     * &lt;p&gt;
     * For example, calling this method on Timestamps of:
     * &lt;ul&gt;
     *     &lt;li&gt;{@code 1969-02-23T07:00+07:00} will return {@code 420}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-22T22:45:00.00-01:15} will return {@code -75}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-23} (by Ion's definition, equivalent to
     *     {@code 1969-02-23T00:00-00:00}) will return {@code null}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return
     *          {@code null} if the local offset is unknown
     *          (i.e. {@code -00:00})
     */
    public Integer getLocalOffset()
    {
<span class="fc" id="L1405">        return _offset;</span>
    }


    /**
     * Returns the year of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 9999], in its local time
     */
    public int getYear()
    {
<span class="fc" id="L1417">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1419" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1421">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1424">        return adjusted.getZYear();</span>
    }


    /**
     * Returns the month of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in its local time;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getMonth()
    {
<span class="fc" id="L1439">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1441" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1443">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1446">        return adjusted.getZMonth();</span>
    }


    /**
     * Returns the day (within the month) of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 31], in its local time;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getDay()
    {
<span class="fc" id="L1460">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1461" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1462" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1463">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1466">        return adjusted.getZDay();</span>
    }


    /**
     * Returns the hour of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 23], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getHour()
    {
<span class="fc" id="L1480">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1482" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1483">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1486">        return adjusted.getZHour();</span>
    }


    /**
     * Returns the minute of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 59], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getMinute()
    {
<span class="fc" id="L1500">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1502" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1503">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1506">        return adjusted.getZMinute();</span>
    }


    /**
     * Returns the seconds of this Timestamp, truncated to an integer.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getZSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZSecond()
     */
    public int getSecond()
    {
<span class="fc" id="L1524">        return this.getZSecond();</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getZDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZDecimalSecond()
     */
    public BigDecimal getDecimalSecond()
    {
<span class="fc" id="L1543">        BigDecimal sec = BigDecimal.valueOf(getSecond());</span>
<span class="fc bfc" id="L1544" title="All 2 branches covered.">        if (_fraction != null)</span>
        {
<span class="fc" id="L1546">            sec = sec.add(_fraction);</span>
        }
<span class="fc" id="L1548">        return sec;</span>
    }


    /**
     * Returns the year of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 9999], in UTC
     */
    public int getZYear()
    {
<span class="fc" id="L1560">        return this._calendar.get(Calendar.YEAR);</span>
    }


    /**
     * Returns the month of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in UTC;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getZMonth()
    {
<span class="fc" id="L1575">        return this._calendar.get(Calendar.MONTH) + 1;</span>
    }


    /**
     * Returns the day of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 31], in UTC;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getZDay()
    {
<span class="fc" id="L1589">        return this._calendar.get(Calendar.DAY_OF_MONTH);</span>
    }


    /**
     * Returns the hour of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 23], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getZHour()
    {
<span class="fc" id="L1603">        return this._calendar.get(Calendar.HOUR_OF_DAY);</span>
    }


    /**
     * Returns the minute of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 59], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getZMinute()
    {
<span class="fc" id="L1617">        return this._calendar.get(Calendar.MINUTE);</span>
    }


    /**
     * Returns the second of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getSecond()
     */
    public int getZSecond()
    {
<span class="fc" id="L1635">        return this._calendar.get(Calendar.SECOND);</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getDecimalSecond()
     */
    public BigDecimal getZDecimalSecond()
    {
<span class="nc" id="L1654">        return getDecimalSecond();</span>
    }


    /**
     * Returns the fractional second of this Timestamp.
     * &lt;p&gt;
     * Fractional seconds are not affected by local offsets.
     *
     * @return
     *          a BigDecimal within the range [0, 1);
     *          {@code null} is returned if the Timestamp isn't
     *          precise to the fractional second
     *
     * @deprecated This is an internal API that is subject to change without notice.
     */
    @Deprecated
    public BigDecimal getZFractionalSecond()
    {
<span class="fc" id="L1673">        return this._fraction;</span>
    }


    //=========================================================================
    // Modification methods


    /**
     * Returns a timestamp at the same point in time, but with the given local
     * offset.  If this timestamp has precision coarser than minutes, then it
     * is returned unchanged since such timestamps always have an unknown
     * offset.
     */
    public Timestamp withLocalOffset(Integer offset)
    {
<span class="fc" id="L1689">        Precision precision = getPrecision();</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">        if (precision.alwaysUnknownOffset() ||</span>
<span class="fc bfc" id="L1691" title="All 2 branches covered.">            safeEquals(offset, getLocalOffset()))</span>
        {
<span class="fc" id="L1693">            return this;</span>
        }
<span class="fc" id="L1695">        return new Timestamp((Calendar) _calendar.clone(), precision, _fraction, offset);</span>
    }


    //=========================================================================


    /**
     * Returns the string representation (in Ion format) of this Timestamp in
     * its local time.
     *
     * @see #toZString()
     * @see #print(Appendable)
     */
    @Override
    public String toString()
    {
<span class="fc" id="L1712">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L1715">            print(buffer);</span>
        }
<span class="nc" id="L1717">        catch (IOException e)</span>
        {
<span class="nc" id="L1719">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                                       e);
<span class="fc" id="L1721">        }</span>
<span class="fc" id="L1722">        return buffer.toString();</span>
    }

    /**
     * Returns the string representation (in Ion format) of this Timestamp
     * in UTC.
     *
     * @see #toString()
     * @see #printZ(Appendable)
     */
    public String toZString()
    {
<span class="fc" id="L1734">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L1737">            printZ(buffer);</span>
        }
<span class="nc" id="L1739">        catch (IOException e)</span>
        {
<span class="nc" id="L1741">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                e);
<span class="fc" id="L1743">        }</span>
<span class="fc" id="L1744">        return buffer.toString();</span>
    }

    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in its local time.
     * &lt;p&gt;
     * This method produces the same output as {@link #toString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@link Appendable} throws it
     *
     * @see #printZ(Appendable)
     */
    public void print(Appendable out)
        throws IOException
    {
        // we have to make a copy to preserve the &quot;immutable&quot; contract
        // on Timestamp and we don't want someone reading the calendar
        // member while we've shifted it around.
<span class="fc" id="L1765">        Timestamp adjusted = this;</span>

        // Adjust UTC time back to local time
<span class="fc bfc" id="L1768" title="All 4 branches covered.">        if (this._offset != null &amp;&amp; this._offset.intValue() != 0) {</span>
<span class="fc" id="L1769">            adjusted = make_localtime();</span>
        }

<span class="fc" id="L1772">        print(out, adjusted);</span>
<span class="fc" id="L1773">    }</span>

    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in UTC.
     * &lt;p&gt;
     * This method produces the same output as {@link #toZString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@code Appendable} throws it.
     *
     * @see #print(Appendable)
     */
    public void printZ(Appendable out)
        throws IOException
    {
<span class="pc bpc" id="L1790" title="1 of 3 branches missed.">        switch (_precision)</span>
        {
            case YEAR:
            case MONTH:
            case DAY:
            {
<span class="pc bpc" id="L1796" title="2 of 4 branches missed.">                assert _offset == UNKNOWN_OFFSET;</span>
                // No need to adjust offset, we won't be using it.
<span class="fc" id="L1798">                print(out);</span>
<span class="fc" id="L1799">                break;</span>
            }
            case MINUTE:
            case SECOND:
            {
<span class="fc" id="L1804">                Timestamp ztime = this.clone();</span>
<span class="fc" id="L1805">                ztime._offset = UTC_OFFSET;</span>
<span class="fc" id="L1806">                ztime.print(out);</span>
<span class="fc" id="L1807">                break;</span>
            }
        }
<span class="fc" id="L1810">    }</span>

    /**
     * helper for print(out) and printZ(out) so that printZ can create
     * a zulu time and pass it directly and print can apply the local
     * offset and adjust the various fields (without breaking the
     * contract to be immutable).
     * @param out destination for the text image of the value
     * @param adjusted the time value with the fields adjusted to match the desired text output
     * @throws IOException
     */
    private static void print(Appendable out, Timestamp adjusted)
        throws IOException
    {
        // null is our first &quot;guess&quot; to get it out of the way
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">        if (adjusted == null) {</span>
<span class="nc" id="L1826">            out.append(&quot;null.timestamp&quot;);</span>
<span class="nc" id="L1827">            return;</span>
        }

        // so we have a real value - we'll start with the date portion
        // which we always have
<span class="fc" id="L1832">        print_digits(out, adjusted.getZYear(), 4);</span>
<span class="fc bfc" id="L1833" title="All 2 branches covered.">        if (adjusted._precision == Precision.YEAR) {</span>
<span class="pc bpc" id="L1834" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L1835">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L1836">            return;</span>
        }

<span class="fc" id="L1839">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L1840">        print_digits(out, adjusted.getZMonth(), 2);  // convert calendar months to a base 1 value</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">        if (adjusted._precision == Precision.MONTH) {</span>
<span class="pc bpc" id="L1842" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L1843">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L1844">            return;</span>
        }

<span class="fc" id="L1847">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L1848">        print_digits(out, adjusted.getZDay(), 2);</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">        if (adjusted._precision == Precision.DAY) {</span>
<span class="pc bpc" id="L1850" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
            // out.append(&quot;T&quot;);
<span class="fc" id="L1852">            return;</span>
        }

<span class="fc" id="L1855">        out.append(&quot;T&quot;);</span>
<span class="fc" id="L1856">        print_digits(out, adjusted.getZHour(), 2);</span>
<span class="fc" id="L1857">        out.append(&quot;:&quot;);</span>
<span class="fc" id="L1858">        print_digits(out, adjusted.getZMinute(), 2);</span>
        // ok, so how much time do we have ?
<span class="fc bfc" id="L1860" title="All 2 branches covered.">        if (adjusted._precision.includes(Precision.SECOND)) {</span>
<span class="fc" id="L1861">            out.append(&quot;:&quot;);</span>
<span class="fc" id="L1862">            print_digits(out, adjusted.getZSecond(), 2);</span>
<span class="fc bfc" id="L1863" title="All 2 branches covered.">            if (adjusted._fraction != null) {</span>
<span class="fc" id="L1864">                print_fractional_digits(out, adjusted._fraction);</span>
            }
        }

<span class="fc bfc" id="L1868" title="All 2 branches covered.">        if (adjusted._offset != UNKNOWN_OFFSET) {</span>
            int min, hour;
<span class="fc" id="L1870">            min = adjusted._offset;</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">            if (min == 0) {</span>
<span class="fc" id="L1872">                out.append('Z');</span>
            }
            else {
<span class="fc bfc" id="L1875" title="All 2 branches covered.">                if (min &lt; 0) {</span>
<span class="fc" id="L1876">                    min = -min;</span>
<span class="fc" id="L1877">                    out.append('-');</span>
                }
                else {
<span class="fc" id="L1880">                    out.append('+');</span>
                }
<span class="fc" id="L1882">                hour = min / 60;</span>
<span class="fc" id="L1883">                min = min - hour*60;</span>
<span class="fc" id="L1884">                print_digits(out, hour, 2);</span>
<span class="fc" id="L1885">                out.append(&quot;:&quot;);</span>
<span class="fc" id="L1886">                print_digits(out, min, 2);</span>
            }
<span class="fc" id="L1888">        }</span>
        else {
<span class="fc" id="L1890">            out.append(&quot;-00:00&quot;);</span>
        }
<span class="fc" id="L1892">    }</span>
    private static void print_digits(Appendable out, int value, int length)
        throws IOException
    {
<span class="fc" id="L1896">        char temp[] = new char[length];</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">        while (length &gt; 0) {</span>
<span class="fc" id="L1898">            length--;</span>
<span class="fc" id="L1899">            int next = value / 10;</span>
<span class="fc" id="L1900">            temp[length] =  (char)('0' + (value - next*10));</span>
<span class="fc" id="L1901">            value = next;</span>
<span class="fc" id="L1902">        }</span>
<span class="pc bpc" id="L1903" title="1 of 2 branches missed.">        while (length &gt; 0) {</span>
<span class="nc" id="L1904">            length--;</span>
<span class="nc" id="L1905">            temp[length] =  '0';</span>
        }
<span class="fc bfc" id="L1907" title="All 2 branches covered.">        for (char c : temp) {</span>
<span class="fc" id="L1908">            out.append(c);</span>
        }
<span class="fc" id="L1910">    }</span>
    private static void print_fractional_digits(Appendable out, BigDecimal value)
        throws IOException
    {
<span class="fc" id="L1914">        String temp = value.toPlainString(); // crude, but it works</span>
<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">        if (temp.charAt(0) == '0') { // this should always be true</span>
<span class="fc" id="L1916">            temp = temp.substring(1);</span>
        }
<span class="fc" id="L1918">        out.append(temp);</span>
<span class="fc" id="L1919">    }</span>


    //=========================================================================
    // Timestamp arithmetic

    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds. Uses this Timestamp's configured Calendar to perform the
     * arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. After performing the arithmetic, the resulting Timestamp's
     * seconds value will be truncated to the same fractional precision as the
     * original. For example, adjusting {@code 2012-04-01T00:00:00Z} by one
     * millisecond results in {@code 2012-04-01T00:00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00.0010Z} by -1 millisecond results in
     * {@code 2012-04-01T00:00:00.0000Z}. To extend the precision when the
     * original Timestamp has coarser than SECOND precision and to avoid
     * truncation of the seconds value, use {@link #addSecond(int)}.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp adjustMillis(long amount) {
<span class="fc bfc" id="L1943" title="All 2 branches covered.">        if (amount == 0) return this;</span>
<span class="fc" id="L1944">        Timestamp ts = addMillis(amount);</span>
<span class="fc" id="L1945">        ts._precision = _precision;</span>
<span class="fc" id="L1946">        ts.clearUnusedPrecision();</span>
<span class="fc bfc" id="L1947" title="All 2 branches covered.">        if (_precision.includes(Precision.SECOND)) {</span>
            // Maintain the same amount of fractional precision.
<span class="fc bfc" id="L1949" title="All 2 branches covered.">            if (_fraction == null) {</span>
<span class="fc" id="L1950">                ts._fraction = null;</span>
            } else {
                // Truncate the result only if it exceeds the fractional precision of the original.
<span class="fc bfc" id="L1953" title="All 2 branches covered.">                if (ts._fraction.scale() &gt; _fraction.scale()) {</span>
<span class="fc" id="L1954">                    ts._fraction = ts._fraction.setScale(_fraction.scale(), RoundingMode.FLOOR);</span>
                }
            }
        }
<span class="fc" id="L1958">        return ts;</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds. Uses this Timestamp's configured Calendar to perform the
     * arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision and a seconds
     * value precise at least to the millisecond. For example, adding one millisecond
     * to {@code 2011T} results in {@code 2011-01-01T00:00:00.001-00:00}. To receive
     * a Timestamp that always maintains the same precision as the original, use
     * {@link #adjustMillis(long)}.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp addMillis(long amount) {
<span class="fc bfc" id="L1975" title="All 8 branches covered.">        if (amount == 0 &amp;&amp; _precision.includes(Precision.SECOND) &amp;&amp; _fraction != null &amp;&amp; _fraction.scale() &gt;= 3) {</span>
            // Zero milliseconds are to be added, and the precision does not need to be increased.
<span class="fc" id="L1977">            return this;</span>
        }
<span class="fc" id="L1979">        long seconds = amount / 1000;</span>
<span class="fc" id="L1980">        BigDecimal millis = BigDecimal.valueOf(amount % 1000).movePointLeft(3);</span>
<span class="fc bfc" id="L1981" title="All 2 branches covered.">        if (_fraction != null) {</span>
<span class="fc" id="L1982">            millis = _fraction.add(millis);</span>
        }
        BigDecimal newFraction;
<span class="fc bfc" id="L1985" title="All 2 branches covered.">        if (BigDecimal.ONE.compareTo(millis) &lt;= 0) {</span>
<span class="fc" id="L1986">            newFraction = millis.subtract(BigDecimal.ONE);</span>
<span class="fc" id="L1987">            seconds += 1;</span>
<span class="fc bfc" id="L1988" title="All 2 branches covered.">        } else if (BigDecimal.ZERO.compareTo(millis) &gt; 0) {</span>
<span class="fc" id="L1989">            newFraction = BigDecimal.ONE.add(millis);</span>
<span class="fc" id="L1990">            seconds -= 1;</span>
        } else {
<span class="fc" id="L1992">            newFraction = millis;</span>
        }
<span class="fc" id="L1994">        Timestamp ts = addSecond(seconds);</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">        if (ts == this) {</span>
            // When the precision does not need to be extended and there are no seconds to add,
            // addSecond returns the same reference unchanged. Clone it to ensure it is not
            // mutated.
<span class="fc" id="L1999">            ts = clone();</span>
        }
<span class="fc" id="L2001">        ts._fraction = newFraction;</span>
<span class="fc" id="L2002">        return ts;</span>
    }

    /**
     * Adds the given amount to the given {@link Calendar} field and returns a new Timestamp
     * with precision set to the maximum of the current precision and the given precision.
     * @param field the field.
     * @param amount an amount.
     * @param precision the precision corresponding to the given field.
     * @return a new Timestamp instance.
     */
    private Timestamp calendarAdd(int field, int amount, Precision precision) {
<span class="fc bfc" id="L2014" title="All 4 branches covered.">        if (amount == 0 &amp;&amp; _precision == precision) return this;</span>
<span class="fc" id="L2015">        Timestamp timestamp = make_localtime();</span>
<span class="fc" id="L2016">        timestamp._calendar.add(field, amount);</span>
<span class="fc" id="L2017">        checkCalendarYear(timestamp._calendar);</span>
<span class="fc bfc" id="L2018" title="All 2 branches covered.">        if (_offset != null) {</span>
<span class="fc" id="L2019">            timestamp.apply_offset(_offset);</span>
<span class="fc" id="L2020">            timestamp._offset = _offset;</span>
        }
<span class="fc bfc" id="L2022" title="All 2 branches covered.">        timestamp._precision = _precision.includes(precision) ? timestamp._precision : precision;</span>
<span class="fc" id="L2023">        return timestamp;</span>
    }

    /**
     * Clears any fields more precise than this Timestamp's precision supports.
     */
    private void clearUnusedPrecision() {
<span class="fc bfc" id="L2030" title="All 5 branches covered.">        switch (_precision) {</span>
            case YEAR:
<span class="fc" id="L2032">                _calendar.set(Calendar.MONTH, 0);</span>
            case MONTH:
<span class="fc" id="L2034">                _calendar.set(Calendar.DAY_OF_MONTH, 1);</span>
            case DAY:
<span class="fc" id="L2036">                _calendar.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L2037">                _calendar.set(Calendar.MINUTE, 0);</span>
            case MINUTE:
<span class="fc" id="L2039">                _calendar.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L2040">                _fraction = null;</span>
            case SECOND:
        }
<span class="fc" id="L2043">    }</span>

    /**
     * Adds the given amount to the given {@link Calendar} field and returns a new Timestamp
     * with the same precision as the original Timestamp.
     * @param field the field.
     * @param amount an amount.
     * @return a new Timestamp instance.
     */
    private Timestamp calendarAdjust(int field, int amount) {
<span class="fc bfc" id="L2053" title="All 2 branches covered.">        if (amount == 0) return this;</span>
<span class="fc" id="L2054">        Timestamp ts = calendarAdd(field, amount, _precision);</span>
<span class="fc" id="L2055">        ts.clearUnusedPrecision();</span>
<span class="fc" id="L2056">        return ts;</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     *
     * @param seconds a number of seconds.
     */
    private Timestamp addSecond(long seconds) {
<span class="fc" id="L2066">        Timestamp ts = this;</span>
        do {
            int incrementalSeconds;
<span class="fc bfc" id="L2069" title="All 2 branches covered.">            if (seconds &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L2070">                incrementalSeconds = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L2071" title="All 2 branches covered.">            } else if (seconds &lt; Integer.MIN_VALUE) {</span>
<span class="fc" id="L2072">                incrementalSeconds = Integer.MIN_VALUE;</span>
            } else {
<span class="fc" id="L2074">                incrementalSeconds = (int)seconds;</span>
            }
<span class="fc" id="L2076">            ts = ts.addSecond(incrementalSeconds);</span>
<span class="fc" id="L2077">            seconds -= incrementalSeconds;</span>
<span class="fc bfc" id="L2078" title="All 2 branches covered.">        } while (seconds != 0);</span>
<span class="fc" id="L2079">        return ts;</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T00:00Z} by one
     * second results in {@code 2012-04-01T00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00Z} by -1 second results in
     * {@code 2012-03-31T23:59:59Z}. To extend the precision when the original
     * Timestamp has coarser than SECOND precision, use {@link #addSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp adjustSecond(int amount)
    {
<span class="fc" id="L2097">        return calendarAdjust(Calendar.SECOND, amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision.
     * For example, adding one second to {@code 2011T} results in
     * {@code 2011-01-01T00:00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp addSecond(int amount)
    {
<span class="fc" id="L2113">        return calendarAdd(Calendar.SECOND, amount, Precision.SECOND);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one minute
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 minute results in {@code 2012-03-31T23:59-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp adjustMinute(int amount)
    {
<span class="fc" id="L2131">        return calendarAdjust(Calendar.MINUTE, amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one minute to {@code 2011T} results in
     * {@code 2011-01-01T00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp addMinute(int amount)
    {
<span class="fc" id="L2147">        return calendarAdd(Calendar.MINUTE, amount, Precision.MINUTE);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one hour
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 hour results in {@code 2012-03-31T23:00-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp adjustHour(int amount)
    {
<span class="fc" id="L2165">        return calendarAdjust(Calendar.HOUR_OF_DAY, amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one hour to {@code 2011T} results in
     * {@code 2011-01-01T01:00-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp addHour(int amount)
    {
<span class="fc" id="L2181">        return calendarAdd(Calendar.HOUR_OF_DAY, amount, Precision.MINUTE);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04T} by one day results
     * in {@code 2012-04T}; adjusting {@code 2012-04-01T} by -1 days results in
     * {@code 2012-03-31T}. To extend the precision when the original Timestamp
     * has coarser than DAY precision, use {@link #addDay(int)}.
     *
     * @param amount a number of days.
     */
    public final Timestamp adjustDay(int amount)
    {
<span class="fc" id="L2198">        return calendarAdjust(Calendar.DAY_OF_MONTH, amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     * Uses this Timestamp's configured Calendar to perform the arithmetic.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least DAY precision.
     * For example, adding one day to {@code 2011T} results in {@code 2011-01-02T}.
     * To receive a Timestamp that always maintains the same precision as the
     * original, use {@link #adjustDay(int)}.
     *
     * @param amount a number of days.
     */
    public final Timestamp addDay(int amount)
    {
<span class="fc" id="L2214">        return calendarAdd(Calendar.DAY_OF_MONTH, amount, Precision.DAY);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days, as required by the configured Calendar's rules. For example,
     * using the default {@link GregorianCalendar}, adjusting {@code 2011-01-31}
     * by one month results in {@code 2011-02-28}.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as the
     * original. For example, adjusting {@code 2011T} by one month results in
     * {@code 2011T}; adding 12 months to {@code 2011T} results in {@code 2012T}.
     * To extend the precision when the original Timestamp has coarser than MONTH
     * precision, use {@link #addMonth(int)}.
     *
     * @param amount a number of months.
     */
    public final Timestamp adjustMonth(int amount)
    {
<span class="fc" id="L2234">        return calendarAdjust(Calendar.MONTH, amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days, as required by the configured Calendar's rules. For example,
     * using the default {@link GregorianCalendar}, adding one month to
     * {@code 2011-01-31} results in {@code 2011-02-28}.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MONTH precision.
     * For example, adding one month to {@code 2011T} results in {@code 2011-02T}.
     * To receive a Timestamp that always maintains the same precision as the
     * original, use {@link #adjustMonth(int)}.
     *
     * @param amount a number of months.
     */
    public final Timestamp addMonth(int amount)
    {
<span class="fc" id="L2253">        return calendarAdd(Calendar.MONTH, amount, Precision.MONTH);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days, as required by
     * the configured Calendar's rules. For example, using the default
     * {@link GregorianCalendar}, adjusting {@code 2012-02-29} by one year
     * results in {@code 2013-02-28}.
     * &lt;p&gt;
     * Because YEAR is the coarsest precision possible, this method always
     * returns a Timestamp with the same precision as the original and
     * behaves identically to {@link #addYear(int)}.
     *
     * @param amount a number of years.
     */
    public final Timestamp adjustYear(int amount) {
<span class="fc" id="L2270">        return addYear(amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days, as required by
     * the configured Calendar's rules. For example, using the default
     * {@link GregorianCalendar}, adding one year to {@code 2012-02-29} results
     * in {@code 2013-02-28}.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. See also: {@link #adjustYear(int)}.
     *
     * @param amount a number of years.
     */
    public final Timestamp addYear(int amount)
    {
<span class="fc" id="L2287">        return calendarAdd(Calendar.YEAR, amount, Precision.YEAR);</span>
    }


    //=========================================================================

    /**
     * Returns a hash code consistent with {@link #equals(Object)}.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public int hashCode()
    {
        // Performs a Shift-Add-XOR-Rotate hash. Rotating at each step to
        // produce an &quot;Avalanche&quot; effect for timestamps with small deltas, which
        // is found to be a common input data set.

<span class="fc" id="L2305">        final int prime = 8191;</span>
<span class="fc" id="L2306">        int result = HASH_SIGNATURE;</span>

<span class="fc bfc" id="L2308" title="All 2 branches covered.">        result = prime * result + (_fraction != null</span>
<span class="fc" id="L2309">            ? _fraction.hashCode()</span>
<span class="fc" id="L2310">            : 0);</span>

<span class="fc" id="L2312">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2314">        result = prime * result + this.getZYear();</span>
<span class="fc" id="L2315">        result = prime * result + this.getZMonth();</span>
<span class="fc" id="L2316">        result = prime * result + this.getZDay();</span>
<span class="fc" id="L2317">        result = prime * result + this.getZHour();</span>
<span class="fc" id="L2318">        result = prime * result + this.getZMinute();</span>
<span class="fc" id="L2319">        result = prime * result + this.getZSecond();</span>

<span class="fc" id="L2321">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2323">        result = prime * result + this._precision.toString().hashCode();</span>

<span class="fc" id="L2325">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc bfc" id="L2327" title="All 2 branches covered.">        result = prime * result + (_offset == null ? 0 : _offset.hashCode());</span>

<span class="fc" id="L2329">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2331">        return result;</span>
    }



    /**
     * Performs a comparison of the two points in time represented by two
     * Timestamps.
     * If the point in time represented by this Timestamp precedes that of
     * {@code t}, then {@code -1} is returned.
     * If {@code t} precedes this Timestamp then {@code 1} is returned.
     * If the Timestamps represent the same point in time, then
     * {@code 0} is returned.
     * Note that a {@code 0} result does not imply that the two Timestamps are
     * {@link #equals}, as the local offset or precision of the two Timestamps
     * may be different.
     *
     * &lt;p&gt;
     * This method is provided in preference to individual methods for each of
     * the six boolean comparison operators (&amp;lt;, ==, &amp;gt;, &amp;gt;=, !=, &amp;lt;=).
     * The suggested idiom for performing these comparisons is:
     * {@code (x.compareTo(y)}&lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt;{@code 0)},
     * where &lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt; is one of the six comparison operators.
     *
     * &lt;p&gt;
     * For example, the pairs below will return a {@code 0} result:
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2008-12-31T16:00-08:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2008-12-31T12:00-12:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T12:00+12:00}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #equals(Timestamp)} method to compare the point
     * in time, &lt;em&gt;including&lt;/em&gt; precision and local offset.
     *
     * @param t
     *          the other {@code Timestamp} to compare this {@code Timestamp} to
     *
     * @return
     *          -1, 0, or 1 if this {@code Timestamp}
     *          is less than, equal to, or greater than {@code t} respectively
     *
     * @throws NullPointerException if {@code t} is null.
     *
     * @see #equals(Timestamp)
     */
    public int compareTo(Timestamp t)
    {
        // Test at millisecond precision first.
<span class="fc" id="L2389">        long this_millis = this.getMillis();</span>
<span class="fc" id="L2390">        long arg_millis = t.getMillis();</span>
<span class="fc bfc" id="L2391" title="All 2 branches covered.">        if (this_millis != arg_millis) {</span>
<span class="fc bfc" id="L2392" title="All 2 branches covered.">            return (this_millis &lt; arg_millis) ? -1 : 1;</span>
        }

        // Values are equivalent at millisecond precision, so compare fraction

        BigDecimal this_fraction =
<span class="fc bfc" id="L2398" title="All 2 branches covered.">            ((this._fraction == null) ? BigDecimal.ZERO : this._fraction);</span>
        BigDecimal arg_fraction =
<span class="fc bfc" id="L2400" title="All 2 branches covered.">            (( t._fraction == null) ? BigDecimal.ZERO :  t._fraction);</span>
<span class="fc" id="L2401">        return this_fraction.compareTo(arg_fraction);</span>
    }


    /**
     * Compares this {@link Timestamp} to the specified Object.
     * The result is {@code true} if and only if the parameter is a
     * {@link Timestamp} object that represents the same point in time,
     * precision and local offset as this Timestamp.
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #equals(Timestamp)
     * @see #compareTo(Timestamp)
     */
    @Override
    public boolean equals(Object t)
    {
<span class="pc bpc" id="L2420" title="1 of 2 branches missed.">        if (!(t instanceof Timestamp)) return false;</span>
<span class="fc" id="L2421">        return equals((Timestamp)t);</span>
    }

    /**
     * Compares this {@link Timestamp} to another {@link Timestamp} object.
     * The result is {@code true} if and only if the parameter
     * represents the same point in time and has
     * the same precision and local offset as this object.
     * &lt;p&gt;
     * These pairs are {@link #equals} to each other, as they
     * represent the same points in time, precision and local offset:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22+00:00} (minute precision, in UTC)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22Z} (minute precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * On the other hand, none of these pairs are {@link #equals} to each other,
     * they represent the same points in time, but with different precisions
     * and/or local offsets:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001T} (year precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01T} (month precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T} (day precision, unknown local offset)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00-00:00} (second precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00+00:00} (second precision, in UTC)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00.000-00:00} (millisecond precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00.000+00:00} (millisecond precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #compareTo(Timestamp)
     */
    public boolean equals(Timestamp t)
    {
<span class="fc bfc" id="L2463" title="All 2 branches covered.">        if (this == t) return true;</span>
<span class="pc bpc" id="L2464" title="1 of 2 branches missed.">        if (t == null) return false;</span>

        // if the precisions are not the same the values are not
        // precision doesn't matter WRT equality
<span class="fc bfc" id="L2468" title="All 2 branches covered.">        if (this._precision != t._precision) return false;</span>

        // if the local offset are not the same the values are not
<span class="fc bfc" id="L2471" title="All 2 branches covered.">        if (this._offset == null) {</span>
<span class="fc bfc" id="L2472" title="All 2 branches covered.">            if (t._offset != null)  return false;</span>
        }
        else {
<span class="fc bfc" id="L2475" title="All 2 branches covered.">            if (t._offset == null) return false;</span>
        }

        // so now we check the actual time value
<span class="fc bfc" id="L2479" title="All 2 branches covered.">        if (this.getZYear()   != t.getZYear())    return false;</span>
<span class="fc bfc" id="L2480" title="All 2 branches covered.">        if (this.getZMonth()  != t.getZMonth())   return false;</span>
<span class="fc bfc" id="L2481" title="All 2 branches covered.">        if (this.getZDay()    != t.getZDay())     return false;</span>
<span class="fc bfc" id="L2482" title="All 2 branches covered.">        if (this.getZHour()   != t.getZHour())    return false;</span>
<span class="fc bfc" id="L2483" title="All 2 branches covered.">        if (this.getZMinute() != t.getZMinute())  return false;</span>
<span class="fc bfc" id="L2484" title="All 2 branches covered.">        if (this.getZSecond() != t.getZSecond())  return false;</span>

        // and if we have a local offset, check the value here
<span class="fc bfc" id="L2487" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L2488" title="All 2 branches covered.">            if (this._offset.intValue() != t._offset.intValue()) return false;</span>
        }

        // we only look at the fraction if we know that it's actually there

<span class="fc bfc" id="L2493" title="All 8 branches covered.">        if ((this._fraction != null &amp;&amp; t._fraction == null)</span>
            || (this._fraction == null &amp;&amp; t._fraction != null)) {
            // one of the fractions are null
<span class="fc" id="L2496">            return false;</span>
        }
<span class="pc bpc" id="L2498" title="1 of 4 branches missed.">        if (this._fraction == null &amp;&amp; t._fraction == null) {</span>
            // both are null
<span class="fc" id="L2500">            return true;</span>
        }
<span class="fc" id="L2502">        return this._fraction.equals(t._fraction);</span>
    }

    private static void checkCalendarYear(Calendar calendar) {
<span class="fc" id="L2506">        int year = calendar.get(Calendar.YEAR);</span>
<span class="fc bfc" id="L2507" title="All 2 branches covered.">        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {</span>
<span class="fc" id="L2508">            year *= -1;</span>
        }
<span class="fc" id="L2510">        checkAndCastYear(year);</span>
<span class="fc" id="L2511">    }</span>

    private static short checkAndCastYear(int year)
    {
<span class="fc bfc" id="L2515" title="All 4 branches covered.">        if (year &lt; 1 || year &gt; 9999)</span>
        {
<span class="fc" id="L2517">            throw new IllegalArgumentException(String.format(&quot;Year %s must be between 1 and 9999 inclusive&quot;, year));</span>
        }

<span class="fc" id="L2520">        return (short) year;</span>
    }

    private static byte checkAndCastMonth(int month)
    {
<span class="fc bfc" id="L2525" title="All 4 branches covered.">        if (month &lt; 1 || month &gt; 12)</span>
        {
<span class="fc" id="L2527">            throw new IllegalArgumentException(String.format(&quot;Month %s must be between 1 and 12 inclusive&quot;, month));</span>
        }

<span class="fc" id="L2530">        return (byte) month;</span>
    }

    private void checkCalendarDay(int day) {
<span class="fc" id="L2534">        int lastDayInMonth = _calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</span>
<span class="fc bfc" id="L2535" title="All 4 branches covered.">        if (day &gt; lastDayInMonth || day &lt; _calendar.getActualMinimum(Calendar.DAY_OF_MONTH)) {</span>
<span class="fc" id="L2536">            throw new IllegalArgumentException(String.format(&quot;Day %s for year %s and month %s must be between 1 and %s inclusive&quot;, day, getZYear(), getZMonth(), lastDayInMonth));</span>
        }
<span class="fc" id="L2538">    }</span>

    private static byte checkAndCastHour(int hour)
    {
<span class="pc bpc" id="L2542" title="1 of 4 branches missed.">        if (hour &lt; 0 || hour &gt; 23)</span>
        {
<span class="fc" id="L2544">            throw new IllegalArgumentException(String.format(&quot;Hour %s must be between 0 and 23 inclusive&quot;, hour));</span>
        }

<span class="fc" id="L2547">        return (byte) hour;</span>
    }

    private static byte checkAndCastMinute(int minute)
    {
<span class="pc bpc" id="L2552" title="1 of 4 branches missed.">        if (minute &lt; 0 || minute &gt; 59)</span>
        {
<span class="fc" id="L2554">            throw new IllegalArgumentException(String.format(&quot;Minute %s must be between between 0 and 59 inclusive&quot;, minute));</span>
        }

<span class="fc" id="L2557">        return (byte) minute;</span>
    }

    private static byte checkAndCastSecond(int second)
    {
<span class="fc bfc" id="L2562" title="All 4 branches covered.">        if (second &lt; 0 || second &gt; 59)</span>
        {
<span class="fc" id="L2564">            throw new IllegalArgumentException(String.format(&quot;Second %s must be between between 0 and 59 inclusive&quot;, second));</span>
        }

<span class="fc" id="L2567">        return (byte) second;</span>
    }

    private static Precision checkFraction(Precision precision, BigDecimal fraction)
    {
<span class="fc bfc" id="L2572" title="All 2 branches covered.">        if (precision.includes(Precision.SECOND)) {</span>
<span class="pc bpc" id="L2573" title="1 of 6 branches missed.">            if (fraction != null &amp;&amp; (fraction.signum() == -1 || BigDecimal.ONE.compareTo(fraction) != 1)) {</span>
<span class="fc" id="L2574">                throw new IllegalArgumentException(String.format(&quot;Fractional seconds %s must be greater than or equal to 0 and less than 1&quot;, fraction));</span>
            }
        }
        else {
<span class="pc bpc" id="L2578" title="1 of 2 branches missed.">            if (fraction != null) {</span>
<span class="nc" id="L2579">                throw new IllegalArgumentException(&quot;Fraction must be null for non-second precision: &quot; + fraction);</span>
            }
        }

<span class="fc" id="L2583">        return precision;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>