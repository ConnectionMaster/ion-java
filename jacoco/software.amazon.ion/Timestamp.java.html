<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Timestamp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion</a> &gt; <span class="el_source">Timestamp.java</span></div><h1>Timestamp.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion;

import static software.amazon.ion.impl.PrivateUtils.safeEquals;
import static software.amazon.ion.util.IonTextUtils.printCodePointAsString;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import software.amazon.ion.impl.PrivateUtils;
import software.amazon.ion.util.IonTextUtils;

/**
 * An immutable representation of a point in time. Ion defines a simple
 * representation of time based on Coordinated Universal Time (UTC).
 * In practice the use of time could be more accurately described as
 * UTC-SLS (UTC Smoothed Leap Seconds) as there is no representation for the
 * leap second discontinuities that UTC has added.
 * &lt;p&gt;
 * Timestamps preserve precision, meaning the fields that are included, and the
 * significant digits of any fractional second.  Only common break
 * points in the values are supported.  Any unspecified fields are handled
 * as the start of the new year/month/day.
 *
 *
 * &lt;h3&gt;Equality and Comparison&lt;/h3&gt;
 *
 * As with {@link IonValue} classes, the {@link #equals equals} methods on this class
 * perform a strict equivalence that observes the precision and local offset
 * of each timestamp.
 * This means that it's possible to have two {@link Timestamp} instances that
 * represent the same point in time but are not {@code equals}.
 * &lt;p&gt;
 * On the other hand, the {@link #compareTo} methods perform point in time
 * comparison, ignoring precision and local offset.
 * Thus the &lt;em&gt;natural comparison method&lt;/em&gt; of this class is &lt;em&gt;not
 * consistent with equals&lt;/em&gt;. See the documentation of {@link Comparable} for
 * further discussion.
 * &lt;p&gt;
 * To illustrate this distinction, consider the following timestamps. None are
 * {@link #equals} to each other, but any pair will return a zero result from
 * {@link #compareTo}.
 * &lt;ul&gt;
 *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.000Z} &lt;em&gt;etc.&lt;/em&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @see #equals(Timestamp)
 * @see #compareTo(Timestamp)
 */
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">public final class Timestamp</span>
    implements Comparable&lt;Timestamp&gt;, Cloneable
{
    private static final boolean APPLY_OFFSET_YES = true;
    private static final boolean APPLY_OFFSET_NO = false;

    private static final int NO_MONTH = 0;
    private static final int NO_DAY = 0;
    private static final int NO_HOURS = 0;
    private static final int NO_MINUTES = 0;
    private static final int NO_SECONDS = 0;
<span class="fc" id="L85">    private static final BigDecimal NO_FRACTIONAL_SECONDS = null;</span>

    // 0001-01-01T00:00:00.0Z in millis
    static final long MINIMUM_TIMESTAMP_IN_MILLIS = -62135769600000L;

    // 0001-01-01T00:00:00.0Z in millis
<span class="fc" id="L91">    static final BigDecimal MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(MINIMUM_TIMESTAMP_IN_MILLIS);</span>

    // 10000T in millis, upper bound exclusive
    static final long MAXIMUM_TIMESTAMP_IN_MILLIS = 253402300800000L;

    // 10000T in millis, upper bound exclusive
<span class="fc" id="L97">    static final BigDecimal MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(MAXIMUM_TIMESTAMP_IN_MILLIS);</span>

    /**
     * Unknown local offset from UTC.
     */
<span class="fc" id="L102">    public static final Integer UNKNOWN_OFFSET = null;</span>

    /**
     * Local offset of zero hours from UTC.
     */
<span class="fc" id="L107">    public static final Integer UTC_OFFSET = Integer.valueOf(0);</span>

    private static final int FLAG_YEAR      = 0x01;
    private static final int FLAG_MONTH     = 0x02;
    private static final int FLAG_DAY       = 0x04;
    private static final int FLAG_MINUTE    = 0x08;
    private static final int FLAG_SECOND    = 0x10;

    /**
     * The precision of the Timestamp.
     */
<span class="fc" id="L118">    public static enum Precision {</span>
<span class="fc" id="L119">        YEAR    (FLAG_YEAR),</span>
<span class="fc" id="L120">        MONTH   (FLAG_YEAR | FLAG_MONTH),</span>
<span class="fc" id="L121">        DAY     (FLAG_YEAR | FLAG_MONTH | FLAG_DAY),</span>
        // HOUR is not a supported precision per https://www.w3.org/TR/NOTE-datetime
<span class="fc" id="L123">        MINUTE  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE),</span>
<span class="fc" id="L124">        SECOND  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE | FLAG_SECOND);</span>

        /** Bit flags for the precision. */
        private final int flags;

        private Precision(int flags)
<span class="fc" id="L130">        {</span>
<span class="fc" id="L131">            this.flags = flags;</span>
<span class="fc" id="L132">        }</span>

        private boolean alwaysUnknownOffset()
        {
<span class="fc bfc" id="L136" title="All 2 branches covered.">            return this.ordinal() &lt;= DAY.ordinal();</span>
        }

        public boolean includes(Precision isIncluded)
        {
<span class="pc bpc" id="L141" title="1 of 6 branches missed.">            switch (isIncluded)</span>
            {
<span class="fc bfc" id="L143" title="All 2 branches covered.">                case SECOND:    return (flags &amp; FLAG_SECOND)   != 0;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">                case MINUTE:    return (flags &amp; FLAG_MINUTE)   != 0;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                case DAY:       return (flags &amp; FLAG_DAY)      != 0;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                case MONTH:     return (flags &amp; FLAG_MONTH)    != 0;</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                case YEAR:      return (flags &amp; FLAG_YEAR)     != 0;</span>
                default:        break;
            }
<span class="nc" id="L150">            throw new IllegalStateException(&quot;unrecognized precision&quot; + isIncluded);</span>
        }
    }

<span class="fc" id="L154">    private static final int HASH_SIGNATURE =</span>
<span class="fc" id="L155">        &quot;INTERNAL TIMESTAMP&quot;.hashCode();</span>

    /**
     * The precision of the Timestamp. The fractional seconds component is
     * defined by a BigDecimal.
     * &lt;p&gt;
     * During construction of all Timestamps, they will have a
     * date value (i.e. Year, Month, Day) but with reduced precision they may
     * exclude any time values that are more precise than the precision that is
     * being defined.
     */
    private Precision   _precision;

    // These are the time field values for the Timestamp.
    // _month and _day are 1-based (0 is an invalid value for
    // these in a non-null Timestamp).
    private short       _year;
<span class="fc" id="L172">    private byte        _month = 1; // Initialized to valid default</span>
<span class="fc" id="L173">    private byte        _day   = 1; // Initialized to valid default</span>
    private byte        _hour;
    private byte        _minute;
    private byte        _second;
    private BigDecimal  _fraction;  // fractional seconds, must be within range [0, 1)

    /**
     * Minutes offset from UTC; zero means UTC proper,
     * &lt;code&gt;null&lt;/code&gt; means that the offset is unknown.
     */
    private Integer     _offset;

                                                      //   jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
                                                      // the first 0 is to make these arrays 1 based (since month values are 1-12)
<span class="fc" id="L187">    private static final int[] LEAP_DAYS_IN_MONTH   = { 0,  31,  29,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };</span>
<span class="fc" id="L188">    private static final int[] NORMAL_DAYS_IN_MONTH = { 0,  31,  28,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };</span>

    private static int last_day_in_month(int year, int month) {
        boolean is_leap;
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if ((year % 4) == 0) {</span>
            // divisible by 4 (lower 2 bits are zero) - may be a leap year
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if ((year % 100) == 0) {</span>
                // and divisible by 100 - not a leap year
<span class="fc bfc" id="L196" title="All 2 branches covered.">                if ((year % 400) == 0) {</span>
                    // but divisible by 400 - then it is a leap year
<span class="fc" id="L198">                    is_leap = true;</span>
                }
                else {
<span class="fc" id="L201">                    is_leap = false;</span>
                }
            }
            else {
<span class="fc" id="L205">                is_leap = true;</span>
            }
        }
        else {
<span class="fc" id="L209">            is_leap = false;</span>
        }
<span class="fc bfc" id="L211" title="All 2 branches covered.">        return is_leap ? LEAP_DAYS_IN_MONTH[month] : NORMAL_DAYS_IN_MONTH[month];</span>
    }

    /**
     * Applies the local time zone offset from UTC to the applicable time field
     * values. Depending on the local time zone offset, adjustments
     * (i.e. rollover) will be made to the Year, Day, Hour, Minute time field
     * values.
     *
     * @param offset the local offset, in minutes from UTC.
     */
    private void apply_offset(int offset)
    {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (offset == 0) return;</span>
<span class="pc bpc" id="L225" title="2 of 4 branches missed.">        if (offset &lt; -24*60 || offset &gt; 24*60) {</span>
<span class="nc" id="L226">            throw new IllegalArgumentException(&quot;bad offset &quot; + offset);</span>
        }
        // To convert _to_ UTC you must SUBTRACT the local offset
<span class="fc" id="L229">        offset = -offset;</span>
<span class="fc" id="L230">        int hour_offset = offset / 60;</span>
<span class="fc" id="L231">        int min_offset = offset - (hour_offset * 60);</span>

<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (offset &lt; 0) {</span>
<span class="fc" id="L234">            _minute += min_offset;  // lower the minute value by adding a negative offset</span>
<span class="fc" id="L235">            _hour += hour_offset;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (_minute &lt; 0) {</span>
<span class="fc" id="L237">                _minute += 60;</span>
<span class="fc" id="L238">                _hour -= 1;</span>
            }
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (_hour &gt;= 0) return;  // hour is 0-23</span>
<span class="fc" id="L241">            _hour += 24;</span>
<span class="fc" id="L242">            _day -= 1;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (_day &gt;= 1) return;  // day is 1-31</span>
            // we can't do this until we've figured out the month and year: _day += last_day_in_month(_year, _month);
<span class="fc" id="L245">            _month -= 1;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">            if (_month &gt;= 1) {</span>
<span class="fc" id="L247">                _day += last_day_in_month(_year, _month);  // now we know (when the year doesn't change</span>
<span class="pc bpc" id="L248" title="2 of 4 branches missed.">                assert(_day == last_day_in_month(_year, _month));</span>
<span class="fc" id="L249">                return;  // 1-12</span>
            }
<span class="fc" id="L251">            _month += 12;</span>
<span class="fc" id="L252">            _year -= 1;</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if (_year &lt; 1) throw new IllegalArgumentException(&quot;year is less than 1&quot;);</span>
<span class="fc" id="L254">            _day += last_day_in_month(_year, _month);  // and now we know, even if the year did change</span>
<span class="pc bpc" id="L255" title="2 of 4 branches missed.">            assert(_day == last_day_in_month(_year, _month));</span>
        }
        else {
<span class="fc" id="L258">            _minute += min_offset;  // lower the minute value by adding a negative offset</span>
<span class="fc" id="L259">            _hour += hour_offset;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (_minute &gt; 59) {</span>
<span class="fc" id="L261">                _minute -= 60;</span>
<span class="fc" id="L262">                _hour += 1;</span>
            }
<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (_hour &lt; 24) return;  // hour is 0-23</span>
<span class="fc" id="L265">            _hour -= 24;</span>
<span class="fc" id="L266">            _day += 1;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (_day &lt;= last_day_in_month(_year, _month)) return;  // day is 1-31</span>
            // we can't do this until we figure out the final month and year: _day -= last_day_in_month(_year, _month);
<span class="fc" id="L269">            _day = 1; // this is always the case</span>
<span class="fc" id="L270">            _month += 1;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (_month &lt;= 12) {</span>
<span class="fc" id="L272">                return;  // 1-12</span>
            }
<span class="fc" id="L274">            _month -= 12;</span>
<span class="fc" id="L275">            _year += 1;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            if (_year &gt; 9999) throw new IllegalArgumentException(&quot;year exceeds 9999&quot;);</span>
        }
<span class="fc" id="L278">    }</span>

    private static byte requireByte(int value, String location) {
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">        if (value &gt; Byte.MAX_VALUE || value &lt; Byte.MIN_VALUE) {</span>
<span class="nc" id="L282">            throw new IllegalArgumentException(String.format(&quot;%s of %d is out of range.&quot;, location, value));</span>
        }
<span class="fc" id="L284">        return (byte) value;</span>
    }

    private static short requireShort(int value, String location) {
<span class="pc bpc" id="L288" title="2 of 4 branches missed.">        if (value &gt; Short.MAX_VALUE || value &lt; Short.MIN_VALUE) {</span>
<span class="nc" id="L289">            throw new IllegalArgumentException(String.format(&quot;%s of %d is out of range.&quot;, location, value));</span>
        }
<span class="fc" id="L291">        return (short) value;</span>
    }

    /**
     * This method uses deprecated methods from {@link java.util.Date}
     * instead of {@link Calendar} so that this code can be used (more easily)
     * on the mobile Java platform (which has Date but does not have Calendar).
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    private void set_fields_from_millis(long millis)
    {
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if(millis &lt; MINIMUM_TIMESTAMP_IN_MILLIS){</span>
<span class="nc" id="L303">            throw new IllegalArgumentException(&quot;year is less than 1&quot;);</span>
        }

<span class="fc" id="L306">        Date date = new Date(millis);</span>

        // The Date getters return values in the Date's time zone (i.e. the system time zone).
        // The components need to be converted to UTC before being validated for exact ranges, because the offset
        // conversion can affect which values are considered valid. Simply verify that the values can fit in the
        // destination type here. If they do not, they would be out of range no matter the offset.
<span class="fc" id="L312">        _minute = requireByte(date.getMinutes(), &quot;Minute&quot;);</span>
<span class="fc" id="L313">        _second = requireByte(date.getSeconds(), &quot;Second&quot;);</span>
<span class="fc" id="L314">        _hour = requireByte(date.getHours(), &quot;Hour&quot;);</span>
<span class="fc" id="L315">        _day = requireByte(date.getDate(), &quot;Day&quot;);</span>
<span class="fc" id="L316">        _month = requireByte(date.getMonth() + 1, &quot;Month&quot;);</span>

        // Date does not correctly handle year values that represent year 0 or earlier in the system time zone through
        // getYear(). This case is detected and forced to zero.
<span class="fc" id="L320">        int offset = -date.getTimezoneOffset();</span>
<span class="pc bpc" id="L321" title="3 of 4 branches missed.">        if(offset &lt; 0 &amp;&amp; MINIMUM_TIMESTAMP_IN_MILLIS - offset &gt; millis) {</span>
<span class="nc" id="L322">            _year = 0;</span>
        } else {
<span class="fc" id="L324">            _year = requireShort(date.getYear() + 1900, &quot;Year&quot;);</span>
        }

        // Now apply the offset to convert the components to UTC.
<span class="fc" id="L328">        apply_offset(offset);</span>

        // Now that all components are in UTC, they may be validated for exact ranges.
<span class="fc" id="L331">        this._year    = checkAndCastYear(_year);</span>
<span class="fc" id="L332">        this._month   = checkAndCastMonth(_month);</span>
<span class="fc" id="L333">        this._day     = checkAndCastDay(_day, _year, _month);</span>
<span class="fc" id="L334">        this._hour    = checkAndCastHour(_hour);</span>
<span class="fc" id="L335">        this._minute  = checkAndCastMinute(_minute);</span>
<span class="fc" id="L336">        this._second  = checkAndCastSecond(_second);</span>
<span class="fc" id="L337">    }</span>

    /**
     * Copies data from a {@link Calendar} into this timestamp.
     * Must only be called during construction due to timestamp immutabliity.
     *
     * @param cal must have at least one field set.
     *
     * @throws IllegalArgumentException if the calendar has no fields set.
     */
    private void set_fields_from_calendar(Calendar cal,
                                          Precision precision,
                                          boolean setLocalOffset)
    {
<span class="fc" id="L351">        _precision = precision;</span>
<span class="fc" id="L352">        _offset = UNKNOWN_OFFSET;</span>
<span class="fc" id="L353">        boolean dayPrecision = false;</span>
<span class="fc" id="L354">        boolean calendarHasMilliseconds = cal.isSet(Calendar.MILLISECOND);</span>

<span class="pc bpc" id="L356" title="1 of 6 branches missed.">        switch (this._precision) {</span>
            case SECOND:
<span class="fc" id="L358">                this._second = checkAndCastSecond(cal.get(Calendar.SECOND));</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">                if (calendarHasMilliseconds) {</span>
<span class="fc" id="L360">                    BigDecimal millis = BigDecimal.valueOf(cal.get(Calendar.MILLISECOND));</span>
<span class="fc" id="L361">                    this._fraction = millis.movePointLeft(3); // convert to fraction</span>
<span class="fc" id="L362">                    checkFraction(precision, this._fraction);</span>
                }
            case MINUTE:
            {
<span class="fc" id="L366">                this._hour   = checkAndCastHour(cal.get(Calendar.HOUR_OF_DAY));</span>
<span class="fc" id="L367">                this._minute = checkAndCastMinute(cal.get(Calendar.MINUTE));</span>

                // If this test is made before calling get(), it will return
                // false even when Calendar.setTimeZone() was called.
<span class="pc bpc" id="L371" title="1 of 4 branches missed.">                if (setLocalOffset &amp;&amp; cal.isSet(Calendar.ZONE_OFFSET))</span>
                {
<span class="fc" id="L373">                    int offset = cal.get(Calendar.ZONE_OFFSET);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                    if (cal.isSet(Calendar.DST_OFFSET)) {</span>
<span class="fc" id="L375">                        offset += cal.get(Calendar.DST_OFFSET);</span>
                    }

                    // convert ms to minutes
<span class="fc" id="L379">                    _offset = offset / (1000*60);</span>
                }
            }
            case DAY:
<span class="fc" id="L383">                dayPrecision = true;</span>
            case MONTH:
                // Calendar months are 0 based, Timestamp months are 1 based
<span class="fc" id="L386">                this._month  = checkAndCastMonth((cal.get(Calendar.MONTH) + 1));</span>
            case YEAR:
                int year;
<span class="fc bfc" id="L389" title="All 2 branches covered.">                if(cal.get(Calendar.ERA) == GregorianCalendar.AD) {</span>
<span class="fc" id="L390">                    year = cal.get(Calendar.YEAR);</span>
                }
                else {
<span class="fc" id="L393">                    year = -cal.get(Calendar.YEAR);</span>
                }

<span class="fc" id="L396">                this._year = checkAndCastYear(year);</span>
        }

<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (dayPrecision)</span>
        {
<span class="fc" id="L401">            this._day = checkAndCastDay(cal.get(Calendar.DAY_OF_MONTH), _year, _month);</span>
        }

<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (_offset != UNKNOWN_OFFSET) {</span>
            // Transform our members from local time to Zulu
<span class="fc" id="L406">            this.apply_offset(_offset);</span>
        }
<span class="fc" id="L408">    }</span>

    /**
     * Creates a new Timestamp, precise to the year, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    private Timestamp(int zyear)
    {
<span class="fc" id="L417">        this(Precision.YEAR, zyear, NO_MONTH, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L418">    }</span>

    /**
     * Creates a new Timestamp, precise to the month, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    private Timestamp(int zyear, int zmonth)
    {
<span class="fc" id="L427">        this(Precision.MONTH, zyear, zmonth, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L428">    }</span>

    /**
     * Creates a new Timestamp, precise to the day, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     */
    @Deprecated
    private Timestamp(int zyear, int zmonth, int zday)
    {
<span class="fc" id="L438">        this(Precision.DAY, zyear, zmonth, zday, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L439">    }</span>


    /**
     * Creates a new Timestamp, precise to the minute, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     */
    @Deprecated
    private Timestamp(int year, int month, int day,
                     int hour, int minute,
                     Integer offset)
    {
<span class="fc" id="L459">        this(Precision.MINUTE, year, month, day, hour, minute, NO_SECONDS, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L460">    }</span>

    /**
     * Creates a new Timestamp, precise to the second, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     */
    @Deprecated
    private Timestamp(int year, int month, int day,
                     int hour, int minute, int second,
                     Integer offset)
    {
<span class="fc" id="L479">        this(Precision.SECOND, year, month, day, hour, minute, second, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L480">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     *
     * @param frac must be &gt;= 0 and &lt; 1
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @see #createFromUtcFields(Precision, int, int, int, int, int, int, BigDecimal, Integer)
     */
    private Timestamp(Precision p, int zyear, int zmonth, int zday,
                      int zhour, int zminute, int zsecond, BigDecimal frac,
                      Integer offset, boolean shouldApplyOffset)
<span class="fc" id="L503">    {</span>
<span class="fc" id="L504">        boolean dayPrecision = false;</span>

<span class="pc bpc" id="L506" title="1 of 6 branches missed.">        switch (p) {</span>
        default:
<span class="nc" id="L508">            throw new IllegalArgumentException(&quot;invalid Precision passed to constructor&quot;);</span>
        case SECOND:
<span class="fc bfc" id="L510" title="All 4 branches covered.">            if (frac == null || frac.equals(BigDecimal.ZERO))</span>
            {
<span class="fc" id="L512">                _fraction = null;</span>
            }
            else
            {
<span class="fc" id="L516">                _fraction = frac.abs();</span>
            }
<span class="fc" id="L518">            _second = checkAndCastSecond(zsecond);</span>
        case MINUTE:
<span class="fc" id="L520">            _minute = checkAndCastMinute(zminute);</span>
<span class="fc" id="L521">            _hour   = checkAndCastHour(zhour);</span>
<span class="fc" id="L522">            _offset = offset;      // offset must be null for years/months/days</span>
        case DAY:
<span class="fc" id="L524">             dayPrecision = true;</span>
        case MONTH:
<span class="fc" id="L526">            _month  = checkAndCastMonth(zmonth);</span>
        case YEAR:
<span class="fc" id="L528">            _year   = checkAndCastYear(zyear);</span>
        }

<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (dayPrecision)</span>
        {
<span class="fc" id="L533">            _day    = checkAndCastDay(zday, zyear, zmonth);</span>
        }

<span class="fc" id="L536">        _precision = checkFraction(p, _fraction);</span>

<span class="fc bfc" id="L538" title="All 4 branches covered.">        if (shouldApplyOffset &amp;&amp; offset != null) {</span>
<span class="fc" id="L539">            apply_offset(offset);</span>
        }
<span class="fc" id="L541">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * As such, if the given {@code offset} is non-null or zero, the resulting
     * Timestamp will have time values that &lt;em&gt;DO NOT&lt;/em&gt; match the time
     * parameters. This method also has a behavior of precision &quot;narrowing&quot;,
     * detailed in the sub-section below.
     *
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values (in its local time) respectively:
     *&lt;pre&gt;
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;null&lt;/b&gt;)    will return 2012-02-03T04:05:06.007-00:00 (match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;0&lt;/b&gt;)       will return 2012-02-03T04:05:06.007+00:00 (match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;480&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;12&lt;/b&gt;:05:06.007&lt;b&gt;+08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-480&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;20&lt;/b&gt;:05:06.007&lt;b&gt;-08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;720&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;+12:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-720&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;-12:00&lt;/b&gt; (do not match)
     *&lt;/pre&gt;
     * Note: All of these resulting Timestamps have the similar value (in UTC) 2012-02-03T04:05:06.007Z.
     *
     * &lt;h3&gt;Precision &quot;Narrowing&quot;&lt;/h3&gt;
     *
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values respectively:
     *&lt;pre&gt;
     * createFromUtcFields(&lt;b&gt;Precision.YEAR&lt;/b&gt;    , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012T
     * createFromUtcFields(&lt;b&gt;Precision.MONTH&lt;/b&gt;   , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02T
     * createFromUtcFields(&lt;b&gt;Precision.DAY&lt;/b&gt;     , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T
     * createFromUtcFields(&lt;b&gt;Precision.MINUTE&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05Z
     * createFromUtcFields(&lt;b&gt;Precision.SECOND&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6,  null, 0)    will return 2012-02-03T04:05:06Z
     * createFromUtcFields(&lt;b&gt;Precision.SECOND&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05:06.007Z
     *&lt;/pre&gt;
     *
     * @param p the desired timestamp precision. The result may have a
     * different precision if the input data isn't precise enough.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     * @deprecated This is an internal API that is subject to change without notice.
     */
    @Deprecated
    public static Timestamp
    createFromUtcFields(Precision p, int zyear, int zmonth, int zday,
                        int zhour, int zminute, int zsecond, BigDecimal frac,
                        Integer offset)
    {
<span class="fc" id="L599">        return new Timestamp(p, zyear, zmonth, zday,</span>
                             zhour, zminute, zsecond, frac,
                             offset, APPLY_OFFSET_NO);
    }

    /**
     * Creates a new Timestamp from a {@link Calendar}, preserving the
     * {@link Calendar}'s precision and local offset from UTC.
     * &lt;p&gt;
     * The most precise calendar field of {@code cal} will be used to determine
     * the precision of the resulting Timestamp.
     *
     * For example, the calendar field will have a Timestamp precision accordingly:
     * &lt;ul&gt;
     *   &lt;li&gt;{@link Calendar#YEAR} - year precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MONTH} - month precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#DAY_OF_MONTH} - day precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#HOUR_OF_DAY} or {@link Calendar#MINUTE} - minute precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#SECOND} - second precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MILLISECOND} - fractional second precision&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @throws IllegalArgumentException
     *          if {@code cal} has no appropriate calendar fields set.
     */
    @Deprecated
    private Timestamp(Calendar cal)
<span class="fc" id="L626">    {</span>
        Precision precision;

<span class="fc bfc" id="L629" title="All 4 branches covered.">        if (cal.isSet(Calendar.MILLISECOND) || cal.isSet(Calendar.SECOND)) {</span>
<span class="fc" id="L630">            precision = Precision.SECOND;</span>
        }
<span class="pc bpc" id="L632" title="1 of 4 branches missed.">        else if (cal.isSet(Calendar.HOUR_OF_DAY) || cal.isSet(Calendar.MINUTE)) {</span>
<span class="fc" id="L633">            precision = Precision.MINUTE;</span>
        }
<span class="fc bfc" id="L635" title="All 2 branches covered.">        else if (cal.isSet(Calendar.DAY_OF_MONTH)) {</span>
<span class="fc" id="L636">            precision = Precision.DAY;</span>
        }
<span class="fc bfc" id="L638" title="All 2 branches covered.">        else if (cal.isSet(Calendar.MONTH)) {</span>
<span class="fc" id="L639">            precision = Precision.MONTH;</span>
        }
<span class="fc bfc" id="L641" title="All 2 branches covered.">        else if (cal.isSet(Calendar.YEAR)) {</span>
<span class="fc" id="L642">            precision = Precision.YEAR;</span>
        }
        else {
<span class="fc" id="L645">            throw new IllegalArgumentException(&quot;Calendar has no fields set&quot;);</span>
        }

<span class="fc" id="L648">        set_fields_from_calendar(cal, precision, true);</span>
<span class="fc" id="L649">    }</span>


    private Timestamp(Calendar cal, Precision precision, BigDecimal fraction,
                      Integer offset)
<span class="fc" id="L654">    {</span>
<span class="fc" id="L655">        set_fields_from_calendar(cal, precision, false);</span>
<span class="fc" id="L656">        _fraction = fraction;</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (offset != null)</span>
        {
<span class="fc" id="L659">            _offset = offset;</span>
<span class="fc" id="L660">            apply_offset(offset);</span>
        }
<span class="fc" id="L662">    }</span>


    private Timestamp(BigDecimal millis, Precision precision, Integer localOffset)
<span class="fc" id="L666">    {</span>
        // check bounds to avoid hanging when calling longValue() on decimals with large positive exponents,
        // e.g. 1e10000000
<span class="fc bfc" id="L669" title="All 2 branches covered.">        if(millis.compareTo(MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL) &lt; 0 ||</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL.compareTo(millis) &lt;= 0) {</span>
<span class="nc" id="L671">            throwTimestampOutOfRangeError(millis);</span>
        }
        // quick handle integral zero
<span class="fc bfc" id="L674" title="All 2 branches covered.">        long ms = isIntegralZero(millis) ? 0 : millis.longValue();</span>
<span class="fc" id="L675">        set_fields_from_millis(ms);</span>

<span class="fc bfc" id="L677" title="All 5 branches covered.">        switch (precision)</span>
        {
            case YEAR:
<span class="fc" id="L680">                _month  = 1;</span>
            case MONTH:
<span class="fc" id="L682">                _day    = 1;</span>
            case DAY:
<span class="fc" id="L684">                _hour   = 0;</span>
<span class="fc" id="L685">                _minute = 0;</span>
            case MINUTE:
<span class="fc" id="L687">                _second = 0;</span>
            case SECOND:
        }

<span class="fc" id="L691">        _offset = localOffset;</span>
        // The given BigDecimal may contain greater than milliseconds precision, which is the maximum precision that
        // a Calendar can handle. Set the _fraction here so that extra precision (if any) is not lost.
        // However, don't set the fraction if the given BigDecimal does not have precision at least to the tenth of
        // a second.
<span class="pc bpc" id="L696" title="1 of 4 branches missed.">        if (precision.includes(Precision.SECOND) &amp;&amp; millis.scale() &gt; -3) {</span>
<span class="fc" id="L697">            BigDecimal secs = millis.movePointLeft(3);</span>
<span class="fc" id="L698">            BigDecimal secsDown = fastRoundZeroFloor(secs);</span>
<span class="fc" id="L699">            _fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L700">        } else {</span>
<span class="fc" id="L701">            _fraction = null;</span>
        }
<span class="fc" id="L703">        _precision = checkFraction(precision, _fraction);</span>
<span class="fc" id="L704">    }</span>


    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds (including any fractional
     * milliseconds) from the epoch, with a given local offset.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the second if {@code millis}
     * doesn't contain information that is more granular than seconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;132541995e4 (132541995 &amp;times; 10&lt;sup&gt;4&lt;/sup&gt;)&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30Z},
     * precise to the second.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second if
     * {@code millis} contains information that is at least granular to
     * milliseconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;1325419950555&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30.555Z},
     * precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     */
    @Deprecated
    private Timestamp(BigDecimal millis, Integer localOffset)
<span class="fc" id="L741">    {</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">        if (millis == null) throw new NullPointerException(&quot;millis is null&quot;);</span>

        // check bounds to avoid hanging when calling longValue() on decimals with large positive exponents,
        // e.g. 1e10000000
<span class="fc bfc" id="L746" title="All 2 branches covered.">        if(millis.compareTo(MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL) &lt; 0 ||</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">            MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL.compareTo(millis) &lt; 0) {</span>
<span class="nc" id="L748">            throwTimestampOutOfRangeError(millis);</span>
        }

        // quick handle integral zero
<span class="fc bfc" id="L752" title="All 2 branches covered.">        long ms = isIntegralZero(millis) ? 0 : millis.longValue();</span>

<span class="fc" id="L754">        set_fields_from_millis(ms);</span>

<span class="fc" id="L756">        int scale = millis.scale();</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">        if (scale &lt;= -3) {</span>
<span class="fc" id="L758">            this._precision = Precision.SECOND;</span>
<span class="fc" id="L759">            this._fraction = null;</span>
        }
        else {
<span class="fc" id="L762">            BigDecimal secs = millis.movePointLeft(3);</span>
<span class="fc" id="L763">            BigDecimal secsDown = fastRoundZeroFloor(secs);</span>
<span class="fc" id="L764">            this._fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L765">            this._precision = checkFraction(Precision.SECOND, _fraction);</span>
        }
<span class="fc" id="L767">        this._offset = localOffset;</span>
<span class="fc" id="L768">    }</span>

    private BigDecimal fastRoundZeroFloor(final BigDecimal decimal) {
<span class="fc bfc" id="L771" title="All 2 branches covered.">        BigDecimal fastValue = decimal.signum() &lt; 0 ? BigDecimal.ONE.negate() : BigDecimal.ZERO;</span>

<span class="fc bfc" id="L773" title="All 2 branches covered.">        return isIntegralZero(decimal) ? fastValue : decimal.setScale(0, RoundingMode.FLOOR);</span>
    }

    private boolean isIntegralZero(final BigDecimal decimal) {
        // zero || no low-order bits || &lt; 1.0
<span class="fc bfc" id="L778" title="All 2 branches covered.">        return  decimal.signum() == 0</span>
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">            || decimal.scale() &lt; -63</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">            || (decimal.precision() - decimal.scale() &lt;= 0);</span>
    }

    private static void throwTimestampOutOfRangeError(Number millis) {
<span class="fc" id="L784">        throw new IllegalArgumentException(&quot;millis: &quot; + millis + &quot; is outside of valid the range: from &quot;</span>
                + MINIMUM_TIMESTAMP_IN_MILLIS
                + &quot; (0001T)&quot;
                + &quot;, inclusive, to &quot;
                + MAXIMUM_TIMESTAMP_IN_MILLIS
                + &quot; (10000T)&quot;
                + &quot; , exclusive&quot;);
    }

    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds from the epoch, with a given local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds from the epoch (1970-01-01T00:00:00.000Z)
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     */
    @Deprecated
    private Timestamp(long millis, Integer localOffset)
<span class="fc" id="L807">    {</span>
<span class="fc bfc" id="L808" title="All 4 branches covered.">        if(millis &lt; MINIMUM_TIMESTAMP_IN_MILLIS || millis &gt;= MAXIMUM_TIMESTAMP_IN_MILLIS) {</span>
<span class="nc" id="L809">            throwTimestampOutOfRangeError(millis);</span>
        }
<span class="fc" id="L811">        this.set_fields_from_millis(millis);</span>

        // fractional seconds portion
<span class="fc" id="L814">        BigDecimal secs = BigDecimal.valueOf(millis).movePointLeft(3);</span>
<span class="fc" id="L815">        BigDecimal secsDown = secs.setScale(0, RoundingMode.FLOOR);</span>
<span class="fc" id="L816">        this._fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L817">        this._precision = checkFraction(Precision.SECOND, _fraction);</span>

<span class="fc" id="L819">        this._offset = localOffset;</span>
<span class="fc" id="L820">    }</span>


    private static IllegalArgumentException fail(CharSequence input, String reason)
    {
<span class="fc" id="L825">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L826">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + reason</span>
                                            + &quot;: &quot; + input);
    }

    private static IllegalArgumentException fail(CharSequence input)
    {
<span class="fc" id="L832">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L833">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + input);</span>
    }

    static final String NULL_TIMESTAMP_IMAGE = &quot;null.timestamp&quot;;
<span class="fc" id="L837">    static final int    LEN_OF_NULL_IMAGE    = NULL_TIMESTAMP_IMAGE.length();</span>
    static final int    END_OF_YEAR          =  4;  // 1234T
    static final int    END_OF_MONTH         =  7;  // 1234-67T
    static final int    END_OF_DAY           = 10;  // 1234-67-90T
    static final int    END_OF_MINUTES       = 16;
    static final int    END_OF_SECONDS       = 19;


    /**
     * Returns a new Timestamp that represents the point in time, precision
     * and local offset defined in Ion format by the {@link CharSequence}.
     *
     * @param ionFormattedTimestamp
     *          a sequence of characters that is the Ion representation of a
     *          Timestamp
     *
     * @throws IllegalArgumentException
     *          if the {@code CharSequence} is an invalid Ion representation
     *          of a Timestamp;
     *          or if the {@code CharSequence} has excess characters which
     *          are not one of the following valid thirteen numeric-stop
     *          characters (escaped accordingly for readability):
     *          &lt;code&gt;{}[](),\&quot;\'\ \t\n\r}&lt;/code&gt;
     *
     * @return
     *          {@code null} if the {@code CharSequence} is &quot;null.timestamp&quot;
     *
     * @see &lt;a href=&quot;http://amzn.github.io/ion-docs/spec.html#timestamp&quot;&gt;Ion Timestamp Page&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;W3C Note on Date and Time Formats&lt;/a&gt;
     */
    public static Timestamp valueOf(CharSequence ionFormattedTimestamp)
    {
<span class="fc" id="L869">        final CharSequence in = ionFormattedTimestamp;</span>
        int pos;

<span class="fc" id="L872">        final int length = in.length();</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">        if (length == 0)</span>
        {
<span class="nc" id="L875">            throw fail(in);</span>
        }

        // check for 'null.timestamp'
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (in.charAt(0) == 'n') {</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">            if (length &gt;= LEN_OF_NULL_IMAGE</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">                &amp;&amp; NULL_TIMESTAMP_IMAGE.contentEquals(in.subSequence(0, LEN_OF_NULL_IMAGE)))</span>
            {
<span class="fc bfc" id="L883" title="All 2 branches covered.">                if (length &gt; LEN_OF_NULL_IMAGE) {</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">                    if (!isValidFollowChar(in.charAt(LEN_OF_NULL_IMAGE))) {</span>
<span class="fc" id="L885">                        throw fail(in);</span>
                    }
                }
<span class="fc" id="L888">                return null;</span>
            }
<span class="fc" id="L890">            throw fail(in);</span>
        }

<span class="fc" id="L893">        int year  = 1;</span>
<span class="fc" id="L894">        int month = 1;</span>
<span class="fc" id="L895">        int day   = 1;</span>
<span class="fc" id="L896">        int hour  = 0;</span>
<span class="fc" id="L897">        int minute = 0;</span>
<span class="fc" id="L898">        int seconds = 0;</span>
<span class="fc" id="L899">        BigDecimal fraction = null;</span>
        Precision precision;

        // fake label to turn goto's into a break so Java is happy :) enjoy
        do {
            // otherwise we expect yyyy-mm-ddThh:mm:ss.ssss+hh:mm
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">            if (length &lt; END_OF_YEAR + 1) {  // +1 for the &quot;T&quot;</span>
<span class="nc" id="L906">                throw fail(in, &quot;year is too short (must be at least yyyyT)&quot;);</span>
            }
<span class="fc" id="L908">            pos = END_OF_YEAR;</span>
<span class="fc" id="L909">            precision = Precision.YEAR;</span>
<span class="fc" id="L910">            year  = read_digits(in, 0, 4, -1, &quot;year&quot;);</span>

<span class="fc" id="L912">            char c = in.charAt(END_OF_YEAR);</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L915">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between year and month, found &quot;
<span class="fc" id="L917">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L919" title="All 2 branches covered.">            if (length &lt; END_OF_MONTH + 1) {  // +1 for the &quot;T&quot;</span>
<span class="fc" id="L920">                throw fail(in, &quot;month is too short (must be yyyy-mmT)&quot;);</span>
            }
<span class="fc" id="L922">            pos = END_OF_MONTH;</span>
<span class="fc" id="L923">            precision = Precision.MONTH;</span>
<span class="fc" id="L924">            month = read_digits(in, END_OF_YEAR + 1, 2, -1,  &quot;month&quot;);</span>

<span class="fc" id="L926">            c = in.charAt(END_OF_MONTH);</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L929">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between month and day, found &quot;
<span class="fc" id="L931">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L933" title="All 2 branches covered.">            if (length &lt; END_OF_DAY) {</span>
<span class="fc" id="L934">                throw fail(in, &quot;too short for yyyy-mm-dd&quot;);</span>
            }
<span class="fc" id="L936">            pos = END_OF_DAY;</span>
<span class="fc" id="L937">            precision = Precision.DAY;</span>
<span class="fc" id="L938">            day   = read_digits(in, END_OF_MONTH + 1, 2, -1, &quot;day&quot;);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">            if (length == END_OF_DAY) break;</span>
<span class="fc" id="L940">            c = in.charAt(END_OF_DAY);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">            if (c != 'T') {</span>
<span class="fc" id="L942">                throw fail(in,</span>
                           &quot;expected \&quot;T\&quot; after day, found &quot;
<span class="fc" id="L944">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L946" title="All 2 branches covered.">            if (length == END_OF_DAY + 1) break;</span>

            // now lets see if we have a time value
<span class="fc bfc" id="L949" title="All 2 branches covered.">            if (length &lt; END_OF_MINUTES) {</span>
<span class="fc" id="L950">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm&quot;);</span>
            }
<span class="fc" id="L952">            hour   = read_digits(in, 11, 2, ':', &quot;hour&quot;);</span>
<span class="fc" id="L953">            minute = read_digits(in, 14, 2, -1, &quot;minutes&quot;);</span>
<span class="fc" id="L954">            pos = END_OF_MINUTES;</span>
<span class="fc" id="L955">            precision = Precision.MINUTE;</span>

            // we may have seconds
<span class="fc bfc" id="L958" title="All 4 branches covered.">            if (length &lt;= END_OF_MINUTES || in.charAt(END_OF_MINUTES) != ':')</span>
            {
<span class="fc" id="L960">                break;</span>
            }
<span class="fc bfc" id="L962" title="All 2 branches covered.">            if (length &lt; END_OF_SECONDS) {</span>
<span class="fc" id="L963">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm:ss&quot;);</span>
            }
<span class="fc" id="L965">            seconds = read_digits(in, 17, 2, -1, &quot;seconds&quot;);</span>
<span class="fc" id="L966">            pos = END_OF_SECONDS;</span>
<span class="fc" id="L967">            precision = Precision.SECOND;</span>

<span class="fc bfc" id="L969" title="All 4 branches covered.">            if (length &lt;= END_OF_SECONDS || in.charAt(END_OF_SECONDS) != '.')</span>
            {
<span class="fc" id="L971">                break;</span>
            }
<span class="fc" id="L973">            precision = Precision.SECOND;</span>
<span class="fc" id="L974">            pos = END_OF_SECONDS + 1;</span>
<span class="fc bfc" id="L975" title="All 4 branches covered.">            while (length &gt; pos &amp;&amp; Character.isDigit(in.charAt(pos))) {</span>
<span class="fc" id="L976">                pos++;</span>
            }
<span class="fc bfc" id="L978" title="All 2 branches covered.">            if (pos &lt;= END_OF_SECONDS + 1) {</span>
<span class="fc" id="L979">                throw fail(in,</span>
                           &quot;must have at least one digit after decimal point&quot;);
            }
<span class="fc" id="L982">            fraction = new BigDecimal(in.subSequence(19, pos).toString());</span>
        } while (false);

        Integer offset;

        // now see if they included a timezone offset
<span class="fc bfc" id="L988" title="All 2 branches covered.">        char timezone_start = pos &lt; length ? in.charAt(pos) : '\n';</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">        if (timezone_start == 'Z') {</span>
<span class="fc" id="L990">            offset = 0;</span>
<span class="fc" id="L991">            pos++;</span>
        }
<span class="fc bfc" id="L993" title="All 4 branches covered.">        else if (timezone_start == '+' || timezone_start == '-')</span>
        {
<span class="fc bfc" id="L995" title="All 2 branches covered.">            if (length &lt; pos + 5) {</span>
<span class="fc" id="L996">                throw fail(in, &quot;local offset too short&quot;);</span>
            }
            // +/- hh:mm
<span class="fc" id="L999">            pos++;</span>
<span class="fc" id="L1000">            int tzdHours = read_digits(in, pos, 2, ':', &quot;local offset hours&quot;);</span>
<span class="pc bpc" id="L1001" title="1 of 4 branches missed.">            if (tzdHours &lt; 0 || tzdHours &gt; 23) {</span>
<span class="fc" id="L1002">                throw fail(in,</span>
                           &quot;local offset hours must be between 0 and 23 inclusive&quot;);
            }
<span class="fc" id="L1005">            pos += 3;</span>

<span class="fc" id="L1007">            int tzdMinutes = read_digits(in, pos, 2, -1, &quot;local offset minutes&quot;);</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">            if (tzdMinutes &gt; 59) {</span>
<span class="fc" id="L1009">                throw fail(in,</span>
                           &quot;local offset minutes must be between 0 and 59 inclusive&quot;);
            }
<span class="fc" id="L1012">            pos += 2;</span>

<span class="fc" id="L1014">            int temp = tzdHours * 60 + tzdMinutes;</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">            if (timezone_start == '-') {</span>
<span class="fc" id="L1016">                temp = -temp;</span>
            }
<span class="fc bfc" id="L1018" title="All 4 branches covered.">            if (temp == 0 &amp;&amp; timezone_start == '-') {</span>
                // int doesn't do negative zero very elegantly
<span class="fc" id="L1020">                offset = null;</span>
            }
            else {
<span class="fc" id="L1023">                offset = temp;</span>
            }
<span class="fc" id="L1025">        }</span>
        else {
<span class="fc bfc" id="L1027" title="All 2 branches covered.">            switch (precision) {</span>
                case YEAR:
                case MONTH:
                case DAY:
<span class="fc" id="L1031">                    break;</span>
                default:
<span class="fc" id="L1033">                    throw fail(in, &quot;missing local offset&quot;);</span>
            }
<span class="fc" id="L1035">            offset = null;</span>
        }
<span class="pc bpc" id="L1037" title="1 of 4 branches missed.">        if (length &gt; (pos + 1) &amp;&amp; !isValidFollowChar(in.charAt(pos + 1)))</span>
        {
<span class="fc" id="L1039">            throw fail(in, &quot;invalid excess characters&quot;);</span>
        }

<span class="fc" id="L1042">        Timestamp ts =</span>
            new Timestamp(precision, year, month, day,
                          hour, minute, seconds, fraction, offset, APPLY_OFFSET_YES);
<span class="fc" id="L1045">        return ts;</span>
    }

    private static int read_digits(CharSequence in, int start, int length,
                                   int terminator, String field)
    {
<span class="fc" id="L1051">        int ii, value = 0;</span>
<span class="fc" id="L1052">        int end = start + length;</span>

<span class="fc bfc" id="L1054" title="All 2 branches covered.">        if (in.length() &lt; end) {</span>
<span class="fc" id="L1055">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits&quot;);
        }

<span class="fc bfc" id="L1059" title="All 2 branches covered.">        for (ii=start; ii&lt;end; ii++) {</span>
<span class="fc" id="L1060">            char c = in.charAt(ii);</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">            if (!Character.isDigit(c)) {</span>
                // FIXME this will give incorrect message if c is a surrogate
<span class="fc" id="L1063">                throw fail(in,</span>
                           field + &quot; has non-digit character &quot;
<span class="fc" id="L1065">                               + printCodePointAsString(c));</span>
            }
<span class="fc" id="L1067">            value *= 10;</span>
<span class="fc" id="L1068">            value += c - '0';</span>
        }

        // Check the terminator if requested.
<span class="fc bfc" id="L1072" title="All 2 branches covered.">        if (terminator != -1) {</span>
<span class="pc bpc" id="L1073" title="1 of 4 branches missed.">            if (ii &gt;= in.length() || in.charAt(ii) != terminator) {</span>
<span class="fc" id="L1074">                throw fail(in,</span>
                           field + &quot; should end with &quot;
<span class="fc" id="L1076">                               + printCodePointAsString(terminator));</span>
            }
        }
        // Otherwise make sure we don't have too many digits.
<span class="fc bfc" id="L1080" title="All 4 branches covered.">        else if (ii &lt; in.length() &amp;&amp; Character.isDigit(in.charAt(ii))) {</span>
<span class="fc" id="L1081">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits but has more&quot;);
        }

<span class="fc" id="L1085">        return value;</span>
    }

    private static boolean isValidFollowChar(char c) {
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">        switch (c) {</span>
        default:
<span class="fc" id="L1091">            return false;</span>
        case '{':
        case '}':
        case '[':
        case ']':
        case '(':
        case ')':
        case ',':
        case '\&quot;':
        case '\'':
        case '\\':
        case '\t':
        case '\n':
        case '\r':
<span class="nc" id="L1105">            return true;</span>
        }
    }

    /**
     * Creates a copy of this Timestamp. The resulting Timestamp will
     * represent the same point in time and has the same precision and local
     * offset.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public Timestamp clone()
    {
        // The Copy-Constructor we're using here already expects the time field
        // values to be in UTC, and that is already what we have for this
        // Timestamp -- no adjustment necessary to make it local time.
<span class="fc" id="L1122">        return new Timestamp(_precision,</span>
                             _year,
                             _month,
                             _day,
                             _hour,
                             _minute,
                             _second,
                             _fraction,
                             _offset,
                             APPLY_OFFSET_NO);
    }

    /**
     * Applies the local offset from UTC to each of the applicable time field
     * values and returns the new Timestamp. In short, this makes the Timestamp
     * represent local time.
     *
     * @return a new Timestamp in its local time
     */
    private Timestamp make_localtime()
    {
<span class="fc bfc" id="L1143" title="All 2 branches covered.">        int offset = _offset != null</span>
<span class="fc" id="L1144">            ? _offset.intValue()</span>
<span class="fc" id="L1145">            : 0;</span>

        // We use a Copy-Constructor that expects the time parameters to be in
        // UTC, as that's what we're supposed to have.
        // As this Copy-Constructor doesn't apply local offset to the time
        // field values (it assumes that the local offset is already applied to
        // them), we explicitly apply the local offset to the time field values
        // after we obtain the new Timestamp instance.
<span class="fc" id="L1153">        Timestamp localtime = new Timestamp(_precision,</span>
                                            _year,
                                            _month,
                                            _day,
                                            _hour,
                                            _minute,
                                            _second,
                                            _fraction,
                                            _offset,
                                            APPLY_OFFSET_NO);
        // explicitly apply the local offset to the time field values
<span class="fc" id="L1164">        localtime.apply_offset(-offset);</span>

<span class="pc bpc" id="L1166" title="2 of 4 branches missed.">        assert localtime._offset == _offset;</span>

<span class="fc" id="L1168">        return localtime;</span>
    }

    /**
     * Returns a Timestamp, precise to the year, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    public static Timestamp forYear(int yearZ)
    {
<span class="fc" id="L1178">        return new Timestamp(yearZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the month, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    public static Timestamp forMonth(int yearZ, int monthZ)
    {
<span class="fc" id="L1188">        return new Timestamp(yearZ, monthZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the day, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     *
     */
    public static Timestamp forDay(int yearZ, int monthZ, int dayZ)
    {
<span class="fc" id="L1199">        return new Timestamp(yearZ, monthZ, dayZ);</span>
    }


    /**
     * Returns a Timestamp, precise to the minute, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forMinute(int year, int month, int day,
                                      int hour, int minute,
                                      Integer offset)
    {
<span class="fc" id="L1220">        return new Timestamp(year, month, day, hour, minute, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, int second,
                                      Integer offset)
    {
<span class="fc" id="L1240">        return new Timestamp(year, month, day, hour, minute, second, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss.sss+-oo:oo}, where {@code oo:oo} represents
     * the hour and minutes of the local offset from UTC.
     *
     * @param second must be at least zero and less than 60.
     * Must not be null.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, BigDecimal second,
                                      Integer offset)
    {
        // Tease apart the whole and fractional seconds.
        // Storing them separately is silly.
<span class="fc" id="L1265">        int s = second.intValue();</span>
<span class="fc" id="L1266">        BigDecimal frac = second.subtract(BigDecimal.valueOf(s));</span>
<span class="fc" id="L1267">        return new Timestamp(Precision.SECOND, year, month, day, hour, minute, s, frac, offset, APPLY_OFFSET_YES);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is
     * {@code millis} milliseconds from the epoch, with a given local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @param millis
     * the number of milliseconds from the epoch (1970-01-01T00:00:00.000Z).
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     */
    public static Timestamp forMillis(long millis, Integer localOffset)
    {
<span class="fc" id="L1286">        return new Timestamp(millis, localOffset);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is
     * {@code millis} milliseconds (including any fractional
     * milliseconds) from the epoch, with a given local offset.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the second if {@code millis}
     * doesn't contain information that is more granular than seconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;132541995e4 (132541995 &amp;times; 10&lt;sup&gt;4&lt;/sup&gt;)&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30Z},
     * precise to the second.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second if
     * {@code millis} contains information that is at least granular to
     * milliseconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;1325419950555&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30.555Z},
     * precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     *
     */
    public static Timestamp forMillis(BigDecimal millis, Integer localOffset)
    {
<span class="fc" id="L1325">        return new Timestamp(millis, localOffset);</span>
    }


    /**
     * Converts a {@link Calendar} to a Timestamp, preserving the calendar's
     * time zone as the equivalent local offset when it has at least minutes
     * precision.
     *
     * @return a Timestamp instance, with precision determined by the smallest
     *   field set in the {@code Calendar};
     *   or {@code null} if {@code calendar} is {@code null}
     *
     */
    public static Timestamp forCalendar(Calendar calendar)
    {
<span class="pc bpc" id="L1341" title="1 of 2 branches missed.">        if (calendar == null) return null;</span>
<span class="fc" id="L1342">        return new Timestamp(calendar);</span>
    }


    /**
     * Converts a {@link Date} to a Timestamp in UTC representing the same
     * point in time.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the millisecond;
     *          {@code null} if {@code date} is {@code null}
     *
     */
    public static Timestamp forDateZ(Date date)
    {
<span class="fc bfc" id="L1359" title="All 2 branches covered.">        if (date == null) return null;</span>
<span class="fc" id="L1360">        long millis = date.getTime();</span>
<span class="fc" id="L1361">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts a {@link java.sql.Timestamp} to a Timestamp in UTC representing
     * the same point in time.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the nanosecond.
     *
     * @param sqlTimestamp assumed to have nanoseconds precision
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the
     *          nanosecond
     *          {@code null} if {@code sqlTimestamp} is {@code null}
     *
     */
    public static Timestamp forSqlTimestampZ(java.sql.Timestamp sqlTimestamp)
    {
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        if (sqlTimestamp == null) return null;</span>

<span class="fc" id="L1383">        long millis = sqlTimestamp.getTime();</span>
<span class="fc" id="L1384">        Timestamp ts = new Timestamp(millis, UTC_OFFSET);</span>
<span class="fc" id="L1385">        int nanos = sqlTimestamp.getNanos();</span>
<span class="fc" id="L1386">        BigDecimal frac = BigDecimal.valueOf(nanos).movePointLeft(9);</span>
<span class="fc" id="L1387">        ts._fraction = frac;</span>
<span class="fc" id="L1388">        return ts;</span>
    }


    /**
     * Returns a Timestamp representing the current time (based on the JVM
     * clock), with an unknown local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance representing the current time.
     */
    public static Timestamp now()
    {
<span class="nc" id="L1403">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1404">        return new Timestamp(millis, UNKNOWN_OFFSET);</span>
    }

    /**
     * Returns a Timestamp in UTC representing the current time (based on the
     * the JVM clock).
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, representing the current
     *          time.
     *
     */
    public static Timestamp nowZ()
    {
<span class="nc" id="L1420">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1421">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts the value of this Timestamp into a {@link Date},
     * representing the time in UTC.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     * &lt;p&gt;
     * Because {@link Date} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Date} instance, in UTC
     */
    public Date dateValue()
    {
<span class="fc" id="L1439">        long millis = getMillis();</span>
<span class="fc" id="L1440">        return new Date(millis);</span>
    }


    /**
     * Converts the value of this Timestamp as a {@link Calendar}, in its
     * local time.
     * &lt;p&gt;
     * Because {@link Calendar} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Calendar} instance, in its local time.
     *
     */
    public Calendar calendarValue()
    {
<span class="fc" id="L1456">        Calendar cal = new GregorianCalendar(PrivateUtils.UTC);</span>

<span class="fc" id="L1458">        long millis = getMillis();</span>
<span class="fc" id="L1459">        Integer offset = _offset;</span>
<span class="fc bfc" id="L1460" title="All 4 branches covered.">        if (offset != null &amp;&amp; offset != 0)</span>
        {
<span class="fc" id="L1462">            int offsetMillis = offset * 60 * 1000;</span>
<span class="fc" id="L1463">            millis += offsetMillis;</span>
<span class="fc" id="L1464">            cal.setTimeInMillis(millis);                // Resets the offset!</span>
<span class="fc" id="L1465">            cal.set(Calendar.ZONE_OFFSET, offsetMillis);</span>
<span class="fc" id="L1466">        }</span>
        else
        {
<span class="fc" id="L1469">            cal.setTimeInMillis(millis);</span>
        }

<span class="pc bpc" id="L1472" title="1 of 6 branches missed.">        switch (_precision) {</span>
            case YEAR:
<span class="fc" id="L1474">                cal.clear(Calendar.MONTH);</span>
            case MONTH:
<span class="fc" id="L1476">                cal.clear(Calendar.DAY_OF_MONTH);</span>
            case DAY:
<span class="fc" id="L1478">                cal.clear(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L1479">                cal.clear(Calendar.MINUTE);</span>
            case MINUTE:
<span class="fc" id="L1481">                cal.clear(Calendar.SECOND);</span>
<span class="fc" id="L1482">                cal.clear(Calendar.MILLISECOND);</span>
            case SECOND:
<span class="fc bfc" id="L1484" title="All 2 branches covered.">                if (_fraction == null) {</span>
<span class="fc" id="L1485">                    cal.clear(Calendar.MILLISECOND);</span>
                }
        }

<span class="fc" id="L1489">        return cal;</span>
    }


    /**
     * Returns a number representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional milliseconds)
     * from the epoch.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public long getMillis()
    {
        //                                        month is 0 based for Date
<span class="fc" id="L1509">        long millis = Date.UTC(this._year - 1900, this._month - 1, this._day, this._hour, this._minute, this._second);</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        if (this._fraction != null) {</span>
<span class="fc" id="L1511">            BigDecimal fracAsDecimal = this._fraction.movePointRight(3);</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">            int frac = isIntegralZero(fracAsDecimal) ? 0 : fracAsDecimal.intValue();</span>
<span class="fc" id="L1513">            millis += frac;</span>
        }
<span class="fc" id="L1515">        return millis;</span>

    }

    /**
     * Returns a BigDecimal representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional milliseconds)
     * from the epoch.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public BigDecimal getDecimalMillis()
    {
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">        switch (this._precision) {</span>
        case YEAR:
        case MONTH:
        case DAY:
        case MINUTE:
        case SECOND:
<span class="fc" id="L1540">            long millis = Date.UTC(this._year - 1900, this._month - 1, this._day, this._hour, this._minute, this._second);</span>
<span class="fc" id="L1541">            BigDecimal dec = BigDecimal.valueOf(millis);</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">            if (_fraction != null) {</span>
<span class="fc" id="L1543">                dec = dec.add(this._fraction.movePointRight(3));</span>
            }
<span class="fc" id="L1545">            return dec;</span>
        }
<span class="nc" id="L1547">        throw new IllegalArgumentException();</span>
    }


    /**
     * Returns the precision of this Timestamp.
     */
    public Precision getPrecision()
    {
<span class="fc" id="L1556">        return this._precision;</span>
    }

    /**
     * Returns the offset of this Timestamp, measured in minutes, for the local
     * timezone in UTC.
     * &lt;p&gt;
     * For example, calling this method on Timestamps of:
     * &lt;ul&gt;
     *     &lt;li&gt;{@code 1969-02-23T07:00+07:00} will return {@code 420}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-22T22:45:00.00-01:15} will return {@code -75}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-23} (by Ion's definition, equivalent to
     *     {@code 1969-02-23T00:00-00:00}) will return {@code null}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return
     *          {@code null} if the local offset is unknown
     *          (i.e. {@code -00:00})
     */
    public Integer getLocalOffset()
    {
<span class="fc" id="L1577">        return _offset;</span>
    }


    /**
     * Returns the year of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 9999], in its local time
     */
    public int getYear()
    {
<span class="fc" id="L1589">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1591" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1592" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1593">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1596">        return adjusted._year;</span>
    }


    /**
     * Returns the month of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in its local time;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getMonth()
    {
<span class="fc" id="L1611">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1613" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1614" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1615">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1618">        return adjusted._month;</span>
    }


    /**
     * Returns the day (within the month) of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 31], in its local time;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getDay()
    {
<span class="fc" id="L1632">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1633" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1634" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1635">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1638">        return adjusted._day;</span>
    }


    /**
     * Returns the hour of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 23], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getHour()
    {
<span class="fc" id="L1652">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1653" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1655">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1658">        return adjusted._hour;</span>
    }


    /**
     * Returns the minute of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 59], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getMinute()
    {
<span class="fc" id="L1672">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1673" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1674" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1675">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1678">        return adjusted._minute;</span>
    }


    /**
     * Returns the seconds of this Timestamp, truncated to an integer.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getZSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZSecond()
     */
    public int getSecond()
    {
<span class="fc" id="L1696">        return this._second;</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getZDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZDecimalSecond()
     */
    public BigDecimal getDecimalSecond()
    {
<span class="fc" id="L1715">        BigDecimal sec = BigDecimal.valueOf(_second);</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">        if (_fraction != null)</span>
        {
<span class="fc" id="L1718">            sec = sec.add(_fraction);</span>
        }
<span class="fc" id="L1720">        return sec;</span>
    }


    /**
     * Returns the year of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 9999], in UTC
     */
    public int getZYear()
    {
<span class="fc" id="L1732">        return this._year;</span>
    }


    /**
     * Returns the month of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in UTC;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getZMonth()
    {
<span class="fc" id="L1747">        return this._month;</span>
    }


    /**
     * Returns the day of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 31], in UTC;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getZDay()
    {
<span class="fc" id="L1761">        return this._day;</span>
    }


    /**
     * Returns the hour of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 23], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getZHour()
    {
<span class="fc" id="L1775">        return this._hour;</span>
    }


    /**
     * Returns the minute of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 59], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getZMinute()
    {
<span class="fc" id="L1789">        return this._minute;</span>
    }


    /**
     * Returns the second of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getSecond()
     */
    public int getZSecond()
    {
<span class="fc" id="L1807">        return this._second;</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getDecimalSecond()
     */
    public BigDecimal getZDecimalSecond()
    {
<span class="nc" id="L1826">        return getDecimalSecond();</span>
    }


    /**
     * Returns the fractional second of this Timestamp.
     * &lt;p&gt;
     * Fractional seconds are not affected by local offsets.
     *
     * @return
     *          a BigDecimal within the range [0, 1);
     *          {@code null} is returned if the Timestamp isn't
     *          precise to the fractional second
     *
     * @deprecated This is an internal API that is subject to change without notice.
     */
    @Deprecated
    public BigDecimal getZFractionalSecond()
    {
<span class="fc" id="L1845">        return this._fraction;</span>
    }


    //=========================================================================
    // Modification methods


    /**
     * Returns a timestamp at the same point in time, but with the given local
     * offset.  If this timestamp has precision coarser than minutes, then it
     * is returned unchanged since such timestamps always have an unknown
     * offset.
     */
    public Timestamp withLocalOffset(Integer offset)
    {
<span class="fc" id="L1861">        Precision precision = getPrecision();</span>
<span class="fc bfc" id="L1862" title="All 2 branches covered.">        if (precision.alwaysUnknownOffset() ||</span>
<span class="fc bfc" id="L1863" title="All 2 branches covered.">            safeEquals(offset, getLocalOffset()))</span>
        {
<span class="fc" id="L1865">            return this;</span>
        }

<span class="fc" id="L1868">        Timestamp ts = createFromUtcFields(precision,</span>
<span class="fc" id="L1869">                                           getZYear(),</span>
<span class="fc" id="L1870">                                           getZMonth(),</span>
<span class="fc" id="L1871">                                           getZDay(),</span>
<span class="fc" id="L1872">                                           getZHour(),</span>
<span class="fc" id="L1873">                                           getZMinute(),</span>
<span class="fc" id="L1874">                                           getZSecond(),</span>
<span class="fc" id="L1875">                                           getZFractionalSecond(),</span>
                                           offset);
<span class="fc" id="L1877">        return ts;</span>
    }


    //=========================================================================


    /**
     * Returns the string representation (in Ion format) of this Timestamp in
     * its local time.
     *
     * @see #toZString()
     * @see #print(Appendable)
     */
    @Override
    public String toString()
    {
<span class="fc" id="L1894">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L1897">            print(buffer);</span>
        }
<span class="nc" id="L1899">        catch (IOException e)</span>
        {
<span class="nc" id="L1901">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                                       e);
<span class="fc" id="L1903">        }</span>
<span class="fc" id="L1904">        return buffer.toString();</span>
    }

    /**
     * Returns the string representation (in Ion format) of this Timestamp
     * in UTC.
     *
     * @see #toString()
     * @see #printZ(Appendable)
     */
    public String toZString()
    {
<span class="fc" id="L1916">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L1919">            printZ(buffer);</span>
        }
<span class="nc" id="L1921">        catch (IOException e)</span>
        {
<span class="nc" id="L1923">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                e);
<span class="fc" id="L1925">        }</span>
<span class="fc" id="L1926">        return buffer.toString();</span>
    }

    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in its local time.
     * &lt;p&gt;
     * This method produces the same output as {@link #toString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@link Appendable} throws it
     *
     * @see #printZ(Appendable)
     */
    public void print(Appendable out)
        throws IOException
    {
        // we have to make a copy to preserve the &quot;immutable&quot; contract
        // on Timestamp and we don't want someone reading the calendar
        // member while we've shifted it around.
<span class="fc" id="L1947">        Timestamp adjusted = this;</span>

        // Adjust UTC time back to local time
<span class="fc bfc" id="L1950" title="All 4 branches covered.">        if (this._offset != null &amp;&amp; this._offset.intValue() != 0) {</span>
<span class="fc" id="L1951">            adjusted = make_localtime();</span>
        }

<span class="fc" id="L1954">        print(out, adjusted);</span>
<span class="fc" id="L1955">    }</span>

    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in UTC.
     * &lt;p&gt;
     * This method produces the same output as {@link #toZString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@code Appendable} throws it.
     *
     * @see #print(Appendable)
     */
    public void printZ(Appendable out)
        throws IOException
    {
<span class="pc bpc" id="L1972" title="1 of 3 branches missed.">        switch (_precision)</span>
        {
            case YEAR:
            case MONTH:
            case DAY:
            {
<span class="pc bpc" id="L1978" title="2 of 4 branches missed.">                assert _offset == UNKNOWN_OFFSET;</span>
                // No need to adjust offset, we won't be using it.
<span class="fc" id="L1980">                print(out);</span>
<span class="fc" id="L1981">                break;</span>
            }
            case MINUTE:
            case SECOND:
            {
<span class="fc" id="L1986">                Timestamp ztime = this.clone();</span>
<span class="fc" id="L1987">                ztime._offset = UTC_OFFSET;</span>
<span class="fc" id="L1988">                ztime.print(out);</span>
<span class="fc" id="L1989">                break;</span>
            }
        }
<span class="fc" id="L1992">    }</span>

    /**
     * helper for print(out) and printZ(out) so that printZ can create
     * a zulu time and pass it directly and print can apply the local
     * offset and adjust the various fields (without breaking the
     * contract to be immutable).
     * @param out destination for the text image of the value
     * @param adjusted the time value with the fields adjusted to match the desired text output
     * @throws IOException
     */
    private static void print(Appendable out, Timestamp adjusted)
        throws IOException
    {
        // null is our first &quot;guess&quot; to get it out of the way
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">        if (adjusted == null) {</span>
<span class="nc" id="L2008">            out.append(&quot;null.timestamp&quot;);</span>
<span class="nc" id="L2009">            return;</span>
        }

        // so we have a real value - we'll start with the date portion
        // which we always have
<span class="fc" id="L2014">        print_digits(out, adjusted._year, 4);</span>
<span class="fc bfc" id="L2015" title="All 2 branches covered.">        if (adjusted._precision == Precision.YEAR) {</span>
<span class="pc bpc" id="L2016" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L2017">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L2018">            return;</span>
        }

<span class="fc" id="L2021">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L2022">        print_digits(out, adjusted._month, 2);  // convert calendar months to a base 1 value</span>
<span class="fc bfc" id="L2023" title="All 2 branches covered.">        if (adjusted._precision == Precision.MONTH) {</span>
<span class="pc bpc" id="L2024" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L2025">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L2026">            return;</span>
        }

<span class="fc" id="L2029">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L2030">        print_digits(out, adjusted._day, 2);</span>
<span class="fc bfc" id="L2031" title="All 2 branches covered.">        if (adjusted._precision == Precision.DAY) {</span>
<span class="pc bpc" id="L2032" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
            // out.append(&quot;T&quot;);
<span class="fc" id="L2034">            return;</span>
        }

<span class="fc" id="L2037">        out.append(&quot;T&quot;);</span>
<span class="fc" id="L2038">        print_digits(out, adjusted._hour, 2);</span>
<span class="fc" id="L2039">        out.append(&quot;:&quot;);</span>
<span class="fc" id="L2040">        print_digits(out, adjusted._minute, 2);</span>
        // ok, so how much time do we have ?
<span class="fc bfc" id="L2042" title="All 2 branches covered.">        if (adjusted._precision == Precision.SECOND) {</span>
<span class="fc" id="L2043">            out.append(&quot;:&quot;);</span>
<span class="fc" id="L2044">            print_digits(out, adjusted._second, 2);</span>
<span class="fc bfc" id="L2045" title="All 2 branches covered.">            if (adjusted._fraction != null) {</span>
<span class="fc" id="L2046">                print_fractional_digits(out, adjusted._fraction);</span>
            }
        }

<span class="fc bfc" id="L2050" title="All 2 branches covered.">        if (adjusted._offset != UNKNOWN_OFFSET) {</span>
            int min, hour;
<span class="fc" id="L2052">            min = adjusted._offset;</span>
<span class="fc bfc" id="L2053" title="All 2 branches covered.">            if (min == 0) {</span>
<span class="fc" id="L2054">                out.append('Z');</span>
            }
            else {
<span class="fc bfc" id="L2057" title="All 2 branches covered.">                if (min &lt; 0) {</span>
<span class="fc" id="L2058">                    min = -min;</span>
<span class="fc" id="L2059">                    out.append('-');</span>
                }
                else {
<span class="fc" id="L2062">                    out.append('+');</span>
                }
<span class="fc" id="L2064">                hour = min / 60;</span>
<span class="fc" id="L2065">                min = min - hour*60;</span>
<span class="fc" id="L2066">                print_digits(out, hour, 2);</span>
<span class="fc" id="L2067">                out.append(&quot;:&quot;);</span>
<span class="fc" id="L2068">                print_digits(out, min, 2);</span>
            }
<span class="fc" id="L2070">        }</span>
        else {
<span class="fc" id="L2072">            out.append(&quot;-00:00&quot;);</span>
        }
<span class="fc" id="L2074">    }</span>
    private static void print_digits(Appendable out, int value, int length)
        throws IOException
    {
<span class="fc" id="L2078">        char temp[] = new char[length];</span>
<span class="fc bfc" id="L2079" title="All 2 branches covered.">        while (length &gt; 0) {</span>
<span class="fc" id="L2080">            length--;</span>
<span class="fc" id="L2081">            int next = value / 10;</span>
<span class="fc" id="L2082">            temp[length] =  (char)('0' + (value - next*10));</span>
<span class="fc" id="L2083">            value = next;</span>
<span class="fc" id="L2084">        }</span>
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">        while (length &gt; 0) {</span>
<span class="nc" id="L2086">            length--;</span>
<span class="nc" id="L2087">            temp[length] =  '0';</span>
        }
<span class="fc bfc" id="L2089" title="All 2 branches covered.">        for (char c : temp) {</span>
<span class="fc" id="L2090">            out.append(c);</span>
        }
<span class="fc" id="L2092">    }</span>
    private static void print_fractional_digits(Appendable out, BigDecimal value)
        throws IOException
    {
<span class="fc" id="L2096">        String temp = value.toPlainString(); // crude, but it works</span>
<span class="pc bpc" id="L2097" title="1 of 2 branches missed.">        if (temp.charAt(0) == '0') { // this should always be true</span>
<span class="fc" id="L2098">            temp = temp.substring(1);</span>
        }
<span class="fc" id="L2100">        out.append(temp);</span>
<span class="fc" id="L2101">    }</span>


    //=========================================================================
    // Timestamp arithmetic


    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. After performing the arithmetic, the resulting Timestamp's
     * seconds value will be truncated to the same fractional precision as the
     * original. For example, adjusting {@code 2012-04-01T00:00:00Z} by one
     * millisecond results in {@code 2012-04-01T00:00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00.0010Z} by -1 millisecond results in
     * {@code 2012-04-01T00:00:00.0000Z}. To extend the precision when the
     * original Timestamp has coarser than SECOND precision and to avoid
     * truncation of the seconds value, use {@link #addSecond(int)}.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp adjustMillis(long amount) {
<span class="fc bfc" id="L2125" title="All 2 branches covered.">        if (amount == 0) return this;</span>
<span class="fc" id="L2126">        Timestamp ts = addMillisForPrecision(amount, _precision, false);</span>
<span class="fc" id="L2127">        ts.clearUnusedPrecision();</span>
<span class="fc bfc" id="L2128" title="All 2 branches covered.">        if (ts._precision.includes(Precision.SECOND)) {</span>
            // Maintain the same amount of fractional precision.
<span class="fc bfc" id="L2130" title="All 2 branches covered.">            if (_fraction == null) {</span>
<span class="fc" id="L2131">                ts._fraction = null;</span>
            } else {
                // Truncate the result only if it exceeds the fractional precision of the original.
<span class="pc bpc" id="L2134" title="1 of 2 branches missed.">                if (ts._fraction.scale() &gt; _fraction.scale()) {</span>
<span class="nc" id="L2135">                    ts._fraction = ts._fraction.setScale(_fraction.scale(), RoundingMode.FLOOR);</span>
                }
            }
        }
<span class="fc" id="L2139">        return ts;</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision and a seconds
     * value precise at least to the millisecond. For example, adding one millisecond
     * to {@code 2011T} results in {@code 2011-01-01T00:00:00.001-00:00}. To receive
     * a Timestamp that always maintains the same precision as the original, use
     * {@link #adjustMillis(long)}.
     * milliseconds.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp addMillis(long amount) {
<span class="fc bfc" id="L2156" title="All 8 branches covered.">        if (amount == 0 &amp;&amp; _precision.includes(Precision.SECOND) &amp;&amp; _fraction != null &amp;&amp; _fraction.scale() &gt;= 3) {</span>
            // Zero milliseconds are to be added, and the precision does not need to be increased.
<span class="fc" id="L2158">            return this;</span>
        }
<span class="fc" id="L2160">        return addMillisForPrecision(amount, Precision.SECOND, true);</span>
    }

    /**
     * Adds the given number of milliseconds, extending (if necessary) the resulting Timestamp to the given
     * precision.
     * @param amount the number of milliseconds to add.
     * @param precision the precision that the Timestamp will be extended to, if it does not already include that
     *                  precision.
     * @param millisecondsPrecision true if and only if the `amount` includes milliseconds precision. If true, the
     *                              resulting timestamp's fraction will have precision at least to the millisecond.
     * @return a new Timestamp.
     */
    private Timestamp addMillisForPrecision(long amount, Precision precision, boolean millisecondsPrecision) {
        // When millisecondsPrecision is true, the caller must do its own short-circuiting because it must
        // check the fractional precision.
<span class="fc bfc" id="L2176" title="All 6 branches covered.">        if (!millisecondsPrecision &amp;&amp; amount == 0 &amp;&amp; _precision == precision) return this;</span>
        // This strips off the local offset, expressing our fields as if they
        // were UTC.
<span class="fc" id="L2179">        BigDecimal millis = make_localtime().getDecimalMillis();</span>
<span class="fc" id="L2180">        millis = millis.add(BigDecimal.valueOf(amount));</span>
<span class="fc bfc" id="L2181" title="All 2 branches covered.">        Precision newPrecision = _precision.includes(precision) ? _precision : precision;</span>


<span class="fc" id="L2184">        Timestamp ts = new Timestamp(millis, newPrecision, _offset);</span>
        // Anything with courser-than-millis precision will have been extended
        // to 3 decimal places due to use of getDecimalMillis(). Compensate for
        // that by setting the scale such that it is never extended unless
        // milliseconds precision is being added and the fraction does not yet
        // have milliseconds precision.
<span class="fc bfc" id="L2190" title="All 2 branches covered.">        int newScale = millisecondsPrecision ? 3 : 0;</span>
<span class="fc bfc" id="L2191" title="All 2 branches covered.">        if (_fraction != null) {</span>
<span class="fc" id="L2192">            newScale = Math.max(newScale, _fraction.scale());</span>
        }
<span class="fc bfc" id="L2194" title="All 2 branches covered.">        if (ts._fraction != null) {</span>
<span class="fc bfc" id="L2195" title="All 2 branches covered.">            ts._fraction = newScale == 0 ? null : ts._fraction.setScale(newScale, RoundingMode.FLOOR);</span>
        }
<span class="fc bfc" id="L2197" title="All 4 branches covered.">        if (_offset != null &amp;&amp; _offset != 0)</span>
        {
<span class="fc" id="L2199">            ts.apply_offset(_offset);</span>
        }
<span class="fc" id="L2201">        return ts;</span>
    }

    /**
     * Clears any fields more precise than this Timestamp's precision supports.
     */
    private void clearUnusedPrecision() {
<span class="fc bfc" id="L2208" title="All 5 branches covered.">        switch (_precision) {</span>
            case YEAR:
<span class="fc" id="L2210">                _month = 1;</span>
            case MONTH:
<span class="fc" id="L2212">                _day = 1;</span>
            case DAY:
<span class="fc" id="L2214">                _hour = 0;</span>
<span class="fc" id="L2215">                _minute = 0;</span>
            case MINUTE:
<span class="fc" id="L2217">                _second = 0;</span>
<span class="fc" id="L2218">                _fraction = null;</span>
            case SECOND:
        }
<span class="fc" id="L2221">    }</span>

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T00:00Z} by one
     * second results in {@code 2012-04-01T00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00Z} by -1 second results in
     * {@code 2012-03-31T23:59:59Z}. To extend the precision when the original
     * Timestamp has coarser than SECOND precision, use {@link #addSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp adjustSecond(int amount)
    {
<span class="fc" id="L2237">        long delta = (long) amount * 1000;</span>
<span class="fc" id="L2238">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision.
     * For example, adding one second to {@code 2011T} results in
     * {@code 2011-01-01T00:00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp addSecond(int amount)
    {
<span class="fc" id="L2253">        long delta = (long) amount * 1000;</span>
<span class="fc" id="L2254">        return addMillisForPrecision(delta, Precision.SECOND, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one minute
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 minute results in {@code 2012-03-31T23:59-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp adjustMinute(int amount)
    {
<span class="fc" id="L2271">        long delta = (long) amount * 60 * 1000;</span>
<span class="fc" id="L2272">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one minute to {@code 2011T} results in
     * {@code 2011-01-01T00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp addMinute(int amount)
    {
<span class="fc" id="L2287">        long delta = (long) amount * 60 * 1000;</span>
<span class="fc" id="L2288">        return addMillisForPrecision(delta, Precision.MINUTE, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one hour
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 hour results in {@code 2012-03-31T23:00-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp adjustHour(int amount)
    {
<span class="fc" id="L2305">        long delta = (long) amount * 60 * 60 * 1000;</span>
<span class="fc" id="L2306">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one hour to {@code 2011T} results in
     * {@code 2011-01-01T01:00-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp addHour(int amount)
    {
<span class="fc" id="L2321">        long delta = (long) amount * 60 * 60 * 1000;</span>
<span class="fc" id="L2322">        return addMillisForPrecision(delta, Precision.MINUTE, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04T} by one day results
     * in {@code 2012-04T}; adjusting {@code 2012-04-01T} by -1 days results in
     * {@code 2012-03-31T}. To extend the precision when the original Timestamp
     * has coarser than DAY precision, use {@link #addDay(int)}.
     *
     * @param amount a number of days.
     */
    public final Timestamp adjustDay(int amount)
    {
<span class="fc" id="L2338">        long delta = (long) amount * 24 * 60 * 60 * 1000;</span>
<span class="fc" id="L2339">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     *
     * @param amount a number of days.
     */
    public final Timestamp addDay(int amount)
    {
<span class="fc" id="L2349">        long delta = (long) amount * 24 * 60 * 60 * 1000;</span>
<span class="fc" id="L2350">        return addMillisForPrecision(delta, Precision.DAY, false);</span>
    }

    // Shifting month and year are more complicated since the length of a month
    // varies and we want the day-of-month to stay the same when possible.
    // We rely on Calendar for the logic.

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as the
     * original. For example, adjusting {@code 2011T} by one month results in
     * {@code 2011T}; adding 12 months to {@code 2011T} results in {@code 2012T}.
     * To extend the precision when the original Timestamp has coarser than MONTH
     * precision, use {@link #addMonth(int)}.
     *
     * @param amount a number of months.
     */
    public final Timestamp adjustMonth(int amount)
    {
<span class="pc bpc" id="L2372" title="1 of 2 branches missed.">        if (amount == 0) return this;</span>
<span class="fc" id="L2373">        return addMonthForPrecision(amount, _precision);</span>
    }

    /**
     * Adds the given number of months, extending (if necessary) the resulting Timestamp to the given
     * precision.
     * @param amount the number of months to add.
     * @param precision the precision that the Timestamp will be extended to, if it does not already include that
     *                  precision.
     * @return a new Timestamp.
     */
    private Timestamp addMonthForPrecision(int amount, Precision precision) {
<span class="fc" id="L2385">        Calendar cal = calendarValue();</span>
<span class="fc" id="L2386">        cal.add(Calendar.MONTH, amount);</span>
<span class="fc" id="L2387">        return new Timestamp(cal, precision, _fraction, _offset);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days.  For example, adding one month to {@code 2011-01-31}
     * results in {@code 2011-02-28}.
     *
     * @param amount a number of months.
     */
    public final Timestamp addMonth(int amount)
    {
<span class="pc bpc" id="L2400" title="3 of 4 branches missed.">        if (amount == 0 &amp;&amp; _precision.includes(Precision.MONTH)) return this;</span>
<span class="fc bfc" id="L2401" title="All 2 branches covered.">        return addMonthForPrecision(amount, _precision.includes(Precision.MONTH) ? _precision : Precision.MONTH);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days. For example,
     * adjusting {@code 2012-02-29} by one year results in {@code 2013-02-28}.
     * &lt;p&gt;
     * Because YEAR is the coarsest precision possible, this method always
     * returns a Timestamp with the same precision as the original and
     * behaves identically to {@link #addYear(int)}.
     *
     * @param amount a number of years.
     */
    public final Timestamp adjustYear(int amount) {
<span class="fc" id="L2416">        return addYear(amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days.  For example,
     * adding one year to {@code 2012-02-29} results in {@code 2013-02-28}.
     *
     * @param amount a number of years.
     */
    public final Timestamp addYear(int amount)
    {
<span class="pc bpc" id="L2428" title="1 of 2 branches missed.">        if (amount == 0) return this;</span>

<span class="fc" id="L2430">        Calendar cal = calendarValue();</span>
<span class="fc" id="L2431">        cal.add(Calendar.YEAR, amount);</span>
<span class="fc" id="L2432">        return new Timestamp(cal, _precision, _fraction, _offset);</span>
    }


    //=========================================================================

    /**
     * Returns a hash code consistent with {@link #equals(Object)}.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public int hashCode()
    {
        // Performs a Shift-Add-XOR-Rotate hash. Rotating at each step to
        // produce an &quot;Avalanche&quot; effect for timestamps with small deltas, which
        // is found to be a common input data set.

<span class="fc" id="L2450">        final int prime = 8191;</span>
<span class="fc" id="L2451">        int result = HASH_SIGNATURE;</span>

<span class="fc bfc" id="L2453" title="All 2 branches covered.">        result = prime * result + (_fraction != null</span>
<span class="fc" id="L2454">            ? _fraction.hashCode()</span>
<span class="fc" id="L2455">            : 0);</span>

<span class="fc" id="L2457">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2459">        result = prime * result + this._year;</span>
<span class="fc" id="L2460">        result = prime * result + this._month;</span>
<span class="fc" id="L2461">        result = prime * result + this._day;</span>
<span class="fc" id="L2462">        result = prime * result + this._hour;</span>
<span class="fc" id="L2463">        result = prime * result + this._minute;</span>
<span class="fc" id="L2464">        result = prime * result + this._second;</span>

<span class="fc" id="L2466">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2468">        result = prime * result + this._precision.toString().hashCode();</span>

<span class="fc" id="L2470">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc bfc" id="L2472" title="All 2 branches covered.">        result = prime * result + (_offset == null ? 0 : _offset.hashCode());</span>

<span class="fc" id="L2474">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2476">        return result;</span>
    }



    /**
     * Performs a comparison of the two points in time represented by two
     * Timestamps.
     * If the point in time represented by this Timestamp precedes that of
     * {@code t}, then {@code -1} is returned.
     * If {@code t} precedes this Timestamp then {@code 1} is returned.
     * If the Timestamps represent the same point in time, then
     * {@code 0} is returned.
     * Note that a {@code 0} result does not imply that the two Timestamps are
     * {@link #equals}, as the local offset or precision of the two Timestamps
     * may be different.
     *
     * &lt;p&gt;
     * This method is provided in preference to individual methods for each of
     * the six boolean comparison operators (&amp;lt;, ==, &amp;gt;, &amp;gt;=, !=, &amp;lt;=).
     * The suggested idiom for performing these comparisons is:
     * {@code (x.compareTo(y)}&lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt;{@code 0)},
     * where &lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt; is one of the six comparison operators.
     *
     * &lt;p&gt;
     * For example, the pairs below will return a {@code 0} result:
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2008-12-31T16:00-08:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2008-12-31T12:00-12:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T12:00+12:00}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #equals(Timestamp)} method to compare the point
     * in time, &lt;em&gt;including&lt;/em&gt; precision and local offset.
     *
     * @param t
     *          the other {@code Timestamp} to compare this {@code Timestamp} to
     *
     * @return
     *          -1, 0, or 1 if this {@code Timestamp}
     *          is less than, equal to, or greater than {@code t} respectively
     *
     * @throws NullPointerException if {@code t} is null.
     *
     * @see #equals(Timestamp)
     */
    public int compareTo(Timestamp t)
    {
        // Test at millisecond precision first.
<span class="fc" id="L2534">        long this_millis = this.getMillis();</span>
<span class="fc" id="L2535">        long arg_millis = t.getMillis();</span>
<span class="fc bfc" id="L2536" title="All 2 branches covered.">        if (this_millis != arg_millis) {</span>
<span class="fc bfc" id="L2537" title="All 2 branches covered.">            return (this_millis &lt; arg_millis) ? -1 : 1;</span>
        }

        // Values are equivalent at millisecond precision, so compare fraction

        BigDecimal this_fraction =
<span class="fc bfc" id="L2543" title="All 2 branches covered.">            ((this._fraction == null) ? BigDecimal.ZERO : this._fraction);</span>
        BigDecimal arg_fraction =
<span class="fc bfc" id="L2545" title="All 2 branches covered.">            (( t._fraction == null) ? BigDecimal.ZERO :  t._fraction);</span>
<span class="fc" id="L2546">        return this_fraction.compareTo(arg_fraction);</span>
    }


    /**
     * Compares this {@link Timestamp} to the specified Object.
     * The result is {@code true} if and only if the parameter is a
     * {@link Timestamp} object that represents the same point in time,
     * precision and local offset as this Timestamp.
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #equals(Timestamp)
     * @see #compareTo(Timestamp)
     */
    @Override
    public boolean equals(Object t)
    {
<span class="pc bpc" id="L2565" title="1 of 2 branches missed.">        if (!(t instanceof Timestamp)) return false;</span>
<span class="fc" id="L2566">        return equals((Timestamp)t);</span>
    }

    /**
     * Compares this {@link Timestamp} to another {@link Timestamp} object.
     * The result is {@code true} if and only if the parameter
     * represents the same point in time and has
     * the same precision and local offset as this object.
     * &lt;p&gt;
     * These pairs are {@link #equals} to each other, as they
     * represent the same points in time, precision and local offset:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22+00:00} (minute precision, in UTC)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22Z} (minute precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * On the other hand, none of these pairs are {@link #equals} to each other,
     * they represent the same points in time, but with different precisions
     * and/or local offsets:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001T} (year precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01T} (month precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T} (day precision, unknown local offset)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00-00:00} (second precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00+00:00} (second precision, in UTC)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00.000-00:00} (millisecond precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00.000+00:00} (millisecond precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #compareTo(Timestamp)
     */
    public boolean equals(Timestamp t)
    {
<span class="fc bfc" id="L2608" title="All 2 branches covered.">        if (this == t) return true;</span>
<span class="pc bpc" id="L2609" title="1 of 2 branches missed.">        if (t == null) return false;</span>

        // if the precisions are not the same the values are not
        // precision doesn't matter WRT equality
<span class="fc bfc" id="L2613" title="All 2 branches covered.">        if (this._precision != t._precision) return false;</span>

        // if the local offset are not the same the values are not
<span class="fc bfc" id="L2616" title="All 2 branches covered.">        if (this._offset == null) {</span>
<span class="fc bfc" id="L2617" title="All 2 branches covered.">            if (t._offset != null)  return false;</span>
        }
        else {
<span class="fc bfc" id="L2620" title="All 2 branches covered.">            if (t._offset == null) return false;</span>
        }

        // so now we check the actual time value
<span class="fc bfc" id="L2624" title="All 2 branches covered.">        if (this._year   != t._year)    return false;</span>
<span class="fc bfc" id="L2625" title="All 2 branches covered.">        if (this._month  != t._month)   return false;</span>
<span class="fc bfc" id="L2626" title="All 2 branches covered.">        if (this._day    != t._day)     return false;</span>
<span class="fc bfc" id="L2627" title="All 2 branches covered.">        if (this._hour   != t._hour)    return false;</span>
<span class="fc bfc" id="L2628" title="All 2 branches covered.">        if (this._minute != t._minute)  return false;</span>
<span class="fc bfc" id="L2629" title="All 2 branches covered.">        if (this._second != t._second)  return false;</span>

        // and if we have a local offset, check the value here
<span class="fc bfc" id="L2632" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L2633" title="All 2 branches covered.">            if (this._offset.intValue() != t._offset.intValue()) return false;</span>
        }

        // we only look at the fraction if we know that it's actually there
<span class="fc bfc" id="L2637" title="All 8 branches covered.">        if ((this._fraction != null &amp;&amp; t._fraction == null)</span>
            || (this._fraction == null &amp;&amp; t._fraction != null)) {
            // one of the fractions are null
<span class="fc" id="L2640">            return false;</span>
        }
<span class="pc bpc" id="L2642" title="1 of 4 branches missed.">        if (this._fraction == null &amp;&amp; t._fraction == null) {</span>
            // both are null
<span class="fc" id="L2644">            return true;</span>
        }
<span class="fc" id="L2646">        return this._fraction.equals(t._fraction);</span>
    }

    private static short checkAndCastYear(int year)
    {
<span class="fc bfc" id="L2651" title="All 4 branches covered.">        if (year &lt; 1 || year &gt; 9999)</span>
        {
<span class="fc" id="L2653">            throw new IllegalArgumentException(String.format(&quot;Year %s must be between 1 and 9999 inclusive&quot;, year));</span>
        }

<span class="fc" id="L2656">        return (short) year;</span>
    }

    private static byte checkAndCastMonth(int month)
    {
<span class="fc bfc" id="L2661" title="All 4 branches covered.">        if (month &lt; 1 || month &gt; 12)</span>
        {
<span class="fc" id="L2663">            throw new IllegalArgumentException(String.format(&quot;Month %s must be between 1 and 12 inclusive&quot;, month));</span>
        }

<span class="fc" id="L2666">        return (byte) month;</span>
    }

    private static byte checkAndCastDay(int day, int year, int month)
    {
<span class="fc" id="L2671">        int lastDayInMonth = last_day_in_month(year, month);</span>
<span class="fc bfc" id="L2672" title="All 4 branches covered.">        if (day &lt; 1 || day &gt; lastDayInMonth) {</span>
<span class="fc" id="L2673">            throw new IllegalArgumentException(String.format(&quot;Day %s for year %s and month %s must be between 1 and %s inclusive&quot;, day, year, month, lastDayInMonth));</span>
        }

<span class="fc" id="L2676">        return (byte) day;</span>
    }

    private static byte checkAndCastHour(int hour)
    {
<span class="pc bpc" id="L2681" title="1 of 4 branches missed.">        if (hour &lt; 0 || hour &gt; 23)</span>
        {
<span class="fc" id="L2683">            throw new IllegalArgumentException(String.format(&quot;Hour %s must be between 0 and 23 inclusive&quot;, hour));</span>
        }

<span class="fc" id="L2686">        return (byte) hour;</span>
    }

    private static byte checkAndCastMinute(int minute)
    {
<span class="pc bpc" id="L2691" title="1 of 4 branches missed.">        if (minute &lt; 0 || minute &gt; 59)</span>
        {
<span class="fc" id="L2693">            throw new IllegalArgumentException(String.format(&quot;Minute %s must be between between 0 and 59 inclusive&quot;, minute));</span>
        }

<span class="fc" id="L2696">        return (byte) minute;</span>
    }

    private static byte checkAndCastSecond(int second)
    {
<span class="fc bfc" id="L2701" title="All 4 branches covered.">        if (second &lt; 0 || second &gt; 59)</span>
        {
<span class="fc" id="L2703">            throw new IllegalArgumentException(String.format(&quot;Second %s must be between between 0 and 59 inclusive&quot;, second));</span>
        }

<span class="fc" id="L2706">        return (byte) second;</span>
    }

    private static Precision checkFraction(Precision precision, BigDecimal fraction)
    {
<span class="fc bfc" id="L2711" title="All 2 branches covered.">        if (precision.includes(Precision.SECOND)) {</span>
<span class="pc bpc" id="L2712" title="1 of 6 branches missed.">            if (fraction != null &amp;&amp; (fraction.signum() == -1 || BigDecimal.ONE.compareTo(fraction) != 1)) {</span>
<span class="fc" id="L2713">                throw new IllegalArgumentException(String.format(&quot;Fractional seconds %s must be greater than or equal to 0 and less than 1&quot;, fraction));</span>
            }
        }
        else {
<span class="pc bpc" id="L2717" title="1 of 2 branches missed.">            if (fraction != null) {</span>
<span class="nc" id="L2718">                throw new IllegalArgumentException(&quot;Fraction must be null for non-second precision: &quot; + fraction);</span>
            }
        }

<span class="fc" id="L2722">        return precision;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>